========================================================================
PLTelemetry Complete Source Bundle
Generated on: Mon Jun 23 14:28:48 GMTDT 2025
From: /e/CORE/Github/pltelemetry
========================================================================

TABLE OF CONTENTS:

./bridges/postgresql/oracle/examples/basic_integration.sql
./bridges/postgresql/oracle/examples/job_setup.sql
./bridges/postgresql/oracle/examples/pg_sample_data.sql
./bridges/postgresql/oracle/examples/sync_mode.sql
./bridges/postgresql/oracle/src/install.sql
./bridges/postgresql/schema/01-database-setup.sql
./examples/basic_usage.sql
./examples/error_handling.sql
./examples/ords_integration.sql
./install/grants/plt_grants.sql
./install/install.sql
./install/jobs/plt_cleanup_job.sql
./install/jobs/plt_queue_processor.sql
./install/tables/plt_indexes.sql
./install/tables/plt_tables.sql
./tests/basic_functionality.sql
./tests/test_error_handling.sql
./tests/test_performance.sql
./bridges/postgresql/oracle/src/PLT_POSTGRES_BRIDGE.pks
./src/PLTelemetry.pks
./bridges/postgresql/oracle/src/PLT_POSTGRES_BRIDGE.pkb
./src/PLTelemetry.pkb
./CONTRIBUTING.md
./README.md
./bridge/README.md
./bridges/README.md
./bridges/postgresql/nodejs/README.md
./pltelemetry-complete-bundle.txt
./bridges/postgresql/schema/02-postgrest-config.conf
./bundle-pltelemetry.sh
./bridge/package.json
./bridges/postgresql/nodejs/package.json

========================================================================


========================================================================
FILE: bridges/postgresql/oracle/examples/basic_integration.sql
SIZE: 3850 bytes
MODIFIED: ./bridges/postgresql/oracle/examples/basic_integration.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550587 1550587 18446744073709551615 -1
2025-06-23 14:10:34.062447000
========================================================================

-- ============================================
-- FILE: basic_integration.sql
-- PostgreSQL Bridge - Basic Integration Example
-- ============================================

/*
This example demonstrates the basic setup and usage of the PostgreSQL bridge
for PLTelemetry. It covers configuration, simple trace creation, and verification.
*/

-- Prerequisites:
-- 1. PLTelemetry core package installed
-- 2. PLT_POSTGRES_BRIDGE package installed
-- 3. PostgreSQL with telemetry schema created
-- 4. PostgREST running on port 3000

SET SERVEROUTPUT ON SIZE UNLIMITED

-- Step 1: Configure the bridge
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== CONFIGURING POSTGRESQL BRIDGE ===');
    
    -- Set PLTelemetry to use the PostgreSQL bridge
    PLTelemetry.set_backend_url('POSTGRES_BRIDGE');
    
    -- Enable autocommit for immediate processing
    PLTelemetry.set_autocommit(TRUE);
    
    -- Configure the bridge endpoint
    PLT_POSTGRES_BRIDGE.set_postgrest_url('http://localhost:3000');
    
    -- Optional: Set timeout for HTTP calls
    PLT_POSTGRES_BRIDGE.set_timeout(30);
    
    DBMS_OUTPUT.PUT_LINE('✓ Configuration complete');
END;
/

-- Step 2: Create a simple trace with span and metric
DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('=== CREATING TELEMETRY DATA ===');
    
    -- Start a new trace
    l_trace_id := PLT_POSTGRES_BRIDGE.start_trace_with_postgres('user_registration');
    DBMS_OUTPUT.PUT_LINE('Trace started: ' || l_trace_id);
    
    -- Create a span for validation process
    l_span_id := PLTelemetry.start_span('validate_user_data');
    
    -- Add some attributes
    l_attrs(1) := PLTelemetry.add_attribute('user.type', 'premium');
    l_attrs(2) := PLTelemetry.add_attribute('user.country', 'ES');
    l_attrs(3) := PLTelemetry.add_attribute('validation.rules', '5');
    
    -- Simulate some work
    DBMS_LOCK.sleep(0.5);
    
    -- Add an event
    PLTelemetry.add_event(l_span_id, 'email_validated', l_attrs);
    
    -- End the span with status
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    
    -- Log a metric (IMPORTANT: After span ends in sync mode!)
    PLTelemetry.log_metric('validation_duration', 500, 'ms', l_attrs);
    
    -- End the trace
    PLTelemetry.end_trace(l_trace_id);
    
    DBMS_OUTPUT.PUT_LINE('✓ Telemetry data created');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('=== VERIFICATION QUERIES ===');
    DBMS_OUTPUT.PUT_LINE('Run these in PostgreSQL to verify:');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('-- Check trace:');
    DBMS_OUTPUT.PUT_LINE('SELECT * FROM telemetry.traces WHERE trace_id = ''' || l_trace_id || ''';');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('-- Check span:');
    DBMS_OUTPUT.PUT_LINE('SELECT * FROM telemetry.spans WHERE trace_id = ''' || l_trace_id || ''';');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('-- Check metrics:');
    DBMS_OUTPUT.PUT_LINE('SELECT * FROM telemetry.metrics WHERE trace_id = ''' || l_trace_id || ''';');
END;
/

-- Step 3: Check for any errors
PROMPT
PROMPT Checking for errors...
SELECT error_time, error_message, module_name
FROM plt_telemetry_errors
WHERE error_time > SYSTIMESTAMP - INTERVAL '5' MINUTE
ORDER BY error_time DESC;

-- Step 4: View queue status (if using async mode)
PROMPT
PROMPT Queue status:
SELECT 
    (SELECT COUNT(*) FROM plt_queue WHERE processed = 'N') as pending_items,
    (SELECT COUNT(*) FROM plt_queue WHERE processed = 'Y' AND processed_time > SYSTIMESTAMP - INTERVAL '1' HOUR) as processed_last_hour,
    (SELECT MAX(processed_time) FROM plt_queue WHERE processed = 'Y') as last_processed
FROM dual;
[END OF FILE: bridges/postgresql/oracle/examples/basic_integration.sql]


========================================================================
FILE: bridges/postgresql/oracle/examples/job_setup.sql
SIZE: 7894 bytes
MODIFIED: ./bridges/postgresql/oracle/examples/job_setup.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550586 1550586 18446744073709551615 -1
2025-06-23 14:11:13.486329000
========================================================================

-- ============================================
-- FILE: job_setup.sql
-- PostgreSQL Bridge - Job Setup Example
-- ============================================

/*
This example shows how to set up automated queue processing jobs
for the PostgreSQL bridge when using asynchronous mode.
*/

SET SERVEROUTPUT ON SIZE UNLIMITED

-- Step 1: Configure for async mode with PostgreSQL bridge
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== CONFIGURING ASYNC MODE WITH JOBS ===');
    
    -- Set async mode
    PLTelemetry.set_async_mode(TRUE);
    PLTelemetry.set_backend_url('POSTGRES_BRIDGE');
    PLTelemetry.set_autocommit(TRUE);
    PLT_POSTGRES_BRIDGE.set_postgrest_url('http://localhost:3000');
    
    DBMS_OUTPUT.PUT_LINE('✓ Async mode configured');
END;
/

-- Step 2: Create the main processing job
BEGIN
    -- Drop existing job if exists
    BEGIN
        DBMS_SCHEDULER.DROP_JOB('PLTELEMETRY_PROCESS_QUEUE', TRUE);
    EXCEPTION
        WHEN OTHERS THEN NULL;
    END;
    
    -- Create new job
    DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'PLTELEMETRY_PROCESS_QUEUE',
        job_type        => 'PLSQL_BLOCK',
        job_action      => '
        DECLARE
            l_start_time TIMESTAMP := SYSTIMESTAMP;
            l_processed  NUMBER;
            l_pending    NUMBER;
        BEGIN
            -- Get initial count
            SELECT COUNT(*) INTO l_pending 
            FROM plt_queue 
            WHERE processed = ''N'';
            
            IF l_pending > 0 THEN
                -- Process up to 100 items
                PLTelemetry.process_queue(100);
                
                -- Log results
                SELECT COUNT(*) INTO l_processed
                FROM plt_queue 
                WHERE processed = ''Y''
                AND processed_time >= l_start_time;
                
                INSERT INTO plt_telemetry_errors (
                    error_time, 
                    error_message, 
                    module_name
                ) VALUES (
                    SYSTIMESTAMP,
                    ''Queue processed: '' || l_processed || '' items in '' ||
                    ROUND(EXTRACT(SECOND FROM (SYSTIMESTAMP - l_start_time)), 2) || '' seconds'',
                    ''QUEUE_JOB''
                );
                COMMIT;
            END IF;
        END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=SECONDLY; INTERVAL=30',  -- Every 30 seconds
        enabled         => FALSE,  -- Start disabled
        comments        => 'Process PLTelemetry queue for PostgreSQL bridge'
    );
    
    DBMS_OUTPUT.PUT_LINE('✓ Main processing job created (disabled)');
END;
/

-- Step 3: Create a high-frequency job for production
BEGIN
    -- Drop if exists
    BEGIN
        DBMS_SCHEDULER.DROP_JOB('PLTELEMETRY_PROCESS_QUEUE_FAST', TRUE);
    EXCEPTION
        WHEN OTHERS THEN NULL;
    END;
    
    -- Create fast processing job
    DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'PLTELEMETRY_PROCESS_QUEUE_FAST',
        job_type        => 'PLSQL_BLOCK',
        job_action      => '
        BEGIN
            -- Only run if there are items to process
            FOR i IN (
                SELECT 1 FROM plt_queue 
                WHERE processed = ''N'' 
                AND ROWNUM = 1
            ) LOOP
                -- Process smaller batches more frequently
                PLTelemetry.process_queue(25);
            END LOOP;
        END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=SECONDLY; INTERVAL=5',  -- Every 5 seconds
        enabled         => FALSE,
        comments        => 'High-frequency PLTelemetry queue processor'
    );
    
    DBMS_OUTPUT.PUT_LINE('✓ Fast processing job created (disabled)');
END;
/

-- Step 4: Create cleanup job for old processed entries
BEGIN
    -- Drop if exists
    BEGIN
        DBMS_SCHEDULER.DROP_JOB('PLTELEMETRY_CLEANUP_QUEUE', TRUE);
    EXCEPTION
        WHEN OTHERS THEN NULL;
    END;
    
    -- Create cleanup job
    DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'PLTELEMETRY_CLEANUP_QUEUE',
        job_type        => 'PLSQL_BLOCK',
        job_action      => '
        DECLARE
            l_deleted NUMBER;
        BEGIN
            -- Delete processed entries older than 7 days
            DELETE FROM plt_queue 
            WHERE processed = ''Y'' 
            AND processed_time < SYSTIMESTAMP - INTERVAL ''7'' DAY;
            
            l_deleted := SQL%ROWCOUNT;
            
            -- Also delete failed entries older than 30 days
            DELETE FROM plt_queue 
            WHERE processed = ''N'' 
            AND process_attempts >= 5
            AND created_time < SYSTIMESTAMP - INTERVAL ''30'' DAY;
            
            l_deleted := l_deleted + SQL%ROWCOUNT;
            
            -- Delete old error logs
            DELETE FROM plt_telemetry_errors
            WHERE error_time < SYSTIMESTAMP - INTERVAL ''30'' DAY
            AND module_name IN (''QUEUE_JOB'', ''process_queue'');
            
            l_deleted := l_deleted + SQL%ROWCOUNT;
            
            IF l_deleted > 0 THEN
                INSERT INTO plt_telemetry_errors (
                    error_time, 
                    error_message, 
                    module_name
                ) VALUES (
                    SYSTIMESTAMP,
                    ''Cleanup completed: '' || l_deleted || '' records deleted'',
                    ''CLEANUP_JOB''
                );
            END IF;
            
            COMMIT;
        END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=DAILY; BYHOUR=2; BYMINUTE=0',  -- Daily at 2 AM
        enabled         => FALSE,
        comments        => 'Cleanup old PLTelemetry queue entries'
    );
    
    DBMS_OUTPUT.PUT_LINE('✓ Cleanup job created (disabled)');
END;
/

-- Step 5: View all jobs
PROMPT
PROMPT Created jobs:
SELECT 
    job_name,
    enabled,
    state,
    repeat_interval,
    comments
FROM user_scheduler_jobs
WHERE job_name LIKE 'PLTELEMETRY%'
ORDER BY job_name;

-- Step 6: Test the job processing
DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('=== TESTING ASYNC MODE ===');
    
    -- Create some test data
    l_trace_id := PLT_POSTGRES_BRIDGE.start_trace_with_postgres('job_test');
    l_span_id := PLTelemetry.start_span('test_operation');
    
    DBMS_LOCK.sleep(0.1);
    
    PLTelemetry.end_span(l_span_id, 'OK');
    PLTelemetry.log_metric('test_metric', 123, 'value');
    
    DBMS_OUTPUT.PUT_LINE('Trace created: ' || l_trace_id);
    
    -- Check queue
    FOR rec IN (
        SELECT COUNT(*) as cnt 
        FROM plt_queue 
        WHERE processed = 'N'
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('Items in queue: ' || rec.cnt);
    END LOOP;
END;
/

-- Step 7: Enable and test a job
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('=== ENABLING AND TESTING JOB ===');
    
    -- Enable the main job
    DBMS_SCHEDULER.ENABLE('PLTELEMETRY_PROCESS_QUEUE');
    DBMS_OUTPUT.PUT_LINE('✓ Job enabled');
    
    -- Run it manually once
    DBMS_SCHEDULER.RUN_JOB('PLTELEMETRY_PROCESS_QUEUE', FALSE);
    DBMS_OUTPUT.PUT_LINE('✓ Job executed manually');
    
    -- Check results
    FOR rec IN (
        SELECT error_message 
        FROM plt_telemetry_errors 
        WHERE module_name = 'QUEUE_JOB'
        AND error_time > SYSTIMESTAMP - INTERVAL '1' MINUTE
        ORDER BY error_time DESC
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('Job log: ' || rec.error_message);
        EXIT; -- Just show the latest
    END LOOP;
END;
/
[END OF FILE: bridges/postgresql/oracle/examples/job_setup.sql]


========================================================================
FILE: bridges/postgresql/oracle/examples/pg_sample_data.sql
SIZE: 17660 bytes
MODIFIED: ./bridges/postgresql/oracle/examples/pg_sample_data.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550584 1550584 18446744073709551615 -1
2025-06-23 14:13:46.302005600
========================================================================

-- Sample Data for PLTelemetry Demo
-- This script creates realistic telemetry data for testing and demo purposes

\c pltelemetry_db;
SET search_path TO telemetry, public;

-- ========================================================================
-- SAMPLE TRACES AND SPANS
-- ========================================================================

-- Sample trace 1: Customer order processing
INSERT INTO telemetry.traces (trace_id, root_operation, start_time, end_time, service_name, service_instance)
VALUES 
('a1b2c3d4e5f6789012345678901234ab', 'process_customer_order', 
 NOW() - INTERVAL '1 hour', NOW() - INTERVAL '59 minutes', 
 'oracle-crm', 'prod-db-01:ORCL');

-- Spans for order processing
INSERT INTO telemetry.spans (span_id, trace_id, parent_span_id, operation_name, start_time, end_time, duration_ms, status)
VALUES 
('a1b2c3d4e5f67890', 'a1b2c3d4e5f6789012345678901234ab', NULL, 'validate_customer', 
 NOW() - INTERVAL '1 hour', NOW() - INTERVAL '59 minutes 50 seconds', 245.67, 'OK'),
('b2c3d4e5f6789012', 'a1b2c3d4e5f6789012345678901234ab', 'a1b2c3d4e5f67890', 'check_credit_limit', 
 NOW() - INTERVAL '59 minutes 45 seconds', NOW() - INTERVAL '59 minutes 35 seconds', 156.23, 'OK'),
('c3d4e5f678901234', 'a1b2c3d4e5f6789012345678901234ab', 'a1b2c3d4e5f67890', 'reserve_inventory', 
 NOW() - INTERVAL '59 minutes 30 seconds', NOW() - INTERVAL '59 minutes 25 seconds', 423.89, 'OK'),
('d4e5f67890123456', 'a1b2c3d4e5f6789012345678901234ab', NULL, 'process_payment', 
 NOW() - INTERVAL '59 minutes 20 seconds', NOW() - INTERVAL '59 minutes 15 seconds', 1234.56, 'OK');

-- Sample trace 2: Error scenario
INSERT INTO telemetry.traces (trace_id, root_operation, start_time, end_time, service_name, service_instance)
VALUES 
('f1e2d3c4b5a6987654321098765432ef', 'process_refund', 
 NOW() - INTERVAL '30 minutes', NOW() - INTERVAL '28 minutes', 
 'oracle-crm', 'prod-db-01:ORCL');

-- Spans with errors
INSERT INTO telemetry.spans (span_id, trace_id, parent_span_id, operation_name, start_time, end_time, duration_ms, status)
VALUES 
('f1e2d3c4b5a69876', 'f1e2d3c4b5a6987654321098765432ef', NULL, 'validate_refund_request', 
 NOW() - INTERVAL '30 minutes', NOW() - INTERVAL '29 minutes 45 seconds', 543.21, 'OK'),
('e1d2c3b4a5968765', 'f1e2d3c4b5a6987654321098765432ef', 'f1e2d3c4b5a69876', 'check_original_payment', 
 NOW() - INTERVAL '29 minutes 40 seconds', NOW() - INTERVAL '29 minutes 30 seconds', 234.56, 'ERROR'),
('d1c2b3a495867543', 'f1e2d3c4b5a6987654321098765432ef', 'f1e2d3c4b5a69876', 'reverse_payment', 
 NOW() - INTERVAL '29 minutes 25 seconds', NOW() - INTERVAL '28 minutes 5 seconds', 891.23, 'ERROR');

-- Sample trace 3: Recent activity
INSERT INTO telemetry.traces (trace_id, root_operation, start_time, service_name, service_instance)
VALUES 
('1234567890abcdef1234567890abcdef', 'generate_monthly_report', 
 NOW() - INTERVAL '5 minutes', 
 'oracle-reporting', 'prod-db-02:ORCL');

-- Long-running spans
INSERT INTO telemetry.spans (span_id, trace_id, parent_span_id, operation_name, start_time, end_time, duration_ms, status)
VALUES 
('1234567890abcdef', '1234567890abcdef1234567890abcdef', NULL, 'collect_data', 
 NOW() - INTERVAL '5 minutes', NOW() - INTERVAL '3 minutes', 120000.45, 'OK'),
('234567890abcdef1', '1234567890abcdef1234567890abcdef', '1234567890abcdef', 'aggregate_sales', 
 NOW() - INTERVAL '4 minutes 30 seconds', NOW() - INTERVAL '3 minutes 45 seconds', 45000.67, 'OK'),
('34567890abcdef12', '1234567890abcdef1234567890abcdef', '1234567890abcdef', 'calculate_metrics', 
 NOW() - INTERVAL '3 minutes 30 seconds', NOW() - INTERVAL '2 minutes 15 seconds', 75000.89, 'OK');

-- ========================================================================
-- SAMPLE EVENTS
-- ========================================================================

INSERT INTO telemetry.events (span_id, event_name, event_time, attributes)
VALUES 
('a1b2c3d4e5f67890', 'customer_validated', 
 NOW() - INTERVAL '59 minutes 55 seconds',
 '{"customer.id": "12345", "customer.type": "premium", "validation.method": "oauth"}'),
('b2c3d4e5f6789012', 'credit_check_completed', 
 NOW() - INTERVAL '59 minutes 40 seconds',
 '{"credit.limit": "50000", "credit.available": "35000", "check.result": "approved"}'),
('c3d4e5f678901234', 'inventory_reserved', 
 NOW() - INTERVAL '59 minutes 28 seconds',
 '{"item.sku": "PROD-001", "quantity": "2", "warehouse": "WH-MADRID"}'),
('d4e5f67890123456', 'payment_processed', 
 NOW() - INTERVAL '59 minutes 16 seconds',
 '{"payment.method": "credit_card", "amount": "299.99", "currency": "EUR", "processor": "stripe"}'),
('e1d2c3b4a5968765', 'payment_lookup_failed', 
 NOW() - INTERVAL '29 minutes 35 seconds',
 '{"error.code": "PAYMENT_NOT_FOUND", "payment.id": "pay_12345", "retry.attempt": "1"}'),
('1234567890abcdef', 'data_collection_started', 
 NOW() - INTERVAL '4 minutes 55 seconds',
 '{"report.type": "monthly", "period": "2025-05", "tables.count": "23"}'),
('234567890abcdef1', 'sales_aggregation_completed', 
 NOW() - INTERVAL '3 minutes 50 seconds',
 '{"records.processed": "156789", "sales.total": "2340567.89", "currency": "EUR"}');

-- ========================================================================
-- SAMPLE METRICS
-- ========================================================================

-- Performance metrics
INSERT INTO telemetry.metrics (metric_name, metric_value, metric_unit, trace_id, span_id, timestamp, attributes)
VALUES 
('order_processing_time', 1234.56, 'milliseconds', 'a1b2c3d4e5f6789012345678901234ab', 'd4e5f67890123456', 
 NOW() - INTERVAL '59 minutes', '{"customer.type": "premium", "order.items": "3"}'),
('credit_check_duration', 156.23, 'milliseconds', 'a1b2c3d4e5f6789012345678901234ab', 'b2c3d4e5f6789012', 
 NOW() - INTERVAL '59 minutes', '{"credit.provider": "experian", "cache.hit": "false"}'),
('inventory_reserve_time', 423.89, 'milliseconds', 'a1b2c3d4e5f6789012345678901234ab', 'c3d4e5f678901234', 
 NOW() - INTERVAL '59 minutes', '{"warehouse": "WH-MADRID", "item.category": "electronics"}'),
('payment_processing_time', 1234.56, 'milliseconds', 'a1b2c3d4e5f6789012345678901234ab', 'd4e5f67890123456', 
 NOW() - INTERVAL '59 minutes', '{"payment.processor": "stripe", "payment.method": "credit_card"}'),
('refund_validation_time', 543.21, 'milliseconds', 'f1e2d3c4b5a6987654321098765432ef', 'f1e2d3c4b5a69876', 
 NOW() - INTERVAL '30 minutes', '{"refund.reason": "defective_product", "customer.tier": "gold"}'),
('data_collection_duration', 120000.45, 'milliseconds', '1234567890abcdef1234567890abcdef', '1234567890abcdef', 
 NOW() - INTERVAL '4 minutes', '{"report.type": "monthly", "data.volume": "156GB"}'),
('sales_aggregation_time', 45000.67, 'milliseconds', '1234567890abcdef1234567890abcdef', '234567890abcdef1', 
 NOW() - INTERVAL '3 minutes 50 seconds', '{"records.count": "156789", "aggregation.type": "sum"}');

-- Business metrics
INSERT INTO telemetry.metrics (metric_name, metric_value, metric_unit, trace_id, span_id, timestamp, attributes)
VALUES 
('order_value', 299.99, 'EUR', 'a1b2c3d4e5f6789012345678901234ab', 'd4e5f67890123456', 
 NOW() - INTERVAL '59 minutes', '{"customer.segment": "premium", "order.channel": "web"}'),
('items_ordered', 3, 'count', 'a1b2c3d4e5f6789012345678901234ab', 'c3d4e5f678901234', 
 NOW() - INTERVAL '59 minutes', '{"product.category": "electronics", "discount.applied": "10"}'),
('credit_utilization', 0.7, 'percentage', 'a1b2c3d4e5f6789012345678901234ab', 'b2c3d4e5f6789012', 
 NOW() - INTERVAL '59 minutes', '{"customer.credit_limit": "50000", "customer.age": "5_years"}'),
('refund_amount', 149.99, 'EUR', 'f1e2d3c4b5a6987654321098765432ef', 'f1e2d3c4b5a69876', 
 NOW() - INTERVAL '30 minutes', '{"refund.type": "partial", "original.order": "ORD-98765"}'),
('report_data_volume', 156.7, 'GB', '1234567890abcdef1234567890abcdef', '1234567890abcdef', 
 NOW() - INTERVAL '4 minutes', '{"compression.ratio": "0.3", "source.tables": "23"}'),
('monthly_sales_total', 2340567.89, 'EUR', '1234567890abcdef1234567890abcdef', '234567890abcdef1', 
 NOW() - INTERVAL '3 minutes 50 seconds', '{"month": "2025-05", "growth.rate": "12.5"}');

-- System metrics
INSERT INTO telemetry.metrics (metric_name, metric_value, metric_unit, trace_id, span_id, timestamp, attributes)
VALUES 
('database_connections', 45, 'count', 'a1b2c3d4e5f6789012345678901234ab', 'a1b2c3d4e5f67890', 
 NOW() - INTERVAL '59 minutes', '{"pool.max": "100", "pool.active": "45", "db.instance": "ORCL"}'),
('memory_usage', 2.3, 'GB', 'a1b2c3d4e5f6789012345678901234ab', 'b2c3d4e5f6789012', 
 NOW() - INTERVAL '59 minutes', '{"process.name": "oracle", "heap.size": "4GB"}'),
('cpu_utilization', 0.65, 'percentage', 'f1e2d3c4b5a6987654321098765432ef', 'e1d2c3b4a5968765', 
 NOW() - INTERVAL '29 minutes', '{"cores": "8", "load.avg": "3.2"}'),
-- LÍNEA CORREGIDA:
('network_latency', 23.5, 'milliseconds', 'a1b2c3d4e5f6789012345678901234ab', 'd4e5f67890123456', 
 NOW() - INTERVAL '59 minutes', '{"endpoint": "payment.api", "region": "eu-west-1"}'),
('disk_io_wait', 12.3, 'milliseconds', '1234567890abcdef1234567890abcdef', '1234567890abcdef', 
 NOW() - INTERVAL '4 minutes', '{"disk.type": "SSD", "operation": "read", "volume": "data"}');

-- ========================================================================
-- SAMPLE ERROR SCENARIOS
-- ========================================================================

-- Error logs
INSERT INTO telemetry.telemetry_errors (error_time, error_message, error_stack, error_code, module_name, trace_id, span_id, session_user_id, host)
VALUES 
(NOW() - INTERVAL '29 minutes 35 seconds', 
 'Payment record not found in external system', 
 'ORA-20001: PAYMENT_NOT_FOUND at line 245\ncheck_original_payment(pay_12345)\nprocess_refund_request()', 
 -20001, 'check_original_payment', 'f1e2d3c4b5a6987654321098765432ef', 'e1d2c3b4a5968765', 
 'CRM_USER', 'prod-db-01'),
(NOW() - INTERVAL '29 minutes 20 seconds', 
 'Timeout connecting to payment gateway', 
 'UTL_HTTP.TRANSFER_TIMEOUT\nreverse_payment()\nprocess_refund_request()', 
 -29273, 'reverse_payment', 'f1e2d3c4b5a6987654321098765432ef', 'd1c2b3a495867543', 
 'CRM_USER', 'prod-db-01'),
(NOW() - INTERVAL '15 minutes', 
 'Invalid JSON format in telemetry payload', 
 'JSON_PARSE_ERROR at character 45\nattributes_to_json()\nend_span()', 
 -40441, 'end_span', NULL, NULL, 
 'TELEMETRY_USER', 'prod-db-01'),
(NOW() - INTERVAL '8 minutes', 
 'Database connection pool exhausted', 
 'ORA-12516: TNS:listener could not find available handler\nget_connection()\nstart_trace()', 
 -12516, 'start_trace', NULL, NULL, 
 'APP_USER', 'prod-db-02'),
(NOW() - INTERVAL '2 minutes', 
 'Span end time before start time detected', 
 'INVALID_TIME_RANGE\nvalidate_span_duration()\nend_span()', 
 -20002, 'end_span', '1234567890abcdef1234567890abcdef', '34567890abcdef12', 
 'REPORTING_USER', 'prod-db-02');

-- Failed exports
INSERT INTO telemetry.failed_exports (export_time, http_status, payload, error_message, retry_count)
VALUES 
(NOW() - INTERVAL '45 minutes', 503, 
 '{"trace_id":"a1b2c3d4e5f6789012345678901234ab","span_id":"d4e5f67890123456","operation":"end_span"...', 
 'Service Unavailable: Backend telemetry service temporarily down', 2),
(NOW() - INTERVAL '32 minutes', 408, 
 '{"metric_name":"payment_processing_time","value":1234.56,"trace_id":"a1b2c3d4e5f6789012345678901234ab"...', 
 'Request Timeout: Backend took longer than 30 seconds to respond', 1),
(NOW() - INTERVAL '12 minutes', 413, 
 '{"trace_id":"1234567890abcdef1234567890abcdef","span_id":"1234567890abcdef","attributes":{"large_field":"very long data..."...', 
 'Payload Too Large: Request body exceeds 4MB limit', 3),
(NOW() - INTERVAL '5 minutes', 400, 
 '{"trace_id":"invalid-trace-id","span_id":"also-invalid","operation":"end_span"}', 
 'Bad Request: Invalid trace_id format - must be 32 hex characters', 0);

-- Queue entries (some processed, some pending)
INSERT INTO telemetry.queue (payload, created_at, processed, process_attempts, processed_time, last_error)
VALUES 
('{"trace_id":"a1b2c3d4e5f6789012345678901234ab","operation":"trace_complete"}', 
 NOW() - INTERVAL '1 hour', true, 1, NOW() - INTERVAL '59 minutes', NULL),
('{"metric_name":"order_completion_rate","value":0.95,"timestamp":"' || (NOW() - INTERVAL '30 minutes')::text || '"}', 
 NOW() - INTERVAL '35 minutes', true, 1, NOW() - INTERVAL '34 minutes', NULL),
('{"trace_id":"f1e2d3c4b5a6987654321098765432ef","operation":"trace_error"}', 
 NOW() - INTERVAL '25 minutes', false, 2, NULL, 'Connection refused: Backend service not responding'),
('{"span_id":"pending_span_001","operation":"span_timeout_warning"}', 
 NOW() - INTERVAL '10 minutes', false, 0, NULL, NULL),
('{"metric_name":"system_health_check","value":1,"timestamp":"' || (NOW() - INTERVAL '2 minutes')::text || '"}', 
 NOW() - INTERVAL '3 minutes', false, 1, NULL, 'HTTP 502: Bad Gateway');

-- ========================================================================
-- SAMPLE DATA FOR PERFORMANCE TESTING
-- ========================================================================

-- Generate additional traces for volume testing
DO $$
DECLARE
    i INTEGER;
    trace_id_val VARCHAR(32);
    span_id_val VARCHAR(16);
    operation_names TEXT[] := ARRAY['user_login', 'product_search', 'add_to_cart', 'checkout_process', 'inventory_check', 'price_calculation'];
    service_names TEXT[] := ARRAY['oracle-crm', 'oracle-inventory', 'oracle-pricing', 'oracle-auth'];
    statuses TEXT[] := ARRAY['OK', 'OK', 'OK', 'OK', 'ERROR'];  -- 80% OK, 20% ERROR
BEGIN
    FOR i IN 1..50 LOOP
        -- Generate random IDs
        trace_id_val := LPAD(TO_HEX(i), 32, '0');
        span_id_val := LPAD(TO_HEX(i), 16, '0');
        
        -- Insert trace
        INSERT INTO telemetry.traces (trace_id, root_operation, start_time, end_time, service_name, service_instance)
        VALUES (
            trace_id_val,
            operation_names[1 + (i % array_length(operation_names, 1))],
            NOW() - (INTERVAL '1 minute' * (i + random() * 60)),
            NOW() - (INTERVAL '1 minute' * (i + random() * 30)),
            service_names[1 + (i % array_length(service_names, 1))],
            'load-test-db:ORCL'
        );
        
        -- Insert span
        INSERT INTO telemetry.spans (span_id, trace_id, operation_name, start_time, end_time, duration_ms, status)
        VALUES (
            span_id_val,
            trace_id_val,
            operation_names[1 + (i % array_length(operation_names, 1))],
            NOW() - (INTERVAL '1 minute' * (i + random() * 60)),
            NOW() - (INTERVAL '1 minute' * (i + random() * 30)),
            (random() * 5000 + 100)::DECIMAL(15,3),
            statuses[1 + (i % array_length(statuses, 1))]
        );
        
        -- Insert metric
        INSERT INTO telemetry.metrics (metric_name, metric_value, metric_unit, trace_id, span_id, timestamp)
        VALUES (
            'response_time',
            (random() * 2000 + 50)::DECIMAL(20,6),
            'milliseconds',
            trace_id_val,
            span_id_val,
            NOW() - (INTERVAL '1 minute' * (i + random() * 60))
        );
    END LOOP;
END $$;

-- ========================================================================
-- SUMMARY VIEWS FOR GRAFANA (Optional)
-- ========================================================================

-- Create a view for easier Grafana queries
CREATE OR REPLACE VIEW telemetry.trace_summary AS
SELECT 
    t.trace_id,
    t.root_operation,
    t.service_name,
    t.start_time,
    t.end_time,
    EXTRACT(EPOCH FROM (t.end_time - t.start_time)) * 1000 AS total_duration_ms,
    COUNT(s.span_id) AS span_count,
    COUNT(CASE WHEN s.status = 'ERROR' THEN 1 END) AS error_count,
    AVG(s.duration_ms) AS avg_span_duration,
    MAX(s.duration_ms) AS max_span_duration
FROM telemetry.traces t
LEFT JOIN telemetry.spans s ON t.trace_id = s.trace_id
GROUP BY t.trace_id, t.root_operation, t.service_name, t.start_time, t.end_time;

-- Grant permissions on the view
GRANT SELECT ON telemetry.trace_summary TO pltel_reader;

-- Create indexes on commonly queried timestamp columns for better performance
CREATE INDEX IF NOT EXISTS idx_telemetry_traces_end_time ON telemetry.traces(end_time) WHERE end_time IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_telemetry_spans_end_time ON telemetry.spans(end_time) WHERE end_time IS NOT NULL;

-- ========================================================================
-- VALIDATION QUERIES
-- ========================================================================

-- Quick validation of sample data
SELECT 'Traces created' AS object_type, COUNT(*) AS count FROM telemetry.traces
UNION ALL
SELECT 'Spans created', COUNT(*) FROM telemetry.spans
UNION ALL  
SELECT 'Events created', COUNT(*) FROM telemetry.events
UNION ALL
SELECT 'Metrics created', COUNT(*) FROM telemetry.metrics
UNION ALL
SELECT 'Errors logged', COUNT(*) FROM telemetry.telemetry_errors
UNION ALL
SELECT 'Failed exports', COUNT(*) FROM telemetry.failed_exports
UNION ALL
SELECT 'Queue entries', COUNT(*) FROM telemetry.queue;

-- Show some sample trace hierarchies
SELECT 
    t.root_operation,
    s.operation_name,
    s.parent_span_id,
    s.duration_ms,
    s.status
FROM telemetry.traces t
JOIN telemetry.spans s ON t.trace_id = s.trace_id
WHERE t.trace_id = 'a1b2c3d4e5f6789012345678901234ab'
ORDER BY s.start_time;

COMMIT;
[END OF FILE: bridges/postgresql/oracle/examples/pg_sample_data.sql]


========================================================================
FILE: bridges/postgresql/oracle/examples/sync_mode.sql
SIZE: 5525 bytes
MODIFIED: ./bridges/postgresql/oracle/examples/sync_mode.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550580 1550580 18446744073709551615 -1
2025-06-23 14:10:57.848672100
========================================================================

-- ============================================
-- FILE: sync_mode.sql
-- PostgreSQL Bridge - Synchronous Mode Example
-- ============================================

/*
This example demonstrates using the PostgreSQL bridge in synchronous mode.
In sync mode, telemetry data is sent immediately to PostgreSQL without queuing.

IMPORTANT: Order matters in sync mode due to foreign key constraints!
*/

SET SERVEROUTPUT ON SIZE UNLIMITED

-- Configure for synchronous mode
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== CONFIGURING SYNCHRONOUS MODE ===');
    
    -- Basic configuration
    PLTelemetry.set_backend_url('POSTGRES_BRIDGE');
    PLTelemetry.set_autocommit(TRUE);
    
    -- IMPORTANT: Set synchronous mode
    PLTelemetry.set_async_mode(FALSE);
    
    -- Configure bridge
    PLT_POSTGRES_BRIDGE.set_postgrest_url('http://localhost:3000');
    
    DBMS_OUTPUT.PUT_LINE('Mode: ' || CASE 
        WHEN PLTelemetry.g_async_mode THEN 'ASYNC' 
        ELSE 'SYNC' 
    END);
    DBMS_OUTPUT.PUT_LINE('✓ Synchronous mode configured');
END;
/

-- Example 1: Correct order for sync mode
DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('=== EXAMPLE 1: CORRECT ORDER ===');
    
    -- 1. Start trace (sent immediately to PostgreSQL)
    l_trace_id := PLT_POSTGRES_BRIDGE.start_trace_with_postgres('sync_order_demo');
    DBMS_OUTPUT.PUT_LINE('1. Trace created: ' || l_trace_id);
    
    -- 2. Start span (only stored locally)
    l_span_id := PLTelemetry.start_span('process_order');
    DBMS_OUTPUT.PUT_LINE('2. Span started: ' || l_span_id);
    
    -- 3. Add attributes
    l_attrs(1) := PLTelemetry.add_attribute('order.id', '12345');
    l_attrs(2) := PLTelemetry.add_attribute('order.total', '299.99');
    
    -- 4. Simulate processing
    DBMS_LOCK.sleep(0.3);
    
    -- 5. CRITICAL: End span BEFORE creating metrics
    -- This sends the span to PostgreSQL
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    DBMS_OUTPUT.PUT_LINE('3. Span ended and sent to PostgreSQL');
    
    -- 6. NOW we can safely create metrics
    -- The span exists in PostgreSQL, so FK constraint is satisfied
    PLTelemetry.log_metric('order_processing_time', 300, 'ms', l_attrs);
    DBMS_OUTPUT.PUT_LINE('4. Metric sent to PostgreSQL');
    
    DBMS_OUTPUT.PUT_LINE('✓ Success - correct order maintained');
END;
/

-- Example 2: Multiple spans with proper ordering
DECLARE
    l_trace_id VARCHAR2(32);
    l_parent_span VARCHAR2(16);
    l_child_span1 VARCHAR2(16);
    l_child_span2 VARCHAR2(16);
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('=== EXAMPLE 2: NESTED SPANS ===');
    
    -- Create trace
    l_trace_id := PLT_POSTGRES_BRIDGE.start_trace_with_postgres('sync_nested_demo');
    
    -- Parent span
    l_parent_span := PLTelemetry.start_span('main_process');
    DBMS_OUTPUT.PUT_LINE('Parent span: ' || l_parent_span);
    
    -- Child span 1
    l_child_span1 := PLTelemetry.start_span('subprocess_1', l_parent_span);
    DBMS_LOCK.sleep(0.1);
    PLTelemetry.end_span(l_child_span1, 'OK');
    PLTelemetry.log_metric('subprocess_1_duration', 100, 'ms');
    DBMS_OUTPUT.PUT_LINE('  Child 1 completed');
    
    -- Child span 2
    l_child_span2 := PLTelemetry.start_span('subprocess_2', l_parent_span);
    DBMS_LOCK.sleep(0.2);
    PLTelemetry.end_span(l_child_span2, 'OK');
    PLTelemetry.log_metric('subprocess_2_duration', 200, 'ms');
    DBMS_OUTPUT.PUT_LINE('  Child 2 completed');
    
    -- End parent
    PLTelemetry.end_span(l_parent_span, 'OK');
    PLTelemetry.log_metric('total_duration', 300, 'ms');
    DBMS_OUTPUT.PUT_LINE('Parent completed');
    
    DBMS_OUTPUT.PUT_LINE('✓ Nested spans processed correctly');
END;
/

-- Example 3: Error handling in sync mode
DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_error_count NUMBER;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('=== EXAMPLE 3: ERROR HANDLING ===');
    
    -- Create trace
    l_trace_id := PLT_POSTGRES_BRIDGE.start_trace_with_postgres('sync_error_demo');
    l_span_id := PLTelemetry.start_span('may_fail_process');
    
    BEGIN
        -- Simulate some process that might fail
        IF DBMS_RANDOM.value < 0.5 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Simulated process error');
        END IF;
        
        -- Success path
        PLTelemetry.end_span(l_span_id, 'OK');
        PLTelemetry.log_metric('success_count', 1, 'count');
        
    EXCEPTION
        WHEN OTHERS THEN
            -- Error path - still record telemetry
            PLTelemetry.end_span(l_span_id, 'ERROR');
            PLTelemetry.log_metric('error_count', 1, 'count');
            DBMS_OUTPUT.PUT_LINE('Process failed but telemetry recorded');
    END;
    
    -- Check if telemetry errors occurred
    SELECT COUNT(*) INTO l_error_count
    FROM plt_telemetry_errors
    WHERE error_time > SYSTIMESTAMP - INTERVAL '1' MINUTE
    AND module_name LIKE '%sync_error_demo%';
    
    DBMS_OUTPUT.PUT_LINE('Telemetry errors: ' || l_error_count);
    DBMS_OUTPUT.PUT_LINE('✓ Error handling complete');
END;
/

-- Cleanup: Switch back to async mode
BEGIN
    PLTelemetry.set_async_mode(TRUE);
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Switched back to async mode');
END;
/
[END OF FILE: bridges/postgresql/oracle/examples/sync_mode.sql]


========================================================================
FILE: bridges/postgresql/oracle/src/install.sql
SIZE: 8363 bytes
MODIFIED: ./bridges/postgresql/oracle/src/install.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550578 1550578 18446744073709551615 -1
2025-06-23 14:16:07.561211600
========================================================================

-- ============================================
-- PLT_POSTGRES_BRIDGE Installation Script
-- Version: 1.0
-- ============================================

-- This script installs the PostgreSQL bridge for PLTelemetry
-- Prerequisites:
--   1. PLTelemetry core package must be installed first
--   2. User must have CREATE PROCEDURE privilege
--   3. EXECUTE privilege on UTL_HTTP package

SET SERVEROUTPUT ON
SET VERIFY OFF
SET FEEDBACK ON

PROMPT
PROMPT ============================================
PROMPT PLT_POSTGRES_BRIDGE Installation
PROMPT ============================================
PROMPT

-- Check prerequisites
DECLARE
    l_count NUMBER;
    l_errors NUMBER := 0;
BEGIN
    -- Check if PLTelemetry exists
    SELECT COUNT(*)
    INTO l_count
    FROM user_objects
    WHERE object_name = 'PLTELEMETRY'
    AND object_type = 'PACKAGE';
    
    IF l_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: PLTelemetry package not found!');
        DBMS_OUTPUT.PUT_LINE('Please install PLTelemetry core first.');
        l_errors := l_errors + 1;
    ELSE
        DBMS_OUTPUT.PUT_LINE('✓ PLTelemetry package found');
    END IF;
    
    -- Check UTL_HTTP privilege
    BEGIN
        IF UTL_HTTP.REQUEST('http://127.0.0.1:1') IS NULL THEN
            NULL; -- Won't reach here, but syntax is valid
        END IF;
        DBMS_OUTPUT.PUT_LINE('✓ UTL_HTTP access confirmed');
    EXCEPTION
        WHEN OTHERS THEN
            IF SQLCODE = -29273 THEN
                DBMS_OUTPUT.PUT_LINE('ERROR: No privilege to execute UTL_HTTP!');
                DBMS_OUTPUT.PUT_LINE('Ask your DBA to run:');
                DBMS_OUTPUT.PUT_LINE('  GRANT EXECUTE ON UTL_HTTP TO ' || USER || ';');
                l_errors := l_errors + 1;
            ELSE
                -- Other errors are OK (connection refused, etc)
                DBMS_OUTPUT.PUT_LINE('✓ UTL_HTTP access confirmed');
            END IF;
    END;
    
    -- Check if bridge already exists
    SELECT COUNT(*)
    INTO l_count
    FROM user_objects
    WHERE object_name = 'PLT_POSTGRES_BRIDGE'
    AND object_type IN ('PACKAGE', 'PACKAGE BODY');
    
    IF l_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('WARNING: PLT_POSTGRES_BRIDGE already exists');
        DBMS_OUTPUT.PUT_LINE('It will be replaced with the new version');
    END IF;
    
    IF l_errors > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Prerequisites check failed. Installation aborted.');
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Prerequisites check passed. Proceeding with installation...');
    DBMS_OUTPUT.PUT_LINE('');
END;
/

-- Create helper function for JSON escaping
PROMPT Creating helper function escape_json_string...

CREATE OR REPLACE FUNCTION escape_json_string(p_input VARCHAR2)
RETURN VARCHAR2
IS
    l_output VARCHAR2(4000);
BEGIN
    IF p_input IS NULL THEN
        RETURN NULL;
    END IF;
    
    l_output := p_input;
    
    -- Escape in correct order (backslash first!)
    l_output := REPLACE(l_output, '\', '\\');    -- Backslash
    l_output := REPLACE(l_output, '"', '\"');    -- Quotes
    l_output := REPLACE(l_output, CHR(10), '\n'); -- Newline
    l_output := REPLACE(l_output, CHR(13), '\r'); -- Carriage return
    l_output := REPLACE(l_output, CHR(9), '\t');  -- Tab
    l_output := REPLACE(l_output, CHR(8), '\b');  -- Backspace
    l_output := REPLACE(l_output, CHR(12), '\f'); -- Form feed
    
    RETURN l_output;
END escape_json_string;
/

SHOW ERRORS

-- Install package specification
PROMPT Creating PLT_POSTGRES_BRIDGE package specification...

@@PLT_POSTGRES_BRIDGE.pks

SHOW ERRORS

-- Install package body
PROMPT Creating PLT_POSTGRES_BRIDGE package body...

@@PLT_POSTGRES_BRIDGE.pkb

SHOW ERRORS

-- Verify installation
PROMPT
PROMPT Verifying installation...

DECLARE
    l_count NUMBER;
    l_status VARCHAR2(20);
BEGIN
    -- Check package
    SELECT COUNT(*), MAX(status)
    INTO l_count, l_status
    FROM user_objects
    WHERE object_name = 'PLT_POSTGRES_BRIDGE'
    AND object_type IN ('PACKAGE', 'PACKAGE BODY');
    
    IF l_count = 2 AND l_status = 'VALID' THEN
        DBMS_OUTPUT.PUT_LINE('✓ PLT_POSTGRES_BRIDGE package installed successfully');
    ELSE
        DBMS_OUTPUT.PUT_LINE('✗ PLT_POSTGRES_BRIDGE package installation failed');
        DBMS_OUTPUT.PUT_LINE('  Objects found: ' || l_count);
        DBMS_OUTPUT.PUT_LINE('  Status: ' || l_status);
    END IF;
    
    -- Check helper function
    SELECT COUNT(*), MAX(status)
    INTO l_count, l_status
    FROM user_objects
    WHERE object_name = 'ESCAPE_JSON_STRING'
    AND object_type = 'FUNCTION';
    
    IF l_count = 1 AND l_status = 'VALID' THEN
        DBMS_OUTPUT.PUT_LINE('✓ Helper function escape_json_string installed successfully');
    ELSE
        DBMS_OUTPUT.PUT_LINE('✗ Helper function installation failed');
    END IF;
END;
/

-- Create synonyms (optional)
PROMPT
PROMPT Creating public synonyms (optional - requires DBA privilege)...

BEGIN
    EXECUTE IMMEDIATE 'CREATE PUBLIC SYNONYM PLT_POSTGRES_BRIDGE FOR PLT_POSTGRES_BRIDGE';
    DBMS_OUTPUT.PUT_LINE('✓ Public synonym created');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -1031 THEN
            DBMS_OUTPUT.PUT_LINE('ℹ Skipping public synonym (requires DBA privilege)');
        ELSE
            DBMS_OUTPUT.PUT_LINE('ℹ Skipping public synonym: ' || SQLERRM);
        END IF;
END;
/

-- Configuration test
PROMPT
PROMPT ============================================
PROMPT Testing basic configuration...
PROMPT ============================================

DECLARE
    l_test_json VARCHAR2(200);
    l_escaped VARCHAR2(200);
BEGIN
    -- Test JSON escaping
    l_test_json := 'Test\with"special';
    l_escaped := escape_json_string(l_test_json);
    
    IF l_escaped = 'Test\\with\"special' THEN
        DBMS_OUTPUT.PUT_LINE('✓ JSON escaping works correctly');
    ELSE
        DBMS_OUTPUT.PUT_LINE('✗ JSON escaping failed');
        DBMS_OUTPUT.PUT_LINE('  Input: ' || l_test_json);
        DBMS_OUTPUT.PUT_LINE('  Output: ' || l_escaped);
    END IF;
    
    -- Test basic configuration
    PLT_POSTGRES_BRIDGE.set_postgrest_url('http://localhost:3000');
    PLT_POSTGRES_BRIDGE.set_timeout(30);
    
    DBMS_OUTPUT.PUT_LINE('✓ Configuration methods work correctly');
    
    -- Test JSON parsing
    DECLARE
        l_json VARCHAR2(200) := '{"name":"test","value":123.45,"unit":"ms"}';
        l_name VARCHAR2(100);
        l_value VARCHAR2(100);
    BEGIN
        l_name := PLT_POSTGRES_BRIDGE.get_json_value(l_json, 'name');
        l_value := PLT_POSTGRES_BRIDGE.get_json_value(l_json, 'value');
        
        IF l_name = 'test' AND l_value = '123.45' THEN
            DBMS_OUTPUT.PUT_LINE('✓ JSON parsing works correctly');
        ELSE
            DBMS_OUTPUT.PUT_LINE('✗ JSON parsing failed');
        END IF;
    END;
END;
/

-- Usage instructions
PROMPT
PROMPT ============================================
PROMPT Installation Complete!
PROMPT ============================================
PROMPT
PROMPT Next steps:
PROMPT
PROMPT 1. Configure PLTelemetry to use the bridge:
PROMPT    BEGIN
PROMPT        PLTelemetry.set_backend_url('POSTGRES_BRIDGE');
PROMPT        PLT_POSTGRES_BRIDGE.set_postgrest_url('http://your-server:3000');
PROMPT    END;
PROMPT
PROMPT 2. Test the connection:
PROMPT    See examples/basic_integration.sql
PROMPT
PROMPT 3. For async mode, set up the processing job:
PROMPT    See examples/job_setup.sql
PROMPT
PROMPT Documentation: https://github.com/yourusername/pltelemetry
PROMPT
PROMPT ============================================

-- Grant execute permissions (optional)
PROMPT
PROMPT To grant access to other users:
PROMPT   GRANT EXECUTE ON PLT_POSTGRES_BRIDGE TO username;
PROMPT   GRANT EXECUTE ON escape_json_string TO username;
PROMPT

-- Summary
SELECT 
    object_name,
    object_type,
    status,
    created,
    last_ddl_time
FROM user_objects
WHERE object_name IN ('PLT_POSTGRES_BRIDGE', 'ESCAPE_JSON_STRING')
ORDER BY object_name, object_type;

-- End of installation
PROMPT
PROMPT Installation script completed.
PROMPT
[END OF FILE: bridges/postgresql/oracle/src/install.sql]


========================================================================
FILE: bridges/postgresql/schema/01-database-setup.sql
SIZE: 13297 bytes
MODIFIED: ./bridges/postgresql/schema/01-database-setup.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550576 1550576 18446744073709551615 -1
2025-06-23 14:10:13.905655500
========================================================================

-- PLTelemetry PostgreSQL Database Schema
-- Professional setup with dedicated database, schema and users
-- 
-- Database: pltelemetry_db
-- Schema: telemetry
-- Users: 
--   - pltel_admin: Full access for setup/maintenance
--   - pltel_writer: Write access for Oracle PL/SQL
--   - pltel_reader: Read access for Grafana
--
-- Tables created:
-- - telemetry.traces: Main trace records
-- - telemetry.spans: Span records within traces  
-- - telemetry.events: Events within spans
-- - telemetry.metrics: Metric records
-- - telemetry.queue: Async processing queue
-- - telemetry.failed_exports: Failed export attempts
-- - telemetry.telemetry_errors: Error logging

-- ========================================================================
-- STEP 1: Database and Users Setup (run as postgres superuser)
-- ========================================================================

-- Create dedicated database
CREATE DATABASE pltelemetry_db
    WITH ENCODING 'UTF8'
    LC_COLLATE = 'en_US.UTF-8'
    LC_CTYPE = 'en_US.UTF-8'
    TEMPLATE = template0;

-- Connect to the new database
\c pltelemetry_db;

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";
CREATE EXTENSION IF NOT EXISTS "btree_gin";

-- Create users with specific roles
CREATE USER pltel_admin WITH PASSWORD 'PltAdmin2025!';
CREATE USER pltel_writer WITH PASSWORD 'PltWriter2025!';
CREATE USER pltel_reader WITH PASSWORD 'PltReader2025!';

-- Grant database access
GRANT CONNECT ON DATABASE pltelemetry_db TO pltel_admin, pltel_writer, pltel_reader;


-- ========================================================================
-- STEP 2: Schema and Tables Setup
-- ========================================================================

-- Create dedicated schema
CREATE SCHEMA IF NOT EXISTS telemetry;

-- Set search path for this session
SET search_path TO telemetry, public;

-- Drop existing tables if they exist (for reinstall)
DROP TABLE IF EXISTS telemetry.telemetry_errors CASCADE;
DROP TABLE IF EXISTS telemetry.failed_exports CASCADE;
DROP TABLE IF EXISTS telemetry.queue CASCADE;
DROP TABLE IF EXISTS telemetry.metrics CASCADE;
DROP TABLE IF EXISTS telemetry.events CASCADE;
DROP TABLE IF EXISTS telemetry.spans CASCADE;
DROP TABLE IF EXISTS telemetry.traces CASCADE;

-- ========================================================================
-- STEP 3: Core Tables
-- ========================================================================

-- Main traces table
CREATE TABLE telemetry.traces (
    trace_id VARCHAR(32) PRIMARY KEY,
    root_operation VARCHAR(255) NOT NULL,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    service_name VARCHAR(100) NOT NULL DEFAULT 'oracle-plsql',
    service_instance VARCHAR(255),
    created_by VARCHAR(100) DEFAULT SESSION_USER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE telemetry.traces IS 'OpenTelemetry traces - root operations';
COMMENT ON COLUMN telemetry.traces.trace_id IS '128-bit trace ID (32 hex chars)';
COMMENT ON COLUMN telemetry.traces.root_operation IS 'Name of the root operation';
COMMENT ON COLUMN telemetry.traces.service_name IS 'Service identifier';
COMMENT ON COLUMN telemetry.traces.service_instance IS 'Service instance identifier';

-- Spans table
CREATE TABLE telemetry.spans (
    span_id VARCHAR(16) PRIMARY KEY,
    trace_id VARCHAR(32) NOT NULL,
    parent_span_id VARCHAR(16),
    operation_name VARCHAR(255) NOT NULL,
    start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    duration_ms DECIMAL(15,3),
    status VARCHAR(50) NOT NULL DEFAULT 'RUNNING',
    created_by VARCHAR(100) DEFAULT SESSION_USER,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT fk_spans_trace FOREIGN KEY (trace_id) REFERENCES telemetry.traces(trace_id) ON DELETE CASCADE,
    CONSTRAINT fk_spans_parent FOREIGN KEY (parent_span_id) REFERENCES telemetry.spans(span_id) ON DELETE SET NULL,
    CONSTRAINT chk_spans_status CHECK (status IN ('RUNNING', 'OK', 'ERROR', 'CANCELLED'))
);

COMMENT ON TABLE telemetry.spans IS 'OpenTelemetry spans - individual operations within traces';
COMMENT ON COLUMN telemetry.spans.span_id IS '64-bit span ID (16 hex chars)';
COMMENT ON COLUMN telemetry.spans.parent_span_id IS 'Parent span for nested operations';
COMMENT ON COLUMN telemetry.spans.duration_ms IS 'Span duration in milliseconds';

-- Events table
CREATE TABLE telemetry.events (
    event_id BIGSERIAL PRIMARY KEY,
    span_id VARCHAR(16) NOT NULL,
    event_name VARCHAR(255) NOT NULL,
    event_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    attributes JSONB,
    created_by VARCHAR(100) DEFAULT SESSION_USER,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT fk_events_span FOREIGN KEY (span_id) REFERENCES telemetry.spans(span_id) ON DELETE CASCADE
);

COMMENT ON TABLE telemetry.events IS 'Events within spans - point-in-time occurrences';
COMMENT ON COLUMN telemetry.events.attributes IS 'JSON attributes for the event';

-- Metrics table
CREATE TABLE telemetry.metrics (
    metric_id BIGSERIAL PRIMARY KEY,
    metric_name VARCHAR(255) NOT NULL,
    metric_value DECIMAL(20,6) NOT NULL,
    metric_unit VARCHAR(50),
    trace_id VARCHAR(32),
    span_id VARCHAR(16),
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    attributes JSONB,
    created_by VARCHAR(100) DEFAULT SESSION_USER,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT fk_metrics_trace FOREIGN KEY (trace_id) REFERENCES telemetry.traces(trace_id) ON DELETE SET NULL,
    CONSTRAINT fk_metrics_span FOREIGN KEY (span_id) REFERENCES telemetry.spans(span_id) ON DELETE SET NULL
);

COMMENT ON TABLE telemetry.metrics IS 'Application metrics with telemetry context';
COMMENT ON COLUMN telemetry.metrics.metric_unit IS 'Unit of measurement (ms, bytes, requests, etc.)';
COMMENT ON COLUMN telemetry.metrics.attributes IS 'JSON attributes for the metric';

-- Failed exports table
CREATE TABLE telemetry.failed_exports (
    export_id BIGSERIAL PRIMARY KEY,
    export_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    http_status INTEGER,
    payload TEXT,
    error_message TEXT,
    retry_count INTEGER NOT NULL DEFAULT 0,
    last_retry TIMESTAMPTZ,
    created_by VARCHAR(100) DEFAULT SESSION_USER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE telemetry.failed_exports IS 'Failed telemetry export attempts for debugging';
COMMENT ON COLUMN telemetry.failed_exports.payload IS 'Payload that failed to export';

-- Async processing queue
CREATE TABLE telemetry.queue (
    queue_id BIGSERIAL PRIMARY KEY,
    payload TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed BOOLEAN NOT NULL DEFAULT FALSE,
    process_attempts INTEGER NOT NULL DEFAULT 0,
    processed_time TIMESTAMPTZ,
    last_error TEXT,
    last_attempt_time TIMESTAMPTZ,
    created_by VARCHAR(100) DEFAULT SESSION_USER
);

COMMENT ON TABLE telemetry.queue IS 'Async processing queue for telemetry export';
COMMENT ON COLUMN telemetry.queue.payload IS 'JSON payload to be exported';
COMMENT ON COLUMN telemetry.queue.process_attempts IS 'Number of processing attempts (max 3)';

-- Error logging table
CREATE TABLE telemetry.telemetry_errors (
    error_id BIGSERIAL PRIMARY KEY,
    error_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    error_message TEXT,
    error_stack TEXT,
    error_code INTEGER,
    module_name VARCHAR(100),
    trace_id VARCHAR(32),
    span_id VARCHAR(16),
    session_user_id VARCHAR(128) DEFAULT SESSION_USER,
    os_user VARCHAR(128),
    host VARCHAR(256),
    ip_address INET,
    created_by VARCHAR(100) DEFAULT SESSION_USER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE telemetry.telemetry_errors IS 'Internal error logging for PLTelemetry operations';
COMMENT ON COLUMN telemetry.telemetry_errors.module_name IS 'PLTelemetry module where error occurred';

-- ========================================================================
-- STEP 4: Performance Indexes
-- ========================================================================

-- Traces indexes
CREATE INDEX idx_telemetry_traces_start_time ON telemetry.traces(start_time);
CREATE INDEX idx_telemetry_traces_service ON telemetry.traces(service_name, start_time);
CREATE INDEX idx_telemetry_traces_operation ON telemetry.traces(root_operation, start_time);
CREATE INDEX idx_telemetry_traces_created_at ON telemetry.traces(created_at);

-- Spans indexes
CREATE INDEX idx_telemetry_spans_trace_id ON telemetry.spans(trace_id, start_time);
CREATE INDEX idx_telemetry_spans_parent ON telemetry.spans(parent_span_id, start_time);
CREATE INDEX idx_telemetry_spans_operation ON telemetry.spans(operation_name, start_time);
CREATE INDEX idx_telemetry_spans_status ON telemetry.spans(status, start_time);
CREATE INDEX idx_telemetry_spans_duration ON telemetry.spans(duration_ms) WHERE duration_ms IS NOT NULL;

-- Events indexes
CREATE INDEX idx_telemetry_events_span_id ON telemetry.events(span_id, event_time);
CREATE INDEX idx_telemetry_events_name ON telemetry.events(event_name, event_time);
CREATE INDEX idx_telemetry_events_time ON telemetry.events(event_time);

-- Metrics indexes
CREATE INDEX idx_telemetry_metrics_name ON telemetry.metrics(metric_name, timestamp);
CREATE INDEX idx_telemetry_metrics_trace ON telemetry.metrics(trace_id, timestamp);
CREATE INDEX idx_telemetry_metrics_span ON telemetry.metrics(span_id, timestamp);
CREATE INDEX idx_telemetry_metrics_time ON telemetry.metrics(timestamp);
CREATE INDEX idx_telemetry_metrics_value ON telemetry.metrics(metric_name, metric_value, timestamp);

-- Queue indexes (for async processing performance)
CREATE INDEX idx_telemetry_queue_processed ON telemetry.queue(processed, process_attempts, created_at);
CREATE INDEX idx_telemetry_queue_created ON telemetry.queue(created_at);
CREATE INDEX idx_telemetry_queue_processed_time ON telemetry.queue(processed_time);
CREATE INDEX idx_telemetry_queue_attempts ON telemetry.queue(process_attempts, last_attempt_time);

-- Failed exports indexes
CREATE INDEX idx_telemetry_failed_exports_time ON telemetry.failed_exports(export_time);
CREATE INDEX idx_telemetry_failed_exports_status ON telemetry.failed_exports(http_status, export_time);
CREATE INDEX idx_telemetry_failed_exports_retry ON telemetry.failed_exports(retry_count, last_retry);

-- Error logging indexes
CREATE INDEX idx_telemetry_errors_time ON telemetry.telemetry_errors(error_time);
CREATE INDEX idx_telemetry_errors_trace ON telemetry.telemetry_errors(trace_id);
CREATE INDEX idx_telemetry_errors_span ON telemetry.telemetry_errors(span_id);
CREATE INDEX idx_telemetry_errors_module ON telemetry.telemetry_errors(module_name, error_time);
CREATE INDEX idx_telemetry_errors_code ON telemetry.telemetry_errors(error_code, error_time);

-- Composite indexes for common query patterns
CREATE INDEX idx_telemetry_trace_span_lookup ON telemetry.spans(trace_id, span_id);
CREATE INDEX idx_telemetry_active_spans ON telemetry.spans(trace_id, end_time) WHERE end_time IS NULL;
CREATE INDEX idx_telemetry_error_spans ON telemetry.spans(trace_id, status) WHERE status = 'ERROR';

-- Function-based indexes for common operations
CREATE INDEX idx_telemetry_queue_failed ON telemetry.queue(process_attempts) WHERE process_attempts >= 3;
CREATE INDEX idx_telemetry_queue_pending ON telemetry.queue(created_at) WHERE processed = FALSE;

-- JSONB indexes for attributes
CREATE INDEX idx_telemetry_events_attributes ON telemetry.events USING GIN (attributes);
CREATE INDEX idx_telemetry_metrics_attributes ON telemetry.metrics USING GIN (attributes);

-- Full text search indexes
CREATE INDEX idx_telemetry_traces_operation_fts ON telemetry.traces USING GIN (to_tsvector('english', root_operation));
CREATE INDEX idx_telemetry_spans_operation_fts ON telemetry.spans USING GIN (to_tsvector('english', operation_name));

-- ========================================================================
-- STEP 5: User Permissions and Security
-- ========================================================================

-- Admin user: Full access to telemetry schema
GRANT ALL PRIVILEGES ON SCHEMA telemetry TO pltel_admin;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA telemetry TO pltel_admin;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA telemetry TO pltel_admin;

-- Writer user: Insert/Update access for Oracle PL/SQL
GRANT USAGE ON SCHEMA telemetry TO pltel_writer;
GRANT INSERT, UPDATE ON telemetry.traces TO pltel_writer;
GRANT INSERT, UPDATE ON telemetry.spans TO pltel_writer;
GRANT INSERT ON telemetry.events TO pltel_writer;
GRANT INSERT ON telemetry.metrics TO pltel_writer;
GRANT INSERT ON telemetry.queue TO pltel_writer;
GRANT INSERT ON telemetry.failed_exports TO pltel_writer;
GRANT INSERT ON telemetry.telemetry_errors TO pltel_writer;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA telemetry TO pltel_writer;

-- Reader user: Read-only access for Grafana
GRANT USAGE ON SCHEMA telemetry TO pltel_reader;
GRANT SELECT ON ALL TABLES IN SCHEMA telemetry TO pltel_reader;
[END OF FILE: bridges/postgresql/schema/01-database-setup.sql]


========================================================================
FILE: examples/basic_usage.sql
SIZE: 12118 bytes
MODIFIED: ./examples/basic_usage.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550573 1550573 18446744073709551615 -1
2025-06-23 06:16:29.771966300
========================================================================

-- PLTelemetry Basic Usage Examples
-- This file contains simple examples to get started with PLTelemetry
-- Run these examples after installing PLTelemetry to verify functionality

PROMPT ================================================================================
PROMPT PLTelemetry Basic Usage Examples
PROMPT ================================================================================

-- First, configure PLTelemetry (adjust URLs and keys for your environment)
BEGIN
    -- Set your backend endpoint
    PLTelemetry.set_backend_url('http://localhost:3000/api/telemetry');
    
    -- Set API key for authentication
    PLTelemetry.set_api_key('your-secret-api-key');
    
    -- Enable async mode for better performance
    PLTelemetry.set_async_mode(TRUE);
    
    DBMS_OUTPUT.PUT_LINE('PLTelemetry configured successfully');
END;
/

-- Example 1: Simple trace with single span
-- ============================================================================
PROMPT
PROMPT Example 1: Simple trace with single span
PROMPT ============================================================================

DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
BEGIN
    -- Start a new trace
    l_trace_id := PLTelemetry.start_trace('simple_example');
    DBMS_OUTPUT.PUT_LINE('Started trace: ' || l_trace_id);
    
    -- Start a span
    l_span_id := PLTelemetry.start_span('do_work');
    DBMS_OUTPUT.PUT_LINE('Started span: ' || l_span_id);
    
    -- Simulate some work
    DBMS_LOCK.SLEEP(1);  -- Sleep for 1 second
    
    -- End the span
    PLTelemetry.end_span(l_span_id, 'OK');
    DBMS_OUTPUT.PUT_LINE('Ended span: ' || l_span_id);
    
    -- End the trace
    PLTelemetry.end_trace(l_trace_id);
    DBMS_OUTPUT.PUT_LINE('Ended trace: ' || l_trace_id);
END;
/

-- Example 2: Adding attributes to spans
-- ============================================================================
PROMPT
PROMPT Example 2: Adding attributes to spans
PROMPT ============================================================================

DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
BEGIN
    l_trace_id := PLTelemetry.start_trace('example_with_attributes');
    l_span_id := PLTelemetry.start_span('process_customer');
    
    -- Create attributes
    l_attrs(1) := PLTelemetry.add_attribute('customer.id', '12345');
    l_attrs(2) := PLTelemetry.add_attribute('customer.tier', 'PREMIUM');
    l_attrs(3) := PLTelemetry.add_attribute('process.type', 'verification');
    
    -- Do some work
    DBMS_LOCK.SLEEP(0.5);
    
    -- End span with attributes
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    PLTelemetry.end_trace(l_trace_id);
    
    DBMS_OUTPUT.PUT_LINE('Completed trace with attributes');
END;
/

-- Example 3: Adding events to spans
-- ============================================================================
PROMPT
PROMPT Example 3: Adding events to spans  
PROMPT ============================================================================

DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
BEGIN
    l_trace_id := PLTelemetry.start_trace('example_with_events');
    l_span_id := PLTelemetry.start_span('order_processing');
    
    -- Add start event
    PLTelemetry.add_event(l_span_id, 'order_received');
    
    -- Simulate validation step
    DBMS_LOCK.SLEEP(0.3);
    l_attrs(1) := PLTelemetry.add_attribute('validation.status', 'passed');
    PLTelemetry.add_event(l_span_id, 'order_validated', l_attrs);
    
    -- Simulate processing step
    DBMS_LOCK.SLEEP(0.5);
    l_attrs.DELETE;
    l_attrs(1) := PLTelemetry.add_attribute('items.count', '3');
    PLTelemetry.add_event(l_span_id, 'items_processed', l_attrs);
    
    -- Add completion event
    PLTelemetry.add_event(l_span_id, 'order_completed');
    
    PLTelemetry.end_span(l_span_id, 'OK');
    PLTelemetry.end_trace(l_trace_id);
    
    DBMS_OUTPUT.PUT_LINE('Completed trace with events');
END;
/

-- Example 4: Recording metrics
-- ============================================================================
PROMPT
PROMPT Example 4: Recording metrics
PROMPT ============================================================================

DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
BEGIN
    l_trace_id := PLTelemetry.start_trace('example_with_metrics');
    l_span_id := PLTelemetry.start_span('calculate_totals');
    
    -- Set up attributes for metrics
    l_attrs(1) := PLTelemetry.add_attribute('currency', 'EUR');
    l_attrs(2) := PLTelemetry.add_attribute('region', 'EMEA');
    
    -- Record various metrics
    PLTelemetry.log_metric('order_total', 299.99, 'EUR', l_attrs);
    PLTelemetry.log_metric('processing_time', 1.25, 'seconds', l_attrs);
    PLTelemetry.log_metric('items_count', 5, 'items', l_attrs);
    
    PLTelemetry.end_span(l_span_id, 'OK');
    PLTelemetry.end_trace(l_trace_id);
    
    DBMS_OUTPUT.PUT_LINE('Completed trace with metrics');
END;
/

-- Example 5: Nested spans (parent-child relationship)
-- ============================================================================
PROMPT
PROMPT Example 5: Nested spans (parent-child relationship)
PROMPT ============================================================================

DECLARE
    l_trace_id     VARCHAR2(32);
    l_parent_span  VARCHAR2(16);
    l_child_span1  VARCHAR2(16);
    l_child_span2  VARCHAR2(16);
    l_attrs        PLTelemetry.t_attributes;
BEGIN
    l_trace_id := PLTelemetry.start_trace('nested_spans_example');
    
    -- Parent span
    l_parent_span := PLTelemetry.start_span('process_order');
    PLTelemetry.add_event(l_parent_span, 'order_processing_started');
    
    -- First child span
    l_child_span1 := PLTelemetry.start_span('validate_payment', l_parent_span);
    DBMS_LOCK.SLEEP(0.3);
    l_attrs(1) := PLTelemetry.add_attribute('payment.method', 'credit_card');
    PLTelemetry.end_span(l_child_span1, 'OK', l_attrs);
    
    -- Second child span
    l_child_span2 := PLTelemetry.start_span('update_inventory', l_parent_span);
    DBMS_LOCK.SLEEP(0.4);
    l_attrs.DELETE;
    l_attrs(1) := PLTelemetry.add_attribute('inventory.updated_items', '3');
    PLTelemetry.end_span(l_child_span2, 'OK', l_attrs);
    
    -- Complete parent span
    PLTelemetry.add_event(l_parent_span, 'order_processing_completed');
    PLTelemetry.end_span(l_parent_span, 'OK');
    PLTelemetry.end_trace(l_trace_id);
    
    DBMS_OUTPUT.PUT_LINE('Completed nested spans example');
END;
/

-- Example 6: Using semantic conventions
-- ============================================================================
PROMPT
PROMPT Example 6: Using OpenTelemetry semantic conventions
PROMPT ============================================================================

DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
BEGIN
    l_trace_id := PLTelemetry.start_trace('semantic_conventions_example');
    l_span_id := PLTelemetry.start_span('database_query');
    
    -- Use standard OpenTelemetry semantic conventions
    l_attrs(1) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_DB_OPERATION, 'SELECT');
    l_attrs(2) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_DB_STATEMENT, 'SELECT * FROM customers WHERE status = ?');
    l_attrs(3) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_USER_ID, 'user123');
    
    -- Simulate database query
    DBMS_LOCK.SLEEP(0.2);
    
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    PLTelemetry.end_trace(l_trace_id);
    
    DBMS_OUTPUT.PUT_LINE('Completed semantic conventions example');
END;
/

-- Example 7: Simple function instrumentation
-- ============================================================================
PROMPT
PROMPT Example 7: Simple function instrumentation
PROMPT ============================================================================

CREATE OR REPLACE FUNCTION calculate_discount_example(
    p_customer_tier VARCHAR2,
    p_order_total   NUMBER
) RETURN NUMBER
IS
    l_span_id   VARCHAR2(16);
    l_attrs     PLTelemetry.t_attributes;
    l_discount  NUMBER;
BEGIN
    -- Start span within existing trace context
    l_span_id := PLTelemetry.start_span('calculate_discount');
    
    -- Add input parameters as attributes
    l_attrs(1) := PLTelemetry.add_attribute('customer.tier', p_customer_tier);
    l_attrs(2) := PLTelemetry.add_attribute('order.total', TO_CHAR(p_order_total));
    
    -- Business logic
    CASE p_customer_tier
        WHEN 'PREMIUM' THEN l_discount := p_order_total * 0.15;
        WHEN 'GOLD' THEN l_discount := p_order_total * 0.10;
        WHEN 'SILVER' THEN l_discount := p_order_total * 0.05;
        ELSE l_discount := 0;
    END CASE;
    
    -- Add result as attribute
    l_attrs(3) := PLTelemetry.add_attribute('discount.amount', TO_CHAR(l_discount));
    
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    
    RETURN l_discount;
END;
/

-- Test the instrumented function
DECLARE
    l_trace_id VARCHAR2(32);
    l_discount NUMBER;
BEGIN
    l_trace_id := PLTelemetry.start_trace('test_function_instrumentation');
    
    l_discount := calculate_discount_example('PREMIUM', 200.00);
    
    DBMS_OUTPUT.PUT_LINE('Calculated discount: ' || l_discount);
    
    PLTelemetry.end_trace(l_trace_id);
END;
/

-- Example 8: Configuration and status check
-- ============================================================================
PROMPT
PROMPT Example 8: Configuration and status check
PROMPT ============================================================================

DECLARE
    l_backend_url VARCHAR2(500);
    l_autocommit  BOOLEAN;
    l_current_trace VARCHAR2(32);
    l_current_span VARCHAR2(16);
BEGIN
    -- Check current configuration
    l_backend_url := PLTelemetry.get_backend_url();
    l_autocommit := PLTelemetry.get_autocommit();
    l_current_trace := PLTelemetry.get_current_trace_id();
    l_current_span := PLTelemetry.get_current_span_id();
    
    DBMS_OUTPUT.PUT_LINE('Current Configuration:');
    DBMS_OUTPUT.PUT_LINE('  Backend URL: ' || NVL(l_backend_url, 'NOT SET'));
    DBMS_OUTPUT.PUT_LINE('  Autocommit: ' || CASE WHEN l_autocommit THEN 'TRUE' ELSE 'FALSE' END);
    DBMS_OUTPUT.PUT_LINE('  Current Trace: ' || NVL(l_current_trace, 'NONE'));
    DBMS_OUTPUT.PUT_LINE('  Current Span: ' || NVL(l_current_span, 'NONE'));
END;
/

-- Check queue status
PROMPT
PROMPT Queue Status:
SELECT 
    COUNT(*) as total_entries,
    SUM(CASE WHEN processed = 'N' THEN 1 ELSE 0 END) as pending,
    SUM(CASE WHEN processed = 'Y' THEN 1 ELSE 0 END) as processed,
    SUM(CASE WHEN process_attempts >= 3 THEN 1 ELSE 0 END) as failed
FROM plt_queue;

-- Check recent activity
PROMPT
PROMPT Recent Traces (last 10):
SELECT 
    trace_id,
    root_operation,
    start_time,
    end_time,
    CASE 
        WHEN end_time IS NOT NULL THEN 
            EXTRACT(SECOND FROM (end_time - start_time)) * 1000
        ELSE NULL 
    END as duration_ms
FROM plt_traces
ORDER BY start_time DESC
FETCH FIRST 10 ROWS ONLY;

PROMPT
PROMPT ================================================================================
PROMPT Basic Usage Examples Completed
PROMPT ================================================================================
PROMPT
PROMPT Next steps:
PROMPT 1. Check the queue processing: SELECT * FROM plt_queue WHERE processed = 'N';
PROMPT 2. Monitor for errors: SELECT * FROM plt_telemetry_errors ORDER BY error_time DESC;
PROMPT 3. Try the advanced examples in advanced_examples.sql
PROMPT 4. Integrate with your existing procedures and functions
PROMPT
PROMPT ================================================================================
[END OF FILE: examples/basic_usage.sql]


========================================================================
FILE: examples/error_handling.sql
SIZE: 26019 bytes
MODIFIED: ./examples/error_handling.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550570 1550570 18446744073709551615 -1
2025-06-23 06:16:29.774951900
========================================================================

-- PLTelemetry Error Handling Patterns
-- This file demonstrates robust error handling patterns with PLTelemetry
-- to ensure telemetry never breaks your business logic

PROMPT ================================================================================
PROMPT PLTelemetry Error Handling Patterns
PROMPT ================================================================================

-- Pattern 1: Basic error handling with span status
-- ============================================================================
PROMPT
PROMPT Pattern 1: Basic error handling with span status
PROMPT ============================================================================

CREATE OR REPLACE PROCEDURE error_handling_basic_example
IS
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
BEGIN
    l_trace_id := PLTelemetry.start_trace('error_handling_basic');
    l_span_id := PLTelemetry.start_span('risky_operation');
    
    BEGIN
        -- Simulate business logic that might fail
        IF DBMS_RANDOM.VALUE(0, 1) > 0.5 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Simulated business error');
        END IF;
        
        -- Success path
        PLTelemetry.add_event(l_span_id, 'operation_successful');
        PLTelemetry.end_span(l_span_id, 'OK');
        
        DBMS_OUTPUT.PUT_LINE('Operation completed successfully');
        
    EXCEPTION
        WHEN OTHERS THEN
            -- Error path - capture error details
            l_attrs(1) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SQLERRM);
            l_attrs(2) := PLTelemetry.add_attribute('error.code', TO_CHAR(SQLCODE));
            l_attrs(3) := PLTelemetry.add_attribute('error.type', 'business_error');
            
            PLTelemetry.add_event(l_span_id, 'operation_failed', l_attrs);
            PLTelemetry.end_span(l_span_id, 'ERROR', l_attrs);
            
            DBMS_OUTPUT.PUT_LINE('Operation failed: ' || SQLERRM);
            
            -- IMPORTANT: Re-raise the original exception
            -- Telemetry should never swallow business exceptions
            RAISE;
    END;
    
    PLTelemetry.end_trace(l_trace_id);
END;
/

-- Test the basic error handling
BEGIN
    FOR i IN 1..3 LOOP
        BEGIN
            error_handling_basic_example();
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Caught exception in test: ' || SQLERRM);
        END;
    END LOOP;
END;
/

-- Pattern 2: Nested operations with proper error propagation
-- ============================================================================
PROMPT
PROMPT Pattern 2: Nested operations with proper error propagation
PROMPT ============================================================================

CREATE OR REPLACE PROCEDURE error_handling_nested_example
IS
    l_trace_id VARCHAR2(32);
    l_main_span VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
BEGIN
    l_trace_id := PLTelemetry.start_trace('error_handling_nested');
    l_main_span := PLTelemetry.start_span('main_operation');
    
    BEGIN
        -- Step 1: Validation (might fail)
        DECLARE
            l_validation_span VARCHAR2(16);
        BEGIN
            l_validation_span := PLTelemetry.start_span('validate_input', l_main_span);
            
            -- Simulate validation logic
            IF DBMS_RANDOM.VALUE(0, 1) > 0.7 THEN
                RAISE_APPLICATION_ERROR(-20100, 'Validation failed: invalid input');
            END IF;
            
            PLTelemetry.end_span(l_validation_span, 'OK');
        EXCEPTION
            WHEN OTHERS THEN
                l_attrs(1) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SQLERRM);
                l_attrs(2) := PLTelemetry.add_attribute('validation.step', 'input_validation');
                PLTelemetry.end_span(l_validation_span, 'ERROR', l_attrs);
                RAISE; -- Propagate to parent
        END;
        
        -- Step 2: Database operation (might fail)
        DECLARE
            l_db_span VARCHAR2(16);
        BEGIN
            l_db_span := PLTelemetry.start_span('database_operation', l_main_span);
            
            l_attrs.DELETE;
            l_attrs(1) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_DB_OPERATION, 'INSERT');
            
            -- Simulate database operation
            IF DBMS_RANDOM.VALUE(0, 1) > 0.8 THEN
                RAISE_APPLICATION_ERROR(-20200, 'Database constraint violation');
            END IF;
            
            PLTelemetry.end_span(l_db_span, 'OK', l_attrs);
        EXCEPTION
            WHEN OTHERS THEN
                l_attrs(2) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SQLERRM);
                l_attrs(3) := PLTelemetry.add_attribute('db.error_type', 'constraint_violation');
                PLTelemetry.end_span(l_db_span, 'ERROR', l_attrs);
                RAISE; -- Propagate to parent
        END;
        
        -- Step 3: External API call (might fail)
        DECLARE
            l_api_span VARCHAR2(16);
        BEGIN
            l_api_span := PLTelemetry.start_span('external_api_call', l_main_span);
            
            l_attrs.DELETE;
            l_attrs(1) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_METHOD, 'POST');
            l_attrs(2) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_URL, 'https://api.example.com/notify');
            
            -- Simulate API call
            IF DBMS_RANDOM.VALUE(0, 1) > 0.9 THEN
                RAISE_APPLICATION_ERROR(-20300, 'External API timeout');
            END IF;
            
            l_attrs(3) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_STATUS, '200');
            PLTelemetry.end_span(l_api_span, 'OK', l_attrs);
        EXCEPTION
            WHEN OTHERS THEN
                l_attrs(3) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_STATUS, '500');
                l_attrs(4) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SQLERRM);
                PLTelemetry.end_span(l_api_span, 'ERROR', l_attrs);
                RAISE; -- Propagate to parent
        END;
        
        -- All steps successful
        PLTelemetry.add_event(l_main_span, 'all_operations_completed');
        PLTelemetry.end_span(l_main_span, 'OK');
        
        DBMS_OUTPUT.PUT_LINE('All nested operations completed successfully');
        
    EXCEPTION
        WHEN OTHERS THEN
            -- Handle any error from nested operations
            l_attrs.DELETE;
            l_attrs(1) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SQLERRM);
            l_attrs(2) := PLTelemetry.add_attribute('error.source', 'nested_operation');
            l_attrs(3) := PLTelemetry.add_attribute('error.code', TO_CHAR(SQLCODE));
            
            PLTelemetry.add_event(l_main_span, 'nested_operation_failed', l_attrs);
            PLTelemetry.end_span(l_main_span, 'ERROR', l_attrs);
            
            DBMS_OUTPUT.PUT_LINE('Nested operation failed: ' || SQLERRM);
            RAISE;
    END;
    
    PLTelemetry.end_trace(l_trace_id);
END;
/

-- Test nested error handling
BEGIN
    FOR i IN 1..5 LOOP
        BEGIN
            error_handling_nested_example();
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Test ' || i || ' - Caught: ' || SQLERRM);
        END;
    END LOOP;
END;
/

-- Pattern 3: Telemetry-safe operations (never fail business logic)
-- ============================================================================
PROMPT
PROMPT Pattern 3: Telemetry-safe operations (defensive programming)
PROMPT ============================================================================

CREATE OR REPLACE PROCEDURE telemetry_safe_operation_example
IS
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
    l_result   NUMBER;
BEGIN
    -- Business logic that must succeed regardless of telemetry issues
    l_result := calculate_important_value();
    
    -- Telemetry operations wrapped in defensive blocks
    BEGIN
        l_trace_id := PLTelemetry.start_trace('safe_operation');
    EXCEPTION
        WHEN OTHERS THEN
            -- Telemetry failed to start, but business continues
            DBMS_OUTPUT.PUT_LINE('Warning: Failed to start trace, continuing without telemetry');
            l_trace_id := NULL;
    END;
    
    BEGIN
        IF l_trace_id IS NOT NULL THEN
            l_span_id := PLTelemetry.start_span('calculate_value');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Warning: Failed to start span');
            l_span_id := NULL;
    END;
    
    -- Add telemetry events safely
    BEGIN
        IF l_span_id IS NOT NULL THEN
            l_attrs(1) := PLTelemetry.add_attribute('calculation.result', TO_CHAR(l_result));
            PLTelemetry.add_event(l_span_id, 'calculation_completed', l_attrs);
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Warning: Failed to add telemetry event');
    END;
    
    -- End telemetry safely
    BEGIN
        IF l_span_id IS NOT NULL THEN
            PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Warning: Failed to end span');
    END;
    
    BEGIN
        IF l_trace_id IS NOT NULL THEN
            PLTelemetry.end_trace(l_trace_id);
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Warning: Failed to end trace');
    END;
    
    -- Business logic completes successfully regardless of telemetry
    DBMS_OUTPUT.PUT_LINE('Business operation completed with result: ' || l_result);
END;

-- Helper function for the example
CREATE OR REPLACE FUNCTION calculate_important_value RETURN NUMBER
IS
BEGIN
    -- Critical business calculation that must never fail
    RETURN ROUND(DBMS_RANDOM.VALUE(1, 1000), 2);
END;
/

-- Test telemetry-safe operations
BEGIN
    telemetry_safe_operation_example();
END;
/

-- Pattern 4: Transaction rollback with telemetry preservation
-- ============================================================================
PROMPT
PROMPT Pattern 4: Transaction rollback with telemetry preservation
PROMPT ============================================================================

CREATE OR REPLACE PROCEDURE transaction_rollback_example
IS
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
    l_savepoint_name VARCHAR2(30) := 'BEFORE_BUSINESS_LOGIC';
BEGIN
    l_trace_id := PLTelemetry.start_trace('transaction_with_rollback');
    l_span_id := PLTelemetry.start_span('transactional_operation');
    
    -- Set savepoint before business transaction
    SAVEPOINT before_business_logic;
    
    BEGIN
        -- Simulate transactional business logic
        l_attrs(1) := PLTelemetry.add_attribute('transaction.type', 'financial');
        PLTelemetry.add_event(l_span_id, 'transaction_started', l_attrs);
        
        -- Business operations that might need rollback
        INSERT INTO test_table VALUES (1, 'test_data', SYSDATE);
        
        -- Simulate error condition
        IF DBMS_RANDOM.VALUE(0, 1) > 0.5 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Business rule violation - transaction must be rolled back');
        END IF;
        
        -- Success path
        PLTelemetry.add_event(l_span_id, 'transaction_committed');
        PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
        
        -- Commit business transaction (telemetry auto-commits separately if needed)
        COMMIT;
        
        DBMS_OUTPUT.PUT_LINE('Transaction completed successfully');
        
    EXCEPTION
        WHEN OTHERS THEN
            -- Rollback business transaction to savepoint
            ROLLBACK TO before_business_logic;
            
            -- Add error information to telemetry
            l_attrs(2) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SQLERRM);
            l_attrs(3) := PLTelemetry.add_attribute('transaction.status', 'rolled_back');
            
            PLTelemetry.add_event(l_span_id, 'transaction_rolled_back', l_attrs);
            PLTelemetry.end_span(l_span_id, 'ERROR', l_attrs);
            
            -- Telemetry is preserved (it commits separately in async mode)
            
            DBMS_OUTPUT.PUT_LINE('Transaction rolled back: ' || SQLERRM);
            -- Don't re-raise if this is expected business behavior
    END;
    
    PLTelemetry.end_trace(l_trace_id);
END;
/

-- Create test table for the example
CREATE TABLE test_table (
    id NUMBER PRIMARY KEY,
    data VARCHAR2(100),
    created_date DATE
);

-- Test transaction rollback
BEGIN
    FOR i IN 1..3 LOOP
        DBMS_OUTPUT.PUT_LINE('--- Test ' || i || ' ---');
        transaction_rollback_example();
    END LOOP;
END;
/

-- Clean up test table
DROP TABLE test_table;

-- Pattern 5: Retry logic with telemetry
-- ============================================================================
PROMPT
PROMPT Pattern 5: Retry logic with telemetry tracking
PROMPT ============================================================================

CREATE OR REPLACE PROCEDURE retry_logic_example
IS
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_retry_span VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
    l_max_retries CONSTANT NUMBER := 3;
    l_retry_count NUMBER := 0;
    l_success BOOLEAN := FALSE;
BEGIN
    l_trace_id := PLTelemetry.start_trace('operation_with_retries');
    l_span_id := PLTelemetry.start_span('retry_operation');
    
    l_attrs(1) := PLTelemetry.add_attribute('retry.max_attempts', TO_CHAR(l_max_retries));
    PLTelemetry.add_event(l_span_id, 'retry_operation_started', l_attrs);
    
    WHILE l_retry_count < l_max_retries AND NOT l_success LOOP
        l_retry_count := l_retry_count + 1;
        
        -- Create span for each retry attempt
        l_retry_span := PLTelemetry.start_span('retry_attempt_' || l_retry_count, l_span_id);
        
        l_attrs.DELETE;
        l_attrs(1) := PLTelemetry.add_attribute('retry.attempt', TO_CHAR(l_retry_count));
        l_attrs(2) := PLTelemetry.add_attribute('retry.max_attempts', TO_CHAR(l_max_retries));
        
        BEGIN
            PLTelemetry.add_event(l_retry_span, 'attempt_started', l_attrs);
            
            -- Simulate operation that might fail
            IF DBMS_RANDOM.VALUE(0, 1) > (0.3 * l_retry_count) THEN  -- Higher success chance each retry
                RAISE_APPLICATION_ERROR(-20001, 'Temporary failure - attempt ' || l_retry_count);
            END IF;
            
            -- Success!
            l_success := TRUE;
            PLTelemetry.add_event(l_retry_span, 'attempt_successful', l_attrs);
            PLTelemetry.end_span(l_retry_span, 'OK', l_attrs);
            
            DBMS_OUTPUT.PUT_LINE('Operation succeeded on attempt ' || l_retry_count);
            
        EXCEPTION
            WHEN OTHERS THEN
                l_attrs(3) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SQLERRM);
                l_attrs(4) := PLTelemetry.add_attribute('retry.will_retry', 
                    CASE WHEN l_retry_count < l_max_retries THEN 'true' ELSE 'false' END);
                
                PLTelemetry.add_event(l_retry_span, 'attempt_failed', l_attrs);
                PLTelemetry.end_span(l_retry_span, 'ERROR', l_attrs);
                
                DBMS_OUTPUT.PUT_LINE('Attempt ' || l_retry_count || ' failed: ' || SQLERRM);
                
                -- If not the last attempt, wait before retrying
                IF l_retry_count < l_max_retries THEN
                    DBMS_LOCK.SLEEP(l_retry_count);  -- Exponential backoff
                ELSE
                    -- All retries exhausted
                    l_attrs(5) := PLTelemetry.add_attribute('retry.exhausted', 'true');
                    PLTelemetry.add_event(l_span_id, 'all_retries_exhausted', l_attrs);
                    PLTelemetry.end_span(l_span_id, 'ERROR', l_attrs);
                    PLTelemetry.end_trace(l_trace_id);
                    RAISE_APPLICATION_ERROR(-20999, 'Operation failed after ' || l_max_retries || ' attempts');
                END IF;
        END;
    END LOOP;
    
    -- Operation succeeded
    l_attrs.DELETE;
    l_attrs(1) := PLTelemetry.add_attribute('retry.final_attempt', TO_CHAR(l_retry_count));
    l_attrs(2) := PLTelemetry.add_attribute('retry.success', 'true');
    
    PLTelemetry.add_event(l_span_id, 'retry_operation_completed', l_attrs);
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    PLTelemetry.end_trace(l_trace_id);
END;
/

-- Test retry logic
BEGIN
    FOR i IN 1..3 LOOP
        BEGIN
            DBMS_OUTPUT.PUT_LINE('=== Retry Test ' || i || ' ===');
            retry_logic_example();
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Final failure: ' || SQLERRM);
        END;
        DBMS_OUTPUT.PUT_LINE('');
    END LOOP;
END;
/

-- Pattern 6: Circuit breaker pattern with telemetry
-- ============================================================================
PROMPT
PROMPT Pattern 6: Circuit breaker pattern with telemetry
PROMPT ============================================================================

-- Simple circuit breaker state table
CREATE TABLE circuit_breaker_state (
    service_name VARCHAR2(100) PRIMARY KEY,
    state VARCHAR2(20) CHECK (state IN ('CLOSED', 'OPEN', 'HALF_OPEN')),
    failure_count NUMBER DEFAULT 0,
    last_failure TIMESTAMP,
    next_attempt TIMESTAMP
);

CREATE OR REPLACE PROCEDURE circuit_breaker_example(
    p_service_name VARCHAR2 DEFAULT 'external_api'
)
IS
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
    l_state    VARCHAR2(20);
    l_failure_count NUMBER;
    l_next_attempt TIMESTAMP;
    l_max_failures CONSTANT NUMBER := 3;
    l_timeout_minutes CONSTANT NUMBER := 5;
BEGIN
    l_trace_id := PLTelemetry.start_trace('circuit_breaker_operation');
    l_span_id := PLTelemetry.start_span('check_circuit_breaker');
    
    l_attrs(1) := PLTelemetry.add_attribute('service.name', p_service_name);
    l_attrs(2) := PLTelemetry.add_attribute('circuit_breaker.max_failures', TO_CHAR(l_max_failures));
    
    -- Get current circuit breaker state
    BEGIN
        SELECT state, failure_count, next_attempt
        INTO l_state, l_failure_count, l_next_attempt
        FROM circuit_breaker_state
        WHERE service_name = p_service_name;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            -- Initialize circuit breaker
            INSERT INTO circuit_breaker_state (service_name, state, failure_count)
            VALUES (p_service_name, 'CLOSED', 0);
            l_state := 'CLOSED';
            l_failure_count := 0;
    END;
    
    l_attrs(3) := PLTelemetry.add_attribute('circuit_breaker.state', l_state);
    l_attrs(4) := PLTelemetry.add_attribute('circuit_breaker.failure_count', TO_CHAR(l_failure_count));
    
    -- Check if circuit breaker allows the call
    IF l_state = 'OPEN' THEN
        IF SYSTIMESTAMP < l_next_attempt THEN
            -- Circuit is open and timeout not reached
            l_attrs(5) := PLTelemetry.add_attribute('circuit_breaker.action', 'blocked');
            PLTelemetry.add_event(l_span_id, 'circuit_breaker_blocked_call', l_attrs);
            PLTelemetry.end_span(l_span_id, 'ERROR', l_attrs);
            PLTelemetry.end_trace(l_trace_id);
            
            RAISE_APPLICATION_ERROR(-20503, 'Service unavailable - circuit breaker is OPEN');
        ELSE
            -- Timeout reached, transition to HALF_OPEN
            UPDATE circuit_breaker_state 
            SET state = 'HALF_OPEN' 
            WHERE service_name = p_service_name;
            l_state := 'HALF_OPEN';
            
            l_attrs(5) := PLTelemetry.add_attribute('circuit_breaker.action', 'half_open_transition');
            PLTelemetry.add_event(l_span_id, 'circuit_breaker_half_open', l_attrs);
        END IF;
    END IF;
    
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    
    -- Attempt the actual service call
    DECLARE
        l_call_span VARCHAR2(16);
    BEGIN
        l_call_span := PLTelemetry.start_span('service_call', l_span_id);
        
        l_attrs(5) := PLTelemetry.add_attribute('circuit_breaker.call_allowed', 'true');
        PLTelemetry.add_event(l_call_span, 'service_call_started', l_attrs);
        
        -- Simulate service call that might fail
        IF DBMS_RANDOM.VALUE(0, 1) > 0.7 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Service call failed');
        END IF;
        
        -- Success - reset circuit breaker
        IF l_state IN ('HALF_OPEN', 'CLOSED') THEN
            UPDATE circuit_breaker_state 
            SET state = 'CLOSED', failure_count = 0, last_failure = NULL, next_attempt = NULL
            WHERE service_name = p_service_name;
            
            l_attrs(6) := PLTelemetry.add_attribute('circuit_breaker.reset', 'true');
        END IF;
        
        PLTelemetry.add_event(l_call_span, 'service_call_successful', l_attrs);
        PLTelemetry.end_span(l_call_span, 'OK', l_attrs);
        
        DBMS_OUTPUT.PUT_LINE('Service call successful - circuit breaker reset to CLOSED');
        
    EXCEPTION
        WHEN OTHERS THEN
            -- Service call failed
            l_failure_count := l_failure_count + 1;
            
            l_attrs(6) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SQLERRM);
            l_attrs(7) := PLTelemetry.add_attribute('circuit_breaker.failure_count', TO_CHAR(l_failure_count));
            
            IF l_failure_count >= l_max_failures THEN
                -- Open the circuit breaker
                UPDATE circuit_breaker_state 
                SET state = 'OPEN', 
                    failure_count = l_failure_count,
                    last_failure = SYSTIMESTAMP,
                    next_attempt = SYSTIMESTAMP + INTERVAL l_timeout_minutes MINUTE
                WHERE service_name = p_service_name;
                
                l_attrs(8) := PLTelemetry.add_attribute('circuit_breaker.opened', 'true');
                l_attrs(9) := PLTelemetry.add_attribute('circuit_breaker.timeout_minutes', TO_CHAR(l_timeout_minutes));
                PLTelemetry.add_event(l_call_span, 'circuit_breaker_opened', l_attrs);
                
                DBMS_OUTPUT.PUT_LINE('Circuit breaker OPENED due to ' || l_failure_count || ' failures');
            ELSE
                -- Increment failure count but keep circuit closed
                UPDATE circuit_breaker_state 
                SET failure_count = l_failure_count, last_failure = SYSTIMESTAMP
                WHERE service_name = p_service_name;
                
                PLTelemetry.add_event(l_call_span, 'service_call_failed', l_attrs);
                DBMS_OUTPUT.PUT_LINE('Service call failed (' || l_failure_count || '/' || l_max_failures || ' failures)');
            END IF;
            
            PLTelemetry.end_span(l_call_span, 'ERROR', l_attrs);
            PLTelemetry.end_trace(l_trace_id);
            RAISE;
    END;
    
    PLTelemetry.end_trace(l_trace_id);
END;
/

-- Test circuit breaker pattern
BEGIN
    FOR i IN 1..8 LOOP
        BEGIN
            DBMS_OUTPUT.PUT_LINE('=== Circuit Breaker Test ' || i || ' ===');
            circuit_breaker_example('test_service');
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Call blocked/failed: ' || SQLERRM);
        END;
        DBMS_OUTPUT.PUT_LINE('');
        
        -- Brief pause between calls
        DBMS_LOCK.SLEEP(1);
    END LOOP;
END;
/

-- Clean up circuit breaker test
DROP TABLE circuit_breaker_state;

PROMPT
PROMPT ================================================================================
PROMPT Error Handling Patterns Summary
PROMPT ================================================================================
PROMPT
PROMPT Patterns Demonstrated:
PROMPT ✓ Basic error handling with span status tracking
PROMPT ✓ Nested operations with proper error propagation
PROMPT ✓ Telemetry-safe operations (defensive programming)
PROMPT ✓ Transaction rollback with telemetry preservation
PROMPT ✓ Retry logic with attempt tracking
PROMPT ✓ Circuit breaker pattern with state management
PROMPT
PROMPT Key Principles:
PROMPT 1. NEVER let telemetry break business logic
PROMPT 2. Always re-raise business exceptions after telemetry
PROMPT 3. Use defensive programming for telemetry operations
PROMPT 4. Preserve telemetry data even during transaction rollbacks
PROMPT 5. Track retry attempts and failure patterns
PROMPT 6. Implement circuit breakers for external dependencies
PROMPT 7. Use proper error attributes for debugging
PROMPT
PROMPT Best Practices:
PROMPT • Wrap telemetry calls in BEGIN/EXCEPTION blocks
PROMPT • Use savepoints to preserve telemetry during rollbacks
PROMPT • Add comprehensive error attributes for debugging
PROMPT • Track patterns like retries and circuit breaker states
PROMPT • Set proper span status (OK/ERROR) for observability
PROMPT • Log both technical and business error contexts
PROMPT
PROMPT ================================================================================
[END OF FILE: examples/error_handling.sql]


========================================================================
FILE: examples/ords_integration.sql
SIZE: 19704 bytes
MODIFIED: ./examples/ords_integration.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550563 1550563 18446744073709551615 -1
2025-06-23 06:16:29.777972800
========================================================================

-- PLTelemetry ORDS Integration Examples
-- This file demonstrates how to integrate PLTelemetry with Oracle REST Data Services (ORDS)
-- for distributed tracing across Angular -> ORDS -> Oracle -> Tauri workflows

PROMPT ================================================================================
PROMPT PLTelemetry ORDS Integration Examples
PROMPT ================================================================================

-- Example 1: Basic ORDS REST endpoint with telemetry
-- ============================================================================
PROMPT
PROMPT Example 1: Basic ORDS REST endpoint with telemetry
PROMPT ============================================================================

CREATE OR REPLACE PROCEDURE ords_get_customer(
    p_customer_id   IN  NUMBER,
    p_trace_id      IN  VARCHAR2 DEFAULT NULL,  -- From HTTP header X-Trace-Id
    p_span_id       IN  VARCHAR2 DEFAULT NULL,  -- From HTTP header X-Parent-Span-Id
    p_user_id       IN  VARCHAR2 DEFAULT NULL   -- From JWT or session
) 
IS
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
    l_customer_name VARCHAR2(100);
BEGIN
    -- Continue existing trace or start new one
    IF p_trace_id IS NOT NULL THEN
        PLTelemetry.g_current_trace_id := p_trace_id;
        l_trace_id := p_trace_id;
    ELSE
        l_trace_id := PLTelemetry.start_trace('ords_get_customer');
    END IF;
    
    -- Start ORDS span
    l_span_id := PLTelemetry.start_span('ords_get_customer', p_span_id, l_trace_id);
    
    -- Add HTTP semantic attributes
    l_attrs(1) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_METHOD, 'GET');
    l_attrs(2) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_URL, '/ords/api/v1/customers/' || p_customer_id);
    l_attrs(3) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_USER_ID, NVL(p_user_id, 'anonymous'));
    l_attrs(4) := PLTelemetry.add_attribute('customer.id', TO_CHAR(p_customer_id));
    
    PLTelemetry.add_event(l_span_id, 'ords_request_started', l_attrs);
    
    -- Database operation with nested span
    DECLARE
        l_db_span VARCHAR2(16);
    BEGIN
        l_db_span := PLTelemetry.start_span('query_customer_data', l_span_id);
        
        l_attrs(5) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_DB_OPERATION, 'SELECT');
        l_attrs(6) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_DB_STATEMENT, 'SELECT name FROM customers WHERE id = ?');
        
        -- Simulate database query
        BEGIN
            SELECT name INTO l_customer_name 
            FROM customers 
            WHERE customer_id = p_customer_id;
            
            l_attrs(7) := PLTelemetry.add_attribute('customer.name', l_customer_name);
            l_attrs(8) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_STATUS, '200');
            
            PLTelemetry.add_event(l_db_span, 'customer_found', l_attrs);
            PLTelemetry.end_span(l_db_span, 'OK', l_attrs);
            
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                l_attrs(7) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_STATUS, '404');
                l_attrs(8) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, 'Customer not found');
                
                PLTelemetry.add_event(l_db_span, 'customer_not_found', l_attrs);
                PLTelemetry.end_span(l_db_span, 'ERROR', l_attrs);
                
                PLTelemetry.end_span(l_span_id, 'ERROR', l_attrs);
                IF p_trace_id IS NULL THEN PLTelemetry.end_trace(l_trace_id); END IF;
                
                RAISE_APPLICATION_ERROR(-20404, 'Customer not found');
        END;
    END;
    
    -- Complete ORDS span
    PLTelemetry.add_event(l_span_id, 'ords_response_ready', l_attrs);
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    
    -- Record API metric
    PLTelemetry.log_metric('api_request_count', 1, 'requests', l_attrs);
    
    -- Only end trace if we started it
    IF p_trace_id IS NULL THEN
        PLTelemetry.end_trace(l_trace_id);
    END IF;
    
EXCEPTION
    WHEN OTHERS THEN
        l_attrs(7) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_STATUS, '500');
        l_attrs(8) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SUBSTR(SQLERRM, 1, 500));
        
        PLTelemetry.add_event(l_span_id, 'ords_error', l_attrs);
        PLTelemetry.end_span(l_span_id, 'ERROR', l_attrs);
        PLTelemetry.log_metric('api_error_count', 1, 'errors', l_attrs);
        
        IF p_trace_id IS NULL THEN PLTelemetry.end_trace(l_trace_id); END IF;
        RAISE;
END;
/

-- Example 2: ORDS POST endpoint for order creation
-- ============================================================================
PROMPT
PROMPT Example 2: ORDS POST endpoint for order creation
PROMPT ============================================================================

CREATE OR REPLACE PROCEDURE ords_create_order(
    p_customer_id   IN  NUMBER,
    p_items         IN  VARCHAR2,  -- JSON array of items
    p_total_amount  IN  NUMBER,
    p_trace_id      IN  VARCHAR2 DEFAULT NULL,
    p_span_id       IN  VARCHAR2 DEFAULT NULL,
    p_user_id       IN  VARCHAR2 DEFAULT NULL,
    p_order_id      OUT NUMBER
)
IS
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
    l_validation_span VARCHAR2(16);
    l_create_span VARCHAR2(16);
    l_inventory_span VARCHAR2(16);
BEGIN
    -- Setup tracing context
    IF p_trace_id IS NOT NULL THEN
        PLTelemetry.g_current_trace_id := p_trace_id;
        l_trace_id := p_trace_id;
    ELSE
        l_trace_id := PLTelemetry.start_trace('ords_create_order');
    END IF;
    
    l_span_id := PLTelemetry.start_span('ords_create_order', p_span_id, l_trace_id);
    
    -- Setup base attributes
    l_attrs(1) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_METHOD, 'POST');
    l_attrs(2) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_URL, '/ords/api/v1/orders');
    l_attrs(3) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_USER_ID, NVL(p_user_id, 'anonymous'));
    l_attrs(4) := PLTelemetry.add_attribute('customer.id', TO_CHAR(p_customer_id));
    l_attrs(5) := PLTelemetry.add_attribute('order.total_amount', TO_CHAR(p_total_amount));
    
    PLTelemetry.add_event(l_span_id, 'order_creation_started', l_attrs);
    
    -- Step 1: Validation
    l_validation_span := PLTelemetry.start_span('validate_order_request', l_span_id);
    BEGIN
        -- Validate customer exists
        DECLARE
            l_customer_count NUMBER;
        BEGIN
            SELECT COUNT(*) INTO l_customer_count 
            FROM customers 
            WHERE customer_id = p_customer_id AND status = 'ACTIVE';
            
            IF l_customer_count = 0 THEN
                RAISE_APPLICATION_ERROR(-20400, 'Invalid or inactive customer');
            END IF;
        END;
        
        -- Validate order total
        IF p_total_amount <= 0 THEN
            RAISE_APPLICATION_ERROR(-20400, 'Invalid order total');
        END IF;
        
        PLTelemetry.add_event(l_validation_span, 'validation_passed');
        PLTelemetry.end_span(l_validation_span, 'OK');
        
    EXCEPTION
        WHEN OTHERS THEN
            l_attrs(6) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SQLERRM);
            PLTelemetry.end_span(l_validation_span, 'ERROR', l_attrs);
            RAISE;
    END;
    
    -- Step 2: Check inventory
    l_inventory_span := PLTelemetry.start_span('check_inventory', l_span_id);
    BEGIN
        -- Simulate inventory check
        DBMS_LOCK.SLEEP(0.1);
        
        l_attrs(6) := PLTelemetry.add_attribute('inventory.check_result', 'sufficient');
        PLTelemetry.add_event(l_inventory_span, 'inventory_checked', l_attrs);
        PLTelemetry.end_span(l_inventory_span, 'OK', l_attrs);
        
    EXCEPTION
        WHEN OTHERS THEN
            l_attrs(6) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, 'Insufficient inventory');
            PLTelemetry.end_span(l_inventory_span, 'ERROR', l_attrs);
            RAISE;
    END;
    
    -- Step 3: Create order
    l_create_span := PLTelemetry.start_span('create_order_record', l_span_id);
    BEGIN
        -- Generate order ID (simplified)
        SELECT order_seq.NEXTVAL INTO p_order_id FROM DUAL;
        
        -- Insert order (simplified)
        INSERT INTO orders (order_id, customer_id, total_amount, status, created_date)
        VALUES (p_order_id, p_customer_id, p_total_amount, 'PENDING', SYSDATE);
        
        l_attrs(6) := PLTelemetry.add_attribute('order.id', TO_CHAR(p_order_id));
        l_attrs(7) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_DB_OPERATION, 'INSERT');
        
        PLTelemetry.add_event(l_create_span, 'order_created', l_attrs);
        PLTelemetry.end_span(l_create_span, 'OK', l_attrs);
        
    EXCEPTION
        WHEN OTHERS THEN
            l_attrs(6) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SQLERRM);
            PLTelemetry.end_span(l_create_span, 'ERROR', l_attrs);
            RAISE;
    END;
    
    -- Complete main span
    l_attrs(8) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_STATUS, '201');
    PLTelemetry.add_event(l_span_id, 'order_creation_completed', l_attrs);
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    
    -- Record metrics
    PLTelemetry.log_metric('orders_created', 1, 'orders', l_attrs);
    PLTelemetry.log_metric('order_value', p_total_amount, 'EUR', l_attrs);
    
    IF p_trace_id IS NULL THEN PLTelemetry.end_trace(l_trace_id); END IF;
    
EXCEPTION
    WHEN OTHERS THEN
        l_attrs(8) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_HTTP_STATUS, '500');
        l_attrs(9) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SUBSTR(SQLERRM, 1, 500));
        
        PLTelemetry.add_event(l_span_id, 'order_creation_failed', l_attrs);
        PLTelemetry.end_span(l_span_id, 'ERROR', l_attrs);
        PLTelemetry.log_metric('order_creation_errors', 1, 'errors', l_attrs);
        
        IF p_trace_id IS NULL THEN PLTelemetry.end_trace(l_trace_id); END IF;
        RAISE;
END;
/

-- Example 3: ORDS procedure for distributed trace propagation
-- ============================================================================
PROMPT
PROMPT Example 3: ORDS trace context extraction helper
PROMPT ============================================================================

CREATE OR REPLACE FUNCTION extract_trace_context(
    p_http_headers IN VARCHAR2  -- JSON string of HTTP headers
) RETURN VARCHAR2  -- Returns trace_id
IS
    l_trace_id VARCHAR2(32);
    l_traceparent VARCHAR2(100);
BEGIN
    -- Extract W3C traceparent header if available
    -- Format: 00-{trace-id}-{parent-id}-{trace-flags}
    BEGIN
        SELECT JSON_VALUE(p_http_headers, '$.traceparent') 
        INTO l_traceparent 
        FROM DUAL;
        
        IF l_traceparent IS NOT NULL THEN
            -- Extract trace ID from traceparent
            l_trace_id := SUBSTR(l_traceparent, 4, 32);  -- Skip version and hyphen
            RETURN l_trace_id;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            NULL; -- Continue to fallback
    END;
    
    -- Fallback: Extract custom X-Trace-Id header
    BEGIN
        SELECT JSON_VALUE(p_http_headers, '$."x-trace-id"') 
        INTO l_trace_id 
        FROM DUAL;
        
        IF l_trace_id IS NOT NULL THEN
            RETURN l_trace_id;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;
    
    -- No trace context found
    RETURN NULL;
END;
/

-- Example 4: Complete ORDS workflow with trace propagation
-- ============================================================================
PROMPT
PROMPT Example 4: Complete ORDS workflow simulation
PROMPT ============================================================================

CREATE OR REPLACE PROCEDURE ords_complete_workflow_example
IS
    l_trace_id VARCHAR2(32);
    l_main_span VARCHAR2(16);
    l_order_id NUMBER;
    l_headers VARCHAR2(1000);
BEGIN
    -- Simulate receiving trace context from Angular
    l_trace_id := 'a1b2c3d4e5f6789012345678901234ab';  -- From Angular frontend
    
    -- Simulate HTTP headers JSON
    l_headers := '{"x-trace-id": "' || l_trace_id || '", "authorization": "Bearer jwt-token", "content-type": "application/json"}';
    
    DBMS_OUTPUT.PUT_LINE('Simulating ORDS workflow with trace: ' || l_trace_id);
    
    -- Step 1: ORDS receives request from Angular
    PLTelemetry.g_current_trace_id := l_trace_id;
    l_main_span := PLTelemetry.start_span('ords_order_workflow', NULL, l_trace_id);
    
    -- Step 2: Process order creation
    ords_create_order(
        p_customer_id  => 12345,
        p_items        => '[{"item_id": 1, "quantity": 2}, {"item_id": 2, "quantity": 1}]',
        p_total_amount => 299.99,
        p_trace_id     => l_trace_id,
        p_span_id      => l_main_span,
        p_user_id      => 'user123',
        p_order_id     => l_order_id
    );
    
    -- Step 3: Simulate response to Angular (which will continue to Tauri)
    DECLARE
        l_response_span VARCHAR2(16);
        l_attrs PLTelemetry.t_attributes;
    BEGIN
        l_response_span := PLTelemetry.start_span('prepare_response', l_main_span);
        
        l_attrs(1) := PLTelemetry.add_attribute('order.id', TO_CHAR(l_order_id));
        l_attrs(2) := PLTelemetry.add_attribute('response.format', 'JSON');
        l_attrs(3) := PLTelemetry.add_attribute('next_step', 'print_order');
        
        PLTelemetry.add_event(l_response_span, 'response_prepared_for_angular', l_attrs);
        PLTelemetry.end_span(l_response_span, 'OK', l_attrs);
    END;
    
    PLTelemetry.end_span(l_main_span, 'OK');
    
    DBMS_OUTPUT.PUT_LINE('Order created: ' || l_order_id);
    DBMS_OUTPUT.PUT_LINE('Trace continues to Angular, then to Tauri for printing...');
    
    -- Note: Trace is NOT ended here because it continues to Angular -> Tauri
    -- Angular will continue the same trace when calling Tauri for printing
END;
/

-- Test the complete workflow
BEGIN
    ords_complete_workflow_example();
END;
/

-- Example 5: ORDS authentication and authorization with telemetry
-- ============================================================================
PROMPT
PROMPT Example 5: ORDS authentication with telemetry
PROMPT ============================================================================

CREATE OR REPLACE FUNCTION ords_validate_jwt_token(
    p_jwt_token IN VARCHAR2,
    p_trace_id  IN VARCHAR2 DEFAULT NULL
) RETURN VARCHAR2  -- Returns user_id or raises exception
IS
    l_span_id VARCHAR2(16);
    l_attrs   PLTelemetry.t_attributes;
    l_user_id VARCHAR2(100);
BEGIN
    l_span_id := PLTelemetry.start_span('validate_jwt_token', NULL, p_trace_id);
    
    l_attrs(1) := PLTelemetry.add_attribute('auth.method', 'JWT');
    l_attrs(2) := PLTelemetry.add_attribute('token.length', TO_CHAR(LENGTH(p_jwt_token)));
    
    PLTelemetry.add_event(l_span_id, 'jwt_validation_started', l_attrs);
    
    -- Simulate JWT validation
    IF p_jwt_token IS NULL OR LENGTH(p_jwt_token) < 20 THEN
        l_attrs(3) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, 'Invalid JWT token');
        PLTelemetry.add_event(l_span_id, 'jwt_validation_failed', l_attrs);
        PLTelemetry.end_span(l_span_id, 'ERROR', l_attrs);
        RAISE_APPLICATION_ERROR(-20401, 'Invalid JWT token');
    END IF;
    
    -- Extract user_id from token (simplified)
    l_user_id := 'user_' || SUBSTR(p_jwt_token, -6);
    
    l_attrs(3) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_USER_ID, l_user_id);
    PLTelemetry.add_event(l_span_id, 'jwt_validation_successful', l_attrs);
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    
    RETURN l_user_id;
    
EXCEPTION
    WHEN OTHERS THEN
        l_attrs(3) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, SQLERRM);
        PLTelemetry.end_span(l_span_id, 'ERROR', l_attrs);
        RAISE;
END;
/

-- Example 6: ORDS response time monitoring
-- ============================================================================
PROMPT
PROMPT Example 6: ORDS response time monitoring
PROMPT ============================================================================

CREATE OR REPLACE PROCEDURE ords_monitor_performance
IS
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
    l_start_time TIMESTAMP;
    l_end_time TIMESTAMP;
    l_duration NUMBER;
BEGIN
    l_trace_id := PLTelemetry.start_trace('ords_performance_monitoring');
    l_span_id := PLTelemetry.start_span('api_performance_test');
    
    l_start_time := SYSTIMESTAMP;
    
    -- Simulate various API response times
    FOR i IN 1..5 LOOP
        DECLARE
            l_api_span VARCHAR2(16);
            l_response_time NUMBER;
        BEGIN
            l_api_span := PLTelemetry.start_span('api_call_' || i, l_span_id);
            
            -- Simulate API call with random response time
            l_response_time := DBMS_RANDOM.VALUE(50, 500);  -- 50-500ms
            DBMS_LOCK.SLEEP(l_response_time / 1000);
            
            l_attrs(1) := PLTelemetry.add_attribute('api.endpoint', '/api/v1/endpoint' || i);
            l_attrs(2) := PLTelemetry.add_attribute('response.time_ms', TO_CHAR(l_response_time));
            
            PLTelemetry.end_span(l_api_span, 'OK', l_attrs);
            PLTelemetry.log_metric('api_response_time', l_response_time, 'milliseconds', l_attrs);
        END;
    END LOOP;
    
    l_end_time := SYSTIMESTAMP;
    l_duration := EXTRACT(SECOND FROM (l_end_time - l_start_time)) * 1000;
    
    l_attrs(1) := PLTelemetry.add_attribute('total.duration_ms', TO_CHAR(l_duration));
    PLTelemetry.log_metric('total_test_duration', l_duration, 'milliseconds', l_attrs);
    
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    PLTelemetry.end_trace(l_trace_id);
    
    DBMS_OUTPUT.PUT_LINE('Performance test completed in ' || ROUND(l_duration, 2) || 'ms');
END;
/

-- Run performance monitoring example
BEGIN
    ords_monitor_performance();
END;
/

PROMPT
PROMPT ================================================================================
PROMPT ORDS Integration Examples Completed
PROMPT ================================================================================
PROMPT
PROMPT Key Integration Patterns Demonstrated:
PROMPT ✓ Trace propagation from Angular frontend via HTTP headers
PROMPT ✓ RESTful API endpoint instrumentation
PROMPT ✓ Nested spans for complex operations
PROMPT ✓ HTTP semantic conventions usage
PROMPT ✓ JWT authentication with telemetry
PROMPT ✓ Performance monitoring for APIs
PROMPT ✓ Error handling with proper status codes
PROMPT
PROMPT For Production Use:
PROMPT 1. Extract trace context from ORDS HTTP headers
PROMPT 2. Pass trace_id and span_id to your PL/SQL procedures
PROMPT 3. Use semantic conventions for HTTP operations
PROMPT 4. Monitor API performance with metrics
PROMPT 5. Ensure traces continue to Tauri via WebSocket
PROMPT
PROMPT ================================================================================
[END OF FILE: examples/ords_integration.sql]


========================================================================
FILE: install/grants/plt_grants.sql
SIZE: 6594 bytes
MODIFIED: ./install/grants/plt_grants.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550558 1550558 18446744073709551615 -1
2025-06-23 06:16:29.780970400
========================================================================

-- PLTelemetry Required Grants
-- This script sets up the necessary privileges for PLTelemetry operation
-- 
-- Run this as a privileged user (DBA) to grant necessary permissions
-- to the PLTelemetry installation user

PROMPT Setting up required grants for PLTelemetry...

-- Define the target user (replace with actual username)
DEFINE PLT_USER = &1

-- Validate that user was provided
DECLARE
    l_username VARCHAR2(128) := UPPER('&PLT_USER');
BEGIN
    IF l_username IS NULL OR l_username = 'UNDEFINED' THEN
        RAISE_APPLICATION_ERROR(-20001, 
            'Usage: @plt_grants.sql <username>' || CHR(10) ||
            'Example: @plt_grants.sql MYAPP_USER');
    END IF;
    
    -- Check if user exists
    DECLARE
        l_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO l_count 
        FROM DBA_USERS 
        WHERE USERNAME = l_username;
        
        IF l_count = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 
                'User ' || l_username || ' does not exist');
        END IF;
    END;
    
    DBMS_OUTPUT.PUT_LINE('Setting up grants for user: ' || l_username);
END;
/

-- Core Oracle packages required for PLTelemetry
PROMPT Granting access to core Oracle packages...

-- UTL_HTTP for backend communication
GRANT EXECUTE ON SYS.UTL_HTTP TO &PLT_USER;

-- DBMS_CRYPTO for ID generation
GRANT EXECUTE ON SYS.DBMS_CRYPTO TO &PLT_USER;

-- DBMS_SCHEDULER for queue processing jobs
GRANT EXECUTE ON SYS.DBMS_SCHEDULER TO &PLT_USER;

-- DBMS_APPLICATION_INFO for session context
GRANT EXECUTE ON SYS.DBMS_APPLICATION_INFO TO &PLT_USER;

-- DBMS_UTILITY for error stack formatting
GRANT EXECUTE ON SYS.DBMS_UTILITY TO &PLT_USER;

-- Database privileges
PROMPT Granting database privileges...

-- CREATE JOB for scheduler jobs
GRANT CREATE JOB TO &PLT_USER;

-- CREATE PROCEDURE for package installation
GRANT CREATE PROCEDURE TO &PLT_USER;

-- CREATE TABLE (if not already granted)
GRANT CREATE TABLE TO &PLT_USER;

-- CREATE INDEX for performance indexes
GRANT CREATE INDEX TO &PLT_USER;

-- Network access for HTTP calls
PROMPT Setting up network access...

-- Note: Network ACLs might need to be configured separately
-- This is an example - adjust host and port ranges as needed
BEGIN
    -- Check if ACL exists for PLTelemetry
    DECLARE
        l_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO l_count 
        FROM DBA_NETWORK_ACLS 
        WHERE ACL = 'pltelemetry_acl.xml';
        
        IF l_count = 0 THEN
            -- Create ACL for PLTelemetry HTTP access
            DBMS_NETWORK_ACL_ADMIN.CREATE_ACL(
                acl         => 'pltelemetry_acl.xml',
                description => 'PLTelemetry HTTP access for telemetry export',
                principal   => UPPER('&PLT_USER'),
                is_grant    => TRUE,
                privilege   => 'connect'
            );
            
            -- Grant resolve privilege
            DBMS_NETWORK_ACL_ADMIN.ADD_PRIVILEGE(
                acl       => 'pltelemetry_acl.xml',
                principal => UPPER('&PLT_USER'),
                is_grant  => TRUE,
                privilege => 'resolve'
            );
            
            -- Assign ACL to host ranges (adjust as needed)
            -- This example allows access to common ranges - customize for your environment
            DBMS_NETWORK_ACL_ADMIN.ASSIGN_ACL(
                acl  => 'pltelemetry_acl.xml',
                host => '*',  -- All hosts - restrict this in production
                lower_port => 80,
                upper_port => 443
            );
            
            DBMS_OUTPUT.PUT_LINE('✓ Network ACL created for PLTelemetry');
        ELSE
            DBMS_OUTPUT.PUT_LINE('ℹ Network ACL already exists');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('⚠ Warning: Could not set up network ACL automatically');
            DBMS_OUTPUT.PUT_LINE('  You may need to configure network access manually');
            DBMS_OUTPUT.PUT_LINE('  Error: ' || SQLERRM);
    END;
END;
/

-- Verification
PROMPT Verifying grants...
DECLARE
    l_missing_grants VARCHAR2(4000) := '';
    l_count NUMBER;
BEGIN
    -- Check required object privileges
    FOR rec IN (
        SELECT 'UTL_HTTP' as obj_name FROM DUAL UNION ALL
        SELECT 'DBMS_CRYPTO' FROM DUAL UNION ALL
        SELECT 'DBMS_SCHEDULER' FROM DUAL UNION ALL
        SELECT 'DBMS_APPLICATION_INFO' FROM DUAL UNION ALL
        SELECT 'DBMS_UTILITY' FROM DUAL
    ) LOOP
        SELECT COUNT(*) INTO l_count
        FROM DBA_TAB_PRIVS
        WHERE GRANTEE = UPPER('&PLT_USER')
          AND TABLE_NAME = rec.obj_name
          AND PRIVILEGE = 'EXECUTE';
        
        IF l_count = 0 THEN
            l_missing_grants := l_missing_grants || rec.obj_name || ' ';
        END IF;
    END LOOP;
    
    -- Check system privileges
    FOR rec IN (
        SELECT 'CREATE JOB' as priv_name FROM DUAL UNION ALL
        SELECT 'CREATE PROCEDURE' FROM DUAL UNION ALL
        SELECT 'CREATE TABLE' FROM DUAL UNION ALL
        SELECT 'CREATE INDEX' FROM DUAL
    ) LOOP
        SELECT COUNT(*) INTO l_count
        FROM DBA_SYS_PRIVS
        WHERE GRANTEE = UPPER('&PLT_USER')
          AND PRIVILEGE = rec.priv_name;
        
        IF l_count = 0 THEN
            l_missing_grants := l_missing_grants || rec.priv_name || ' ';
        END IF;
    END LOOP;
    
    IF LENGTH(l_missing_grants) > 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 
            'Missing required grants: ' || l_missing_grants);
    ELSE
        DBMS_OUTPUT.PUT_LINE('✓ All required grants verified successfully');
    END IF;
END;
/

PROMPT
PROMPT ================================================================================
PROMPT PLTelemetry Grants Setup Complete
PROMPT ================================================================================
PROMPT
PROMPT Grants provided to user: &PLT_USER
PROMPT
PROMPT Required privileges:
PROMPT ✓ EXECUTE on UTL_HTTP, DBMS_CRYPTO, DBMS_SCHEDULER
PROMPT ✓ CREATE JOB, CREATE PROCEDURE, CREATE TABLE, CREATE INDEX
PROMPT ✓ Network ACL for HTTP access (if possible)
PROMPT
PROMPT Note: You may need to adjust network ACL settings based on your
PROMPT       specific backend URL and security requirements.
PROMPT
PROMPT Next: Run the main installation script as user &PLT_USER
PROMPT ================================================================================
[END OF FILE: install/grants/plt_grants.sql]


========================================================================
FILE: install/install.sql
SIZE: 5532 bytes
MODIFIED: ./install/install.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550557 1550557 18446744073709551615 -1
2025-06-23 06:16:29.783973000
========================================================================

-- PLTelemetry Installation Script
-- Version: 0.1.0
-- 
-- This script installs PLTelemetry package and all required components
-- Run as a privileged user with necessary grants

PROMPT ================================================================================
PROMPT PLTelemetry v0.1.0 Installation
PROMPT OpenTelemetry SDK for Oracle PL/SQL
PROMPT ================================================================================

-- Set environment
SET VERIFY OFF
SET FEEDBACK OFF
SET ECHO ON
SET SERVEROUTPUT ON
WHENEVER SQLERROR EXIT SQL.SQLCODE

-- Check Oracle version compatibility
DECLARE
    l_version VARCHAR2(100);
    l_major_version NUMBER;
BEGIN
    SELECT VERSION INTO l_version FROM V$INSTANCE;
    l_major_version := TO_NUMBER(SUBSTR(l_version, 1, INSTR(l_version, '.') - 1));
    
    IF l_major_version < 12 THEN
        RAISE_APPLICATION_ERROR(-20001, 
            'PLTelemetry requires Oracle 12c or higher. Current version: ' || l_version);
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('Oracle version check passed: ' || l_version);
END;
/

-- Check required privileges
PROMPT Checking required privileges...
DECLARE
    l_count NUMBER;
BEGIN
    -- Check UTL_HTTP access
    BEGIN
        SELECT COUNT(*) INTO l_count 
        FROM USER_TAB_PRIVS 
        WHERE TABLE_NAME = 'UTL_HTTP' AND PRIVILEGE = 'EXECUTE';
        
        IF l_count = 0 THEN
            RAISE_APPLICATION_ERROR(-20002, 
                'Missing EXECUTE privilege on UTL_HTTP. Please grant: GRANT EXECUTE ON UTL_HTTP TO ' || USER);
        END IF;
        DBMS_OUTPUT.PUT_LINE('✓ UTL_HTTP access verified');
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 
                'Cannot verify UTL_HTTP access. Please ensure: GRANT EXECUTE ON UTL_HTTP TO ' || USER);
    END;
    
    -- Check DBMS_CRYPTO access
    BEGIN
        SELECT COUNT(*) INTO l_count 
        FROM USER_TAB_PRIVS 
        WHERE TABLE_NAME = 'DBMS_CRYPTO' AND PRIVILEGE = 'EXECUTE';
        
        IF l_count = 0 THEN
            RAISE_APPLICATION_ERROR(-20003, 
                'Missing EXECUTE privilege on DBMS_CRYPTO. Please grant: GRANT EXECUTE ON DBMS_CRYPTO TO ' || USER);
        END IF;
        DBMS_OUTPUT.PUT_LINE('✓ DBMS_CRYPTO access verified');
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20003, 
                'Cannot verify DBMS_CRYPTO access. Please ensure: GRANT EXECUTE ON DBMS_CRYPTO TO ' || USER);
    END;
END;
/

PROMPT
PROMPT Step 1: Creating database tables...
@@tables/plt_tables.sql

PROMPT
PROMPT Step 2: Creating additional indexes...
@@tables/plt_indexes.sql

PROMPT
PROMPT Step 3: Installing PLTelemetry package specification...
@@../src/PLTelemetry.pks

PROMPT
PROMPT Step 4: Installing PLTelemetry package body...
@@../src/PLTelemetry.pkb

PROMPT
PROMPT Step 5: Setting up scheduler jobs...
@@jobs/plt_queue_processor.sql
@@jobs/plt_cleanup_job.sql

PROMPT
PROMPT Step 6: Verifying installation...
DECLARE
    l_count NUMBER;
    l_status VARCHAR2(10);
BEGIN
    -- Check tables
    SELECT COUNT(*) INTO l_count 
    FROM USER_TABLES 
    WHERE TABLE_NAME IN ('PLT_TRACES', 'PLT_SPANS', 'PLT_EVENTS', 'PLT_METRICS', 
                         'PLT_QUEUE', 'PLT_FAILED_EXPORTS', 'PLT_TELEMETRY_ERRORS');
    
    IF l_count != 7 THEN
        RAISE_APPLICATION_ERROR(-20004, 'Not all tables were created. Expected 7, found ' || l_count);
    END IF;
    DBMS_OUTPUT.PUT_LINE('✓ All tables created successfully');
    
    -- Check package
    SELECT COUNT(*) INTO l_count 
    FROM USER_OBJECTS 
    WHERE OBJECT_NAME = 'PLTELEMETRY' AND OBJECT_TYPE = 'PACKAGE';
    
    IF l_count = 0 THEN
        RAISE_APPLICATION_ERROR(-20005, 'PLTelemetry package not found');
    END IF;
    
    SELECT STATUS INTO l_status 
    FROM USER_OBJECTS 
    WHERE OBJECT_NAME = 'PLTELEMETRY' AND OBJECT_TYPE = 'PACKAGE BODY';
    
    IF l_status != 'VALID' THEN
        RAISE_APPLICATION_ERROR(-20006, 'PLTelemetry package body is not valid');
    END IF;
    DBMS_OUTPUT.PUT_LINE('✓ PLTelemetry package installed and valid');
    
    -- Check jobs
    SELECT COUNT(*) INTO l_count 
    FROM USER_SCHEDULER_JOBS 
    WHERE JOB_NAME IN ('PLT_QUEUE_PROCESSOR', 'PLT_QUEUE_CLEANUP');
    
    IF l_count != 2 THEN
        DBMS_OUTPUT.PUT_LINE('⚠ Warning: Expected 2 scheduler jobs, found ' || l_count);
    ELSE
        DBMS_OUTPUT.PUT_LINE('✓ Scheduler jobs created successfully');
    END IF;
END;
/

PROMPT
PROMPT ================================================================================
PROMPT PLTelemetry Installation Completed Successfully!
PROMPT ================================================================================
PROMPT
PROMPT Next Steps:
PROMPT 1. Configure your backend URL:
PROMPT    PLTelemetry.set_backend_url('https://your-backend.com/api/telemetry');
PROMPT
PROMPT 2. Set your API key:
PROMPT    PLTelemetry.set_api_key('your-secret-api-key');
PROMPT
PROMPT 3. Enable async mode (recommended):
PROMPT    PLTelemetry.set_async_mode(TRUE);
PROMPT
PROMPT 4. Test the installation:
PROMPT    @@../examples/basic_usage.sql
PROMPT
PROMPT Documentation: https://github.com/pradocabreroalejandro/pltelemetry
PROMPT
PROMPT ================================================================================

-- Reset environment
SET VERIFY ON
SET FEEDBACK ON
SET ECHO OFF
[END OF FILE: install/install.sql]


========================================================================
FILE: install/jobs/plt_cleanup_job.sql
SIZE: 8978 bytes
MODIFIED: ./install/jobs/plt_cleanup_job.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550555 1550555 18446744073709551615 -1
2025-06-23 06:16:29.783973000
========================================================================

-- PLTelemetry Cleanup Job
-- This script creates scheduled jobs for data retention and cleanup
-- 
-- Jobs created:
-- 1. PLT_QUEUE_CLEANUP - Removes processed queue entries older than 7 days
-- 2. PLT_DATA_CLEANUP - Archives/removes old telemetry data based on retention policy

PROMPT Creating PLTelemetry cleanup jobs...

-- Drop existing cleanup jobs if they exist
BEGIN
    FOR rec IN (
        SELECT job_name 
        FROM USER_SCHEDULER_JOBS 
        WHERE job_name IN ('PLT_QUEUE_CLEANUP', 'PLT_DATA_CLEANUP')
    ) LOOP
        DBMS_SCHEDULER.DROP_JOB(
            job_name => rec.job_name,
            force    => TRUE
        );
        DBMS_OUTPUT.PUT_LINE('Dropped existing job: ' || rec.job_name);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        NULL; -- Jobs might not exist
END;
/

-- Create queue cleanup job
BEGIN
    DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'PLT_QUEUE_CLEANUP',
        job_type        => 'PLSQL_BLOCK',
        job_action      => '
DECLARE
    l_deleted_count NUMBER := 0;
    l_retention_days NUMBER := 7;  -- Configurable retention period
    l_cutoff_date TIMESTAMP WITH TIME ZONE;
BEGIN
    l_cutoff_date := SYSTIMESTAMP - INTERVAL l_retention_days DAY;
    
    -- Delete processed queue entries older than retention period
    DELETE FROM plt_queue 
    WHERE processed = ''Y'' 
      AND processed_time < l_cutoff_date;
    
    l_deleted_count := SQL%ROWCOUNT;
    
    -- Log cleanup activity if significant
    IF l_deleted_count > 0 THEN
        INSERT INTO plt_telemetry_errors (
            error_time,
            error_message,
            module_name
        ) VALUES (
            SYSTIMESTAMP,
            ''Queue cleanup: deleted '' || l_deleted_count || '' processed entries older than '' || l_retention_days || '' days'',
            ''PLT_QUEUE_CLEANUP''
        );
    END IF;
    
    COMMIT;
    
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO plt_telemetry_errors (
            error_time,
            error_message,
            error_code,
            module_name,
            error_stack
        ) VALUES (
            SYSTIMESTAMP,
            ''Queue cleanup failed: '' || SUBSTR(SQLERRM, 1, 3000),
            SQLCODE,
            ''PLT_QUEUE_CLEANUP'',
            SUBSTR(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 3000)
        );
        COMMIT;
        RAISE;
END;',
        start_date      => TRUNC(SYSDATE + 1) + INTERVAL '3' HOUR,  -- 3 AM tomorrow
        repeat_interval => 'FREQ=DAILY; BYHOUR=3; BYMINUTE=0',
        enabled         => TRUE,
        auto_drop       => FALSE,
        comments        => 'PLTelemetry queue cleanup - removes processed entries older than 7 days'
    );
    
    DBMS_OUTPUT.PUT_LINE('✓ PLT_QUEUE_CLEANUP job created successfully');
END;
/

-- Create comprehensive data cleanup job
BEGIN
    DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'PLT_DATA_CLEANUP',
        job_type        => 'PLSQL_BLOCK',
        job_action      => '
DECLARE
    l_retention_days NUMBER := 90;  -- Main data retention: 90 days
    l_error_retention_days NUMBER := 30;  -- Error log retention: 30 days
    l_failed_export_retention_days NUMBER := 14;  -- Failed export retention: 14 days
    l_cutoff_date TIMESTAMP WITH TIME ZONE;
    l_error_cutoff TIMESTAMP WITH TIME ZONE;
    l_export_cutoff TIMESTAMP WITH TIME ZONE;
    l_deleted_count NUMBER;
    l_total_deleted NUMBER := 0;
    
BEGIN
    l_cutoff_date := SYSTIMESTAMP - INTERVAL l_retention_days DAY;
    l_error_cutoff := SYSTIMESTAMP - INTERVAL l_error_retention_days DAY;
    l_export_cutoff := SYSTIMESTAMP - INTERVAL l_failed_export_retention_days DAY;
    
    -- 1. Clean up old events (oldest first, as they depend on spans)
    DELETE FROM plt_events 
    WHERE span_id IN (
        SELECT s.span_id 
        FROM plt_spans s 
        JOIN plt_traces t ON s.trace_id = t.trace_id
        WHERE t.start_time < l_cutoff_date
    );
    l_deleted_count := SQL%ROWCOUNT;
    l_total_deleted := l_total_deleted + l_deleted_count;
    
    -- 2. Clean up old metrics
    DELETE FROM plt_metrics 
    WHERE timestamp < l_cutoff_date;
    l_deleted_count := SQL%ROWCOUNT;
    l_total_deleted := l_total_deleted + l_deleted_count;
    
    -- 3. Clean up old spans
    DELETE FROM plt_spans 
    WHERE trace_id IN (
        SELECT trace_id 
        FROM plt_traces 
        WHERE start_time < l_cutoff_date
    );
    l_deleted_count := SQL%ROWCOUNT;
    l_total_deleted := l_total_deleted + l_deleted_count;
    
    -- 4. Clean up old traces
    DELETE FROM plt_traces 
    WHERE start_time < l_cutoff_date;
    l_deleted_count := SQL%ROWCOUNT;
    l_total_deleted := l_total_deleted + l_deleted_count;
    
    -- 5. Clean up old failed exports
    DELETE FROM plt_failed_exports 
    WHERE export_time < l_export_cutoff;
    l_deleted_count := SQL%ROWCOUNT;
    l_total_deleted := l_total_deleted + l_deleted_count;
    
    -- 6. Clean up old error logs
    DELETE FROM plt_telemetry_errors 
    WHERE error_time < l_error_cutoff
      AND module_name != ''PLT_DATA_CLEANUP'';  -- Keep cleanup logs longer
    l_deleted_count := SQL%ROWCOUNT;
    l_total_deleted := l_total_deleted + l_deleted_count;
    
    -- Log cleanup summary
    INSERT INTO plt_telemetry_errors (
        error_time,
        error_message,
        module_name
    ) VALUES (
        SYSTIMESTAMP,
        ''Data cleanup completed: deleted '' || l_total_deleted || '' total records. '' ||
        ''Retention: data='' || l_retention_days || ''d, errors='' || l_error_retention_days || ''d, exports='' || l_failed_export_retention_days || ''d'',
        ''PLT_DATA_CLEANUP''
    );
    
    COMMIT;
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        INSERT INTO plt_telemetry_errors (
            error_time,
            error_message,
            error_code,
            module_name,
            error_stack
        ) VALUES (
            SYSTIMESTAMP,
            ''Data cleanup failed: '' || SUBSTR(SQLERRM, 1, 3000),
            SQLCODE,
            ''PLT_DATA_CLEANUP'',
            SUBSTR(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 3000)
        );
        COMMIT;
        RAISE;
END;',
        start_date      => TRUNC(SYSDATE + 1) + INTERVAL '2' HOUR,  -- 2 AM tomorrow
        repeat_interval => 'FREQ=DAILY; BYHOUR=2; BYMINUTE=0',
        enabled         => TRUE,
        auto_drop       => FALSE,
        comments        => 'PLTelemetry data cleanup - removes old telemetry data based on retention policy'
    );
    
    DBMS_OUTPUT.PUT_LINE('✓ PLT_DATA_CLEANUP job created successfully');
END;
/

-- Verify jobs creation
DECLARE
    l_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO l_count
    FROM USER_SCHEDULER_JOBS
    WHERE job_name IN ('PLT_QUEUE_CLEANUP', 'PLT_DATA_CLEANUP')
      AND enabled = 'TRUE';
    
    IF l_count != 2 THEN
        DBMS_OUTPUT.PUT_LINE('⚠ Warning: Expected 2 cleanup jobs, found ' || l_count || ' enabled');
    ELSE
        DBMS_OUTPUT.PUT_LINE('✓ Both cleanup jobs created and enabled successfully');
    END IF;
    
    -- Show next run times
    FOR rec IN (
        SELECT job_name, next_run_date
        FROM USER_SCHEDULER_JOBS
        WHERE job_name IN ('PLT_QUEUE_CLEANUP', 'PLT_DATA_CLEANUP')
        ORDER BY job_name
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('  ' || rec.job_name || ' next run: ' || 
                           TO_CHAR(rec.next_run_date, 'YYYY-MM-DD HH24:MI:SS'));
    END LOOP;
END;
/

PROMPT
PROMPT ================================================================================
PROMPT PLTelemetry Cleanup Jobs Configuration
PROMPT ================================================================================
PROMPT
PROMPT Jobs Created:
PROMPT ✓ PLT_QUEUE_CLEANUP    - Daily at 3:00 AM (removes processed queue entries > 7 days)
PROMPT ✓ PLT_DATA_CLEANUP     - Daily at 2:00 AM (removes telemetry data > 90 days)
PROMPT
PROMPT Default Retention Policies:
PROMPT • Queue entries:     7 days (processed only)
PROMPT • Telemetry data:   90 days (traces, spans, events, metrics)
PROMPT • Error logs:       30 days
PROMPT • Failed exports:   14 days
PROMPT
PROMPT To customize retention periods, edit the job actions:
PROMPT   EXEC DBMS_SCHEDULER.SET_ATTRIBUTE(''PLT_DATA_CLEANUP'', ''job_action'', ''...'');
PROMPT
PROMPT To monitor cleanup activity:
PROMPT   SELECT * FROM plt_telemetry_errors 
PROMPT   WHERE module_name IN (''PLT_QUEUE_CLEANUP'', ''PLT_DATA_CLEANUP'')
PROMPT   ORDER BY error_time DESC;
PROMPT
PROMPT To disable cleanup jobs:
PROMPT   EXEC DBMS_SCHEDULER.DISABLE(''PLT_QUEUE_CLEANUP'');
PROMPT   EXEC DBMS_SCHEDULER.DISABLE(''PLT_DATA_CLEANUP'');
PROMPT
PROMPT ================================================================================
[END OF FILE: install/jobs/plt_cleanup_job.sql]


========================================================================
FILE: install/jobs/plt_queue_processor.sql
SIZE: 5239 bytes
MODIFIED: ./install/jobs/plt_queue_processor.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550553 1550553 18446744073709551615 -1
2025-06-23 06:16:29.788104400
========================================================================

-- PLTelemetry Queue Processor Job
-- This script creates a scheduled job to process the async telemetry queue
-- 
-- The job runs every minute and processes pending queue entries
-- Adjust the frequency and batch size based on your requirements

PROMPT Creating PLTelemetry queue processor job...

-- Drop existing job if it exists
BEGIN
    DBMS_SCHEDULER.DROP_JOB(
        job_name => 'PLT_QUEUE_PROCESSOR',
        force    => TRUE
    );
    DBMS_OUTPUT.PUT_LINE('Dropped existing PLT_QUEUE_PROCESSOR job');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -27475 THEN  -- Job does not exist
            RAISE;
        END IF;
END;
/

-- Create the queue processor job
BEGIN
    DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'PLT_QUEUE_PROCESSOR',
        job_type        => 'PLSQL_BLOCK',
        job_action      => '
DECLARE
    l_processed NUMBER := 0;
    l_errors NUMBER := 0;
    l_start_time TIMESTAMP;
BEGIN
    l_start_time := SYSTIMESTAMP;
    
    -- Process queue with error handling
    BEGIN
        PLTelemetry.process_queue(100);  -- Process up to 100 entries per run
    EXCEPTION
        WHEN OTHERS THEN
            -- Log job execution error
            INSERT INTO plt_telemetry_errors (
                error_time, 
                error_message, 
                error_code,
                module_name,
                error_stack
            ) VALUES (
                SYSTIMESTAMP,
                ''Queue processor job failed: '' || SUBSTR(SQLERRM, 1, 3000),
                SQLCODE,
                ''PLT_QUEUE_PROCESSOR'',
                SUBSTR(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 3000)
            );
            COMMIT;
    END;
    
    -- Optional: Log successful execution periodically
    -- Uncomment if you want to track job execution
    /*
    IF EXTRACT(MINUTE FROM SYSTIMESTAMP) = 0 THEN  -- Log once per hour
        INSERT INTO plt_telemetry_errors (
            error_time,
            error_message,
            module_name
        ) VALUES (
            SYSTIMESTAMP,
            ''Queue processor executed successfully'',
            ''PLT_QUEUE_PROCESSOR''
        );
        COMMIT;
    END IF;
    */
END;',
        start_date      => SYSTIMESTAMP + INTERVAL '1' MINUTE,
        repeat_interval => 'FREQ=MINUTELY; INTERVAL=1',
        enabled         => TRUE,
        auto_drop       => FALSE,
        comments        => 'PLTelemetry async queue processor - runs every minute'
    );
    
    DBMS_OUTPUT.PUT_LINE('✓ PLT_QUEUE_PROCESSOR job created successfully');
    DBMS_OUTPUT.PUT_LINE('  Frequency: Every 1 minute');
    DBMS_OUTPUT.PUT_LINE('  Batch size: 100 entries per run');
    DBMS_OUTPUT.PUT_LINE('  Start time: ' || TO_CHAR(SYSTIMESTAMP + INTERVAL '1' MINUTE, 'YYYY-MM-DD HH24:MI:SS'));
END;
/

-- Create a more frequent processor for high-volume environments (optional)
-- Uncomment if you need higher throughput
/*
BEGIN
    DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'PLT_QUEUE_PROCESSOR_FAST',
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN PLTelemetry.process_queue(50); END;',
        start_date      => SYSTIMESTAMP + INTERVAL '30' SECOND,
        repeat_interval => 'FREQ=SECONDLY; INTERVAL=30',
        enabled         => FALSE,  -- Disabled by default
        auto_drop       => FALSE,
        comments        => 'PLTelemetry high-frequency queue processor - 30 seconds'
    );
    
    DBMS_OUTPUT.PUT_LINE('✓ PLT_QUEUE_PROCESSOR_FAST job created (disabled)');
    DBMS_OUTPUT.PUT_LINE('  Enable with: DBMS_SCHEDULER.ENABLE(''PLT_QUEUE_PROCESSOR_FAST'')');
END;
/
*/

-- Verify job creation
DECLARE
    l_count NUMBER;
    l_enabled VARCHAR2(10);
    l_next_run TIMESTAMP WITH TIME ZONE;
BEGIN
    SELECT COUNT(*), MAX(enabled), MAX(next_run_date)
    INTO l_count, l_enabled, l_next_run
    FROM USER_SCHEDULER_JOBS
    WHERE job_name = 'PLT_QUEUE_PROCESSOR';
    
    IF l_count = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Failed to create PLT_QUEUE_PROCESSOR job');
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Job Status:');
    DBMS_OUTPUT.PUT_LINE('  Enabled: ' || l_enabled);
    DBMS_OUTPUT.PUT_LINE('  Next run: ' || TO_CHAR(l_next_run, 'YYYY-MM-DD HH24:MI:SS TZH:TZM'));
END;
/

PROMPT
PROMPT Queue Processor Job Configuration:
PROMPT 
PROMPT To monitor the job:
PROMPT   SELECT job_name, enabled, next_run_date, run_count, failure_count
PROMPT   FROM USER_SCHEDULER_JOBS 
PROMPT   WHERE job_name = 'PLT_QUEUE_PROCESSOR';
PROMPT
PROMPT To view job run history:
PROMPT   SELECT log_date, status, error#, additional_info
PROMPT   FROM USER_SCHEDULER_JOB_RUN_DETAILS 
PROMPT   WHERE job_name = 'PLT_QUEUE_PROCESSOR'
PROMPT   ORDER BY log_date DESC;
PROMPT
PROMPT To manually process the queue:
PROMPT   BEGIN PLTelemetry.process_queue(100); END;
PROMPT
PROMPT To disable the job:
PROMPT   EXEC DBMS_SCHEDULER.DISABLE('PLT_QUEUE_PROCESSOR');
PROMPT
PROMPT To adjust the frequency:
PROMPT   EXEC DBMS_SCHEDULER.SET_ATTRIBUTE('PLT_QUEUE_PROCESSOR', 'repeat_interval', 'FREQ=MINUTELY; INTERVAL=5');
PROMPT
[END OF FILE: install/jobs/plt_queue_processor.sql]


========================================================================
FILE: install/tables/plt_indexes.sql
SIZE: 3893 bytes
MODIFIED: ./install/tables/plt_indexes.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550551 1550551 18446744073709551615 -1
2025-06-23 06:16:29.790136400
========================================================================

-- PLTelemetry Performance Indexes
-- This script creates indexes for optimal PLTelemetry performance
-- 
-- Indexes created for:
-- - Query performance on common access patterns
-- - Foreign key performance
-- - Queue processing efficiency
-- - Error analysis and monitoring

PROMPT Creating PLTelemetry performance indexes...

-- Traces indexes
CREATE INDEX idx_plt_traces_start_time ON plt_traces(start_time);
CREATE INDEX idx_plt_traces_service ON plt_traces(service_name, start_time);
CREATE INDEX idx_plt_traces_operation ON plt_traces(root_operation, start_time);

-- Spans indexes
CREATE INDEX idx_plt_spans_trace_id ON plt_spans(trace_id, start_time);
CREATE INDEX idx_plt_spans_parent ON plt_spans(parent_span_id, start_time);
CREATE INDEX idx_plt_spans_operation ON plt_spans(operation_name, start_time);
CREATE INDEX idx_plt_spans_status ON plt_spans(status, start_time);
CREATE INDEX idx_plt_spans_duration ON plt_spans(duration_ms) WHERE duration_ms IS NOT NULL;

-- Events indexes
CREATE INDEX idx_plt_events_span_id ON plt_events(span_id, event_time);
CREATE INDEX idx_plt_events_name ON plt_events(event_name, event_time);
CREATE INDEX idx_plt_events_time ON plt_events(event_time);

-- Metrics indexes
CREATE INDEX idx_plt_metrics_name ON plt_metrics(metric_name, timestamp);
CREATE INDEX idx_plt_metrics_trace ON plt_metrics(trace_id, timestamp);
CREATE INDEX idx_plt_metrics_span ON plt_metrics(span_id, timestamp);
CREATE INDEX idx_plt_metrics_time ON plt_metrics(timestamp);
CREATE INDEX idx_plt_metrics_value ON plt_metrics(metric_name, metric_value, timestamp);

-- Queue indexes (for async processing performance)
CREATE INDEX idx_plt_queue_processed ON plt_queue(processed, process_attempts, created_at);
CREATE INDEX idx_plt_queue_created ON plt_queue(created_at);
CREATE INDEX idx_plt_queue_processed_time ON plt_queue(processed_time);
CREATE INDEX idx_plt_queue_attempts ON plt_queue(process_attempts, last_attempt_time);

-- Failed exports indexes
CREATE INDEX idx_plt_failed_exports_time ON plt_failed_exports(export_time);
CREATE INDEX idx_plt_failed_exports_status ON plt_failed_exports(http_status, export_time);
CREATE INDEX idx_plt_failed_exports_retry ON plt_failed_exports(retry_count, last_retry);

-- Error logging indexes
CREATE INDEX idx_plt_telemetry_errors_time ON plt_telemetry_errors(error_time);
CREATE INDEX idx_plt_telemetry_errors_trace ON plt_telemetry_errors(trace_id);
CREATE INDEX idx_plt_telemetry_errors_span ON plt_telemetry_errors(span_id);
CREATE INDEX idx_plt_telemetry_errors_module ON plt_telemetry_errors(module_name, error_time);
CREATE INDEX idx_plt_telemetry_errors_code ON plt_telemetry_errors(error_code, error_time);

-- Composite indexes for common query patterns
CREATE INDEX idx_plt_trace_span_lookup ON plt_spans(trace_id, span_id);
CREATE INDEX idx_plt_active_spans ON plt_spans(trace_id, end_time) WHERE end_time IS NULL;
CREATE INDEX idx_plt_error_spans ON plt_spans(trace_id, status) WHERE status = 'ERROR';

-- Function-based indexes for common operations
CREATE INDEX idx_plt_queue_failed ON plt_queue(process_attempts) WHERE process_attempts >= 3;
CREATE INDEX idx_plt_queue_pending ON plt_queue(created_at) WHERE processed = 'N';

-- Bitmap indexes for low-cardinality columns (if appropriate for your data volume)
-- Uncomment these if you have Oracle Enterprise Edition and large data volumes
-- CREATE BITMAP INDEX idx_plt_queue_processed_bmp ON plt_queue(processed);
-- CREATE BITMAP INDEX idx_plt_spans_status_bmp ON plt_spans(status);

PROMPT PLTelemetry indexes created successfully.
PROMPT
PROMPT Index Summary:
PROMPT - 25+ indexes created for optimal query performance
PROMPT - Queue processing optimized for async operations
PROMPT - Time-based indexes for efficient data retention
PROMPT - Error analysis and monitoring support
[END OF FILE: install/tables/plt_indexes.sql]


========================================================================
FILE: install/tables/plt_tables.sql
SIZE: 6537 bytes
MODIFIED: ./install/tables/plt_tables.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550550 1550550 18446744073709551615 -1
2025-06-23 06:16:29.790136400
========================================================================

-- PLTelemetry Database Tables
-- This script creates all required tables for PLTelemetry
-- 
-- Tables created:
-- - plt_traces: Main trace records
-- - plt_spans: Span records within traces  
-- - plt_events: Events within spans
-- - plt_metrics: Metric records
-- - plt_queue: Async processing queue
-- - plt_failed_exports: Failed export attempts
-- - plt_telemetry_errors: Error logging

PROMPT Creating PLTelemetry tables...

-- Drop existing tables if they exist (for reinstall)
DECLARE
    l_sql VARCHAR2(1000);
    l_count NUMBER;
BEGIN
    FOR rec IN (
        SELECT table_name 
        FROM user_tables 
        WHERE table_name IN ('PLT_TRACES', 'PLT_SPANS', 'PLT_EVENTS', 'PLT_METRICS', 
                            'PLT_FAILED_EXPORTS', 'PLT_QUEUE', 'PLT_TELEMETRY_ERRORS')
    ) LOOP
        l_sql := 'DROP TABLE ' || rec.table_name || ' CASCADE CONSTRAINTS';
        EXECUTE IMMEDIATE l_sql;
        DBMS_OUTPUT.PUT_LINE('Dropped existing table: ' || rec.table_name);
    END LOOP;
END;
/

-- Main traces table
CREATE TABLE plt_traces (
    trace_id VARCHAR2(32) PRIMARY KEY,
    root_operation VARCHAR2(255) NOT NULL,
    start_time TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    end_time TIMESTAMP WITH TIME ZONE,
    service_name VARCHAR2(100) DEFAULT 'oracle-plsql',
    service_instance VARCHAR2(255)
);

COMMENT ON TABLE plt_traces IS 'OpenTelemetry traces - root operations';
COMMENT ON COLUMN plt_traces.trace_id IS '128-bit trace ID (32 hex chars)';
COMMENT ON COLUMN plt_traces.root_operation IS 'Name of the root operation';
COMMENT ON COLUMN plt_traces.service_name IS 'Service identifier';
COMMENT ON COLUMN plt_traces.service_instance IS 'Service instance identifier';

-- Spans table
CREATE TABLE plt_spans (
    span_id VARCHAR2(16) PRIMARY KEY,
    trace_id VARCHAR2(32) NOT NULL,
    parent_span_id VARCHAR2(16),
    operation_name VARCHAR2(255) NOT NULL,
    start_time TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    end_time TIMESTAMP WITH TIME ZONE,
    duration_ms NUMBER,
    status VARCHAR2(50) DEFAULT 'RUNNING',
    CONSTRAINT fk_spans_trace FOREIGN KEY (trace_id) REFERENCES plt_traces(trace_id),
    CONSTRAINT fk_spans_parent FOREIGN KEY (parent_span_id) REFERENCES plt_spans(span_id),
    CONSTRAINT chk_spans_status CHECK (status IN ('RUNNING', 'OK', 'ERROR', 'CANCELLED'))
);

COMMENT ON TABLE plt_spans IS 'OpenTelemetry spans - individual operations within traces';
COMMENT ON COLUMN plt_spans.span_id IS '64-bit span ID (16 hex chars)';
COMMENT ON COLUMN plt_spans.parent_span_id IS 'Parent span for nested operations';
COMMENT ON COLUMN plt_spans.duration_ms IS 'Span duration in milliseconds';

-- Events table
CREATE TABLE plt_events (
    event_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    span_id VARCHAR2(16) NOT NULL,
    event_name VARCHAR2(255) NOT NULL,
    event_time TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    attributes VARCHAR2(4000),
    CONSTRAINT fk_events_span FOREIGN KEY (span_id) REFERENCES plt_spans(span_id)
);

COMMENT ON TABLE plt_events IS 'Events within spans - point-in-time occurrences';
COMMENT ON COLUMN plt_events.attributes IS 'JSON attributes for the event';

-- Metrics table
CREATE TABLE plt_metrics (
    metric_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    metric_name VARCHAR2(255) NOT NULL,
    metric_value NUMBER NOT NULL,
    metric_unit VARCHAR2(50),
    trace_id VARCHAR2(32),
    span_id VARCHAR2(16),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    attributes VARCHAR2(4000),
    CONSTRAINT fk_metrics_trace FOREIGN KEY (trace_id) REFERENCES plt_traces(trace_id),
    CONSTRAINT fk_metrics_span FOREIGN KEY (span_id) REFERENCES plt_spans(span_id)
);

COMMENT ON TABLE plt_metrics IS 'Application metrics with telemetry context';
COMMENT ON COLUMN plt_metrics.metric_unit IS 'Unit of measurement (ms, bytes, requests, etc.)';
COMMENT ON COLUMN plt_metrics.attributes IS 'JSON attributes for the metric';

-- Failed exports table
CREATE TABLE plt_failed_exports (
    export_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    export_time TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    http_status NUMBER,
    payload VARCHAR2(4000),
    error_message VARCHAR2(4000),
    retry_count NUMBER DEFAULT 0,
    last_retry TIMESTAMP WITH TIME ZONE
);

COMMENT ON TABLE plt_failed_exports IS 'Failed telemetry export attempts for debugging';
COMMENT ON COLUMN plt_failed_exports.payload IS 'Truncated payload that failed to export';

-- Async processing queue
CREATE TABLE plt_queue (
    queue_id NUMBER GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1 
        MAXVALUE 9999999999999999999999999999 
        MINVALUE 1 
        NOCYCLE 
        CACHE 20 
        NOORDER 
        NOKEEP
    ) NOT NULL,
    payload VARCHAR2(4000) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    processed CHAR(1) DEFAULT 'N' NOT NULL,
    process_attempts NUMBER DEFAULT 0 NOT NULL,
    processed_time TIMESTAMP WITH TIME ZONE,
    last_error VARCHAR2(4000),
    last_attempt_time TIMESTAMP WITH TIME ZONE,
    CONSTRAINT pk_plt_queue PRIMARY KEY (queue_id),
    CONSTRAINT chk_plt_queue_processed CHECK (processed IN ('Y', 'N'))
);

COMMENT ON TABLE plt_queue IS 'Async processing queue for telemetry export';
COMMENT ON COLUMN plt_queue.payload IS 'JSON payload to be exported';
COMMENT ON COLUMN plt_queue.process_attempts IS 'Number of processing attempts (max 3)';

-- Error logging table
CREATE TABLE plt_telemetry_errors (
    error_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    error_time TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    error_message VARCHAR2(4000),
    error_stack VARCHAR2(4000),
    error_code NUMBER,
    module_name VARCHAR2(100),
    trace_id VARCHAR2(32),
    span_id VARCHAR2(16),
    session_user VARCHAR2(128) DEFAULT USER,
    os_user VARCHAR2(128) DEFAULT SYS_CONTEXT('USERENV', 'OS_USER'),
    host VARCHAR2(256) DEFAULT SYS_CONTEXT('USERENV', 'HOST'),
    ip_address VARCHAR2(45) DEFAULT SYS_CONTEXT('USERENV', 'IP_ADDRESS')
);

COMMENT ON TABLE plt_telemetry_errors IS 'Internal error logging for PLTelemetry operations';
COMMENT ON COLUMN plt_telemetry_errors.module_name IS 'PLTelemetry module where error occurred';

PROMPT PLTelemetry tables created successfully.
[END OF FILE: install/tables/plt_tables.sql]


========================================================================
FILE: tests/basic_functionality.sql
SIZE: 23294 bytes
MODIFIED: ./tests/basic_functionality.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550549 1550549 18446744073709551615 -1
2025-06-23 06:16:29.799154900
========================================================================

-- PLTelemetry Basic Functionality Tests
-- This file contains unit tests for core PLTelemetry functionality
-- Run these tests after installing PLTelemetry to verify it works correctly

PROMPT ================================================================================
PROMPT PLTelemetry Basic Functionality Tests
PROMPT ================================================================================

-- Test configuration
SET SERVEROUTPUT ON
SET FEEDBACK OFF

-- Global test counters
DECLARE
    g_test_count NUMBER := 0;
    g_pass_count NUMBER := 0;
    g_fail_count NUMBER := 0;
BEGIN
    NULL;
END;
/

-- Test utility procedures
CREATE OR REPLACE PACKAGE plt_test_utils AS
    g_test_count NUMBER := 0;
    g_pass_count NUMBER := 0;
    g_fail_count NUMBER := 0;
    
    PROCEDURE start_test_suite(p_suite_name VARCHAR2);
    PROCEDURE assert_equals(p_description VARCHAR2, p_expected VARCHAR2, p_actual VARCHAR2);
    PROCEDURE assert_not_null(p_description VARCHAR2, p_value VARCHAR2);
    PROCEDURE assert_null(p_description VARCHAR2, p_value VARCHAR2);
    PROCEDURE assert_true(p_description VARCHAR2, p_condition BOOLEAN);
    PROCEDURE end_test_suite;
    PROCEDURE cleanup_test_data;
END;
/

CREATE OR REPLACE PACKAGE BODY plt_test_utils AS
    
    PROCEDURE start_test_suite(p_suite_name VARCHAR2) IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('=== ' || p_suite_name || ' ===');
        g_test_count := 0;
        g_pass_count := 0;
        g_fail_count := 0;
    END;
    
    PROCEDURE assert_equals(p_description VARCHAR2, p_expected VARCHAR2, p_actual VARCHAR2) IS
    BEGIN
        g_test_count := g_test_count + 1;
        IF NVL(p_expected, 'NULL') = NVL(p_actual, 'NULL') THEN
            g_pass_count := g_pass_count + 1;
            DBMS_OUTPUT.PUT_LINE('✓ PASS: ' || p_description);
        ELSE
            g_fail_count := g_fail_count + 1;
            DBMS_OUTPUT.PUT_LINE('✗ FAIL: ' || p_description);
            DBMS_OUTPUT.PUT_LINE('  Expected: ' || NVL(p_expected, 'NULL'));
            DBMS_OUTPUT.PUT_LINE('  Actual: ' || NVL(p_actual, 'NULL'));
        END IF;
    END;
    
    PROCEDURE assert_not_null(p_description VARCHAR2, p_value VARCHAR2) IS
    BEGIN
        g_test_count := g_test_count + 1;
        IF p_value IS NOT NULL THEN
            g_pass_count := g_pass_count + 1;
            DBMS_OUTPUT.PUT_LINE('✓ PASS: ' || p_description);
        ELSE
            g_fail_count := g_fail_count + 1;
            DBMS_OUTPUT.PUT_LINE('✗ FAIL: ' || p_description || ' (value is NULL)');
        END IF;
    END;
    
    PROCEDURE assert_null(p_description VARCHAR2, p_value VARCHAR2) IS
    BEGIN
        g_test_count := g_test_count + 1;
        IF p_value IS NULL THEN
            g_pass_count := g_pass_count + 1;
            DBMS_OUTPUT.PUT_LINE('✓ PASS: ' || p_description);
        ELSE
            g_fail_count := g_fail_count + 1;
            DBMS_OUTPUT.PUT_LINE('✗ FAIL: ' || p_description || ' (value is not NULL: ' || p_value || ')');
        END IF;
    END;
    
    PROCEDURE assert_true(p_description VARCHAR2, p_condition BOOLEAN) IS
    BEGIN
        g_test_count := g_test_count + 1;
        IF p_condition THEN
            g_pass_count := g_pass_count + 1;
            DBMS_OUTPUT.PUT_LINE('✓ PASS: ' || p_description);
        ELSE
            g_fail_count := g_fail_count + 1;
            DBMS_OUTPUT.PUT_LINE('✗ FAIL: ' || p_description);
        END IF;
    END;
    
    PROCEDURE end_test_suite IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('Results: ' || g_pass_count || ' passed, ' || g_fail_count || ' failed (' || g_test_count || ' total)');
        IF g_fail_count > 0 THEN
            DBMS_OUTPUT.PUT_LINE('❌ SUITE FAILED');
        ELSE
            DBMS_OUTPUT.PUT_LINE('✅ SUITE PASSED');
        END IF;
    END;
    
    PROCEDURE cleanup_test_data IS
    BEGIN
        -- Clean up test data
        DELETE FROM plt_traces WHERE root_operation LIKE 'test_%';
        DELETE FROM plt_spans WHERE operation_name LIKE 'test_%';
        DELETE FROM plt_events WHERE event_name LIKE 'test_%';
        DELETE FROM plt_metrics WHERE metric_name LIKE 'test_%';
        DELETE FROM plt_queue WHERE payload LIKE '%test_%';
        DELETE FROM plt_telemetry_errors WHERE module_name LIKE 'test_%';
        COMMIT;
    END;
END;
/

-- Test 1: Basic Configuration
-- ============================================================================
BEGIN
    plt_test_utils.start_test_suite('Configuration Tests');
    
    -- Test setting and getting backend URL
    PLTelemetry.set_backend_url('http://test.example.com/api');
    plt_test_utils.assert_equals(
        'Backend URL setting/getting',
        'http://test.example.com/api',
        PLTelemetry.get_backend_url()
    );
    
    -- Test autocommit setting
    PLTelemetry.set_autocommit(TRUE);
    plt_test_utils.assert_true(
        'Autocommit setting to TRUE',
        PLTelemetry.get_autocommit()
    );
    
    PLTelemetry.set_autocommit(FALSE);
    plt_test_utils.assert_true(
        'Autocommit setting to FALSE',
        NOT PLTelemetry.get_autocommit()
    );
    
    -- Test async mode setting
    PLTelemetry.set_async_mode(TRUE);
    PLTelemetry.set_async_mode(FALSE);  -- No direct getter, but should not error
    
    plt_test_utils.end_test_suite();
END;
/

-- Test 2: Trace Management
-- ============================================================================
BEGIN
    plt_test_utils.start_test_suite('Trace Management Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_trace_count NUMBER;
    BEGIN
        -- Test trace creation
        l_trace_id := PLTelemetry.start_trace('test_trace_creation');
        
        plt_test_utils.assert_not_null('Trace ID generation', l_trace_id);
        plt_test_utils.assert_equals('Trace ID length', '32', TO_CHAR(LENGTH(l_trace_id)));
        plt_test_utils.assert_equals('Current trace ID', l_trace_id, PLTelemetry.get_current_trace_id());
        
        -- Verify trace was inserted
        SELECT COUNT(*) INTO l_trace_count 
        FROM plt_traces 
        WHERE trace_id = l_trace_id;
        
        plt_test_utils.assert_equals('Trace inserted in database', '1', TO_CHAR(l_trace_count));
        
        -- Test trace ending
        PLTelemetry.end_trace(l_trace_id);
        
        -- Verify trace was ended
        SELECT COUNT(*) INTO l_trace_count 
        FROM plt_traces 
        WHERE trace_id = l_trace_id AND end_time IS NOT NULL;
        
        plt_test_utils.assert_equals('Trace ended in database', '1', TO_CHAR(l_trace_count));
    END;
    
    plt_test_utils.end_test_suite();
END;
/

-- Test 3: Span Management
-- ============================================================================
BEGIN
    plt_test_utils.start_test_suite('Span Management Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id VARCHAR2(16);
        l_span_count NUMBER;
        l_attrs PLTelemetry.t_attributes;
    BEGIN
        -- Create trace for span tests
        l_trace_id := PLTelemetry.start_trace('test_span_management');
        
        -- Test span creation
        l_span_id := PLTelemetry.start_span('test_span_creation');
        
        plt_test_utils.assert_not_null('Span ID generation', l_span_id);
        plt_test_utils.assert_equals('Span ID length', '16', TO_CHAR(LENGTH(l_span_id)));
        plt_test_utils.assert_equals('Current span ID', l_span_id, PLTelemetry.get_current_span_id());
        
        -- Verify span was inserted
        SELECT COUNT(*) INTO l_span_count 
        FROM plt_spans 
        WHERE span_id = l_span_id;
        
        plt_test_utils.assert_equals('Span inserted in database', '1', TO_CHAR(l_span_count));
        
        -- Test span ending with attributes
        l_attrs(1) := PLTelemetry.add_attribute('test.attribute', 'test_value');
        PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
        
        -- Verify span was ended
        SELECT COUNT(*) INTO l_span_count 
        FROM plt_spans 
        WHERE span_id = l_span_id AND end_time IS NOT NULL AND status = 'OK';
        
        plt_test_utils.assert_equals('Span ended with OK status', '1', TO_CHAR(l_span_count));
        
        PLTelemetry.end_trace(l_trace_id);
    END;
    
    plt_test_utils.end_test_suite();
END;
/

-- Test 4: Nested Spans
-- ============================================================================
BEGIN
    plt_test_utils.start_test_suite('Nested Spans Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_parent_span VARCHAR2(16);
        l_child_span VARCHAR2(16);
        l_relationship_count NUMBER;
    BEGIN
        l_trace_id := PLTelemetry.start_trace('test_nested_spans');
        
        -- Create parent span
        l_parent_span := PLTelemetry.start_span('test_parent_span');
        
        -- Create child span
        l_child_span := PLTelemetry.start_span('test_child_span', l_parent_span);
        
        -- Verify parent-child relationship
        SELECT COUNT(*) INTO l_relationship_count
        FROM plt_spans
        WHERE span_id = l_child_span 
          AND parent_span_id = l_parent_span
          AND trace_id = l_trace_id;
        
        plt_test_utils.assert_equals('Parent-child span relationship', '1', TO_CHAR(l_relationship_count));
        
        -- End spans in correct order
        PLTelemetry.end_span(l_child_span, 'OK');
        PLTelemetry.end_span(l_parent_span, 'OK');
        PLTelemetry.end_trace(l_trace_id);
    END;
    
    plt_test_utils.end_test_suite();
END;
/

-- Test 5: Events
-- ============================================================================
BEGIN
    plt_test_utils.start_test_suite('Events Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id VARCHAR2(16);
        l_attrs PLTelemetry.t_attributes;
        l_event_count NUMBER;
    BEGIN
        l_trace_id := PLTelemetry.start_trace('test_events');
        l_span_id := PLTelemetry.start_span('test_event_span');
        
        -- Add event without attributes
        PLTelemetry.add_event(l_span_id, 'test_simple_event');
        
        -- Add event with attributes
        l_attrs(1) := PLTelemetry.add_attribute('event.type', 'test');
        l_attrs(2) := PLTelemetry.add_attribute('event.value', '42');
        PLTelemetry.add_event(l_span_id, 'test_event_with_attributes', l_attrs);
        
        -- Verify events were created
        SELECT COUNT(*) INTO l_event_count
        FROM plt_events
        WHERE span_id = l_span_id;
        
        plt_test_utils.assert_equals('Events created for span', '2', TO_CHAR(l_event_count));
        
        -- Verify specific event names
        SELECT COUNT(*) INTO l_event_count
        FROM plt_events
        WHERE span_id = l_span_id AND event_name = 'test_simple_event';
        
        plt_test_utils.assert_equals('Simple event created', '1', TO_CHAR(l_event_count));
        
        SELECT COUNT(*) INTO l_event_count
        FROM plt_events
        WHERE span_id = l_span_id AND event_name = 'test_event_with_attributes';
        
        plt_test_utils.assert_equals('Event with attributes created', '1', TO_CHAR(l_event_count));
        
        PLTelemetry.end_span(l_span_id, 'OK');
        PLTelemetry.end_trace(l_trace_id);
    END;
    
    plt_test_utils.end_test_suite();
END;
/

-- Test 6: Metrics
-- ============================================================================
BEGIN
    plt_test_utils.start_test_suite('Metrics Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id VARCHAR2(16);
        l_attrs PLTelemetry.t_attributes;
        l_metric_count NUMBER;
        l_metric_value NUMBER;
    BEGIN
        l_trace_id := PLTelemetry.start_trace('test_metrics');
        l_span_id := PLTelemetry.start_span('test_metric_span');
        
        -- Log various types of metrics
        l_attrs(1) := PLTelemetry.add_attribute('test.context', 'metric_test');
        
        PLTelemetry.log_metric('test_counter', 1, 'count', l_attrs);
        PLTelemetry.log_metric('test_duration', 123.45, 'milliseconds', l_attrs);
        PLTelemetry.log_metric('test_percentage', 85.5, 'percent', l_attrs);
        
        -- Verify metrics were created
        SELECT COUNT(*) INTO l_metric_count
        FROM plt_metrics
        WHERE metric_name LIKE 'test_%' AND trace_id = l_trace_id;
        
        plt_test_utils.assert_equals('Metrics created', '3', TO_CHAR(l_metric_count));
        
        -- Verify specific metric value
        SELECT metric_value INTO l_metric_value
        FROM plt_metrics
        WHERE metric_name = 'test_duration' AND trace_id = l_trace_id;
        
        plt_test_utils.assert_equals('Metric value stored correctly', '123.45', TO_CHAR(l_metric_value));
        
        PLTelemetry.end_span(l_span_id, 'OK');
        PLTelemetry.end_trace(l_trace_id);
    END;
    
    plt_test_utils.end_test_suite();
END;
/

-- Test 7: Attribute Handling
-- ============================================================================
BEGIN
    plt_test_utils.start_test_suite('Attribute Handling Tests');
    
    DECLARE
        l_attr_result VARCHAR2(4000);
        l_attrs PLTelemetry.t_attributes;
        l_json_result VARCHAR2(4000);
    BEGIN
        -- Test basic attribute creation
        l_attr_result := PLTelemetry.add_attribute('test.key', 'test_value');
        plt_test_utils.assert_equals('Basic attribute format', 'test.key=test_value', l_attr_result);
        
        -- Test attribute with special characters
        l_attr_result := PLTelemetry.add_attribute('test.special', 'value with = and \ chars');
        plt_test_utils.assert_not_null('Attribute with special characters', l_attr_result);
        
        -- Test attributes to JSON conversion
        l_attrs(1) := PLTelemetry.add_attribute('key1', 'value1');
        l_attrs(2) := PLTelemetry.add_attribute('key2', 'value2');
        l_attrs(3) := PLTelemetry.add_attribute('number.key', '42');
        
        l_json_result := PLTelemetry.attributes_to_json(l_attrs);
        
        plt_test_utils.assert_not_null('Attributes to JSON conversion', l_json_result);
        plt_test_utils.assert_true('JSON contains key1', INSTR(l_json_result, 'key1') > 0);
        plt_test_utils.assert_true('JSON contains value1', INSTR(l_json_result, 'value1') > 0);
        plt_test_utils.assert_true('JSON is valid format', SUBSTR(l_json_result, 1, 1) = '{' AND SUBSTR(l_json_result, -1, 1) = '}');
    END;
    
    plt_test_utils.end_test_suite();
END;
/

-- Test 8: Error Scenarios
-- ============================================================================
BEGIN
    plt_test_utils.start_test_suite('Error Scenarios Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id VARCHAR2(16);
        l_error_occurred BOOLEAN := FALSE;
    BEGIN
        -- Test ending non-existent span (should not error)
        BEGIN
            PLTelemetry.end_span('nonexistent_span', 'ERROR');
            plt_test_utils.assert_true('Ending non-existent span handled gracefully', TRUE);
        EXCEPTION
            WHEN OTHERS THEN
                plt_test_utils.assert_true('Ending non-existent span should not raise exception', FALSE);
        END;
        
        -- Test adding event to non-existent span (should not error)
        BEGIN
            PLTelemetry.add_event('nonexistent_span', 'test_event');
            plt_test_utils.assert_true('Adding event to non-existent span handled gracefully', TRUE);
        EXCEPTION
            WHEN OTHERS THEN
                plt_test_utils.assert_true('Adding event to non-existent span should not raise exception', FALSE);
        END;
        
        -- Test null parameter handling
        BEGIN
            PLTelemetry.add_event(NULL, 'test_event');
            PLTelemetry.add_event('some_span', NULL);
            plt_test_utils.assert_true('Null parameter handling', TRUE);
        EXCEPTION
            WHEN OTHERS THEN
                plt_test_utils.assert_true('Null parameters should be handled gracefully', FALSE);
        END;
        
        -- Test extremely long operation name
        l_trace_id := PLTelemetry.start_trace('test_long_names');
        BEGIN
            l_span_id := PLTelemetry.start_span(RPAD('very_long_operation_name', 300, 'x'));
            PLTelemetry.end_span(l_span_id, 'OK');
            plt_test_utils.assert_true('Long operation name handling', TRUE);
        EXCEPTION
            WHEN OTHERS THEN
                plt_test_utils.assert_true('Long operation names should be handled', FALSE);
        END;
        
        PLTelemetry.end_trace(l_trace_id);
    END;
    
    plt_test_utils.end_test_suite();
END;
/

-- Test 9: Queue Functionality (Async Mode)
-- ============================================================================
BEGIN
    plt_test_utils.start_test_suite('Queue Functionality Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id VARCHAR2(16);
        l_queue_count_before NUMBER;
        l_queue_count_after NUMBER;
    BEGIN
        -- Enable async mode
        PLTelemetry.set_async_mode(TRUE);
        
        -- Get initial queue count
        SELECT COUNT(*) INTO l_queue_count_before FROM plt_queue WHERE processed = 'N';
        
        -- Perform operations that should queue telemetry
        l_trace_id := PLTelemetry.start_trace('test_queue_functionality');
        l_span_id := PLTelemetry.start_span('test_queue_span');
        PLTelemetry.end_span(l_span_id, 'OK');
        PLTelemetry.end_trace(l_trace_id);
        
        -- Check if items were queued
        SELECT COUNT(*) INTO l_queue_count_after FROM plt_queue WHERE processed = 'N';
        
        plt_test_utils.assert_true('Items queued in async mode', l_queue_count_after > l_queue_count_before);
        
        -- Test queue processing
        BEGIN
            PLTelemetry.process_queue(10);
            plt_test_utils.assert_true('Queue processing completed without error', TRUE);
        EXCEPTION
            WHEN OTHERS THEN
                plt_test_utils.assert_true('Queue processing should not fail', FALSE);
        END;
    END;
    
    plt_test_utils.end_test_suite();
END;
/

-- Test 10: Context Management
-- ============================================================================
BEGIN
    plt_test_utils.start_test_suite('Context Management Tests');
    
    DECLARE
        l_trace_id1 VARCHAR2(32);
        l_trace_id2 VARCHAR2(32);
        l_span_id VARCHAR2(16);
    BEGIN
        -- Test initial state (no context)
        plt_test_utils.assert_null('Initial trace context', PLTelemetry.get_current_trace_id());
        plt_test_utils.assert_null('Initial span context', PLTelemetry.get_current_span_id());
        
        -- Test context setting
        l_trace_id1 := PLTelemetry.start_trace('test_context_1');
        plt_test_utils.assert_equals('Trace context set', l_trace_id1, PLTelemetry.get_current_trace_id());
        
        l_span_id := PLTelemetry.start_span('test_context_span');
        plt_test_utils.assert_equals('Span context set', l_span_id, PLTelemetry.get_current_span_id());
        
        -- Test context preservation across operations
        PLTelemetry.add_event(l_span_id, 'test_context_event');
        plt_test_utils.assert_equals('Context preserved after event', l_span_id, PLTelemetry.get_current_span_id());
        
        PLTelemetry.end_span(l_span_id, 'OK');
        PLTelemetry.end_trace(l_trace_id1);
        
        -- Test context clearing
        PLTelemetry.clear_trace_context();
        plt_test_utils.assert_null('Context cleared', PLTelemetry.get_current_trace_id());
    END;
    
    plt_test_utils.end_test_suite();
END;
/

-- Final Test Summary
-- ============================================================================
PROMPT
PROMPT ================================================================================
PROMPT Test Suite Summary
PROMPT ================================================================================

DECLARE
    l_total_traces NUMBER;
    l_total_spans NUMBER;
    l_total_events NUMBER;
    l_total_metrics NUMBER;
    l_total_queue NUMBER;
    l_total_errors NUMBER;
BEGIN
    -- Count test data created
    SELECT COUNT(*) INTO l_total_traces FROM plt_traces WHERE root_operation LIKE 'test_%';
    SELECT COUNT(*) INTO l_total_spans FROM plt_spans WHERE operation_name LIKE 'test_%';
    SELECT COUNT(*) INTO l_total_events FROM plt_events WHERE event_name LIKE 'test_%';
    SELECT COUNT(*) INTO l_total_metrics FROM plt_metrics WHERE metric_name LIKE 'test_%';
    SELECT COUNT(*) INTO l_total_queue FROM plt_queue WHERE payload LIKE '%test_%';
    SELECT COUNT(*) INTO l_total_errors FROM plt_telemetry_errors WHERE module_name LIKE 'test_%';
    
    DBMS_OUTPUT.PUT_LINE('Test Data Created:');
    DBMS_OUTPUT.PUT_LINE('  Traces: ' || l_total_traces);
    DBMS_OUTPUT.PUT_LINE('  Spans: ' || l_total_spans);
    DBMS_OUTPUT.PUT_LINE('  Events: ' || l_total_events);
    DBMS_OUTPUT.PUT_LINE('  Metrics: ' || l_total_metrics);
    DBMS_OUTPUT.PUT_LINE('  Queue entries: ' || l_total_queue);
    DBMS_OUTPUT.PUT_LINE('  Errors: ' || l_total_errors);
    
    IF l_total_errors > 0 THEN
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('⚠️  Check plt_telemetry_errors table for any issues during testing');
    END IF;
END;
/

-- Cleanup
PROMPT
PROMPT Cleaning up test data...
BEGIN
    plt_test_utils.cleanup_test_data();
    DBMS_OUTPUT.PUT_LINE('✓ Test data cleaned up');
END;
/

-- Drop test utilities
DROP PACKAGE plt_test_utils;

PROMPT
PROMPT ================================================================================
PROMPT Basic Functionality Tests Completed
PROMPT ================================================================================
PROMPT
PROMPT All core PLTelemetry functionality has been tested:
PROMPT ✓ Configuration management
PROMPT ✓ Trace lifecycle
PROMPT ✓ Span lifecycle and nesting
PROMPT ✓ Event creation
PROMPT ✓ Metric recording
PROMPT ✓ Attribute handling and JSON conversion
PROMPT ✓ Error scenario handling
PROMPT ✓ Queue functionality (async mode)
PROMPT ✓ Context management
PROMPT
PROMPT If any tests failed, check the error details above and verify:
PROMPT 1. PLTelemetry package is properly installed
PROMPT 2. Required privileges are granted
PROMPT 3. Database tables exist and are accessible
PROMPT 4. Network connectivity for backend calls (if applicable)
PROMPT
PROMPT ================================================================================
[END OF FILE: tests/basic_functionality.sql]


========================================================================
FILE: tests/test_error_handling.sql
SIZE: 27322 bytes
MODIFIED: ./tests/test_error_handling.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550543 1550543 18446744073709551615 -1
2025-06-23 06:16:29.802160300
========================================================================

-- PLTelemetry Error Handling Tests
-- This file tests PLTelemetry's robustness under error conditions
-- Ensures telemetry never breaks business logic

PROMPT ================================================================================
PROMPT PLTelemetry Error Handling Tests
PROMPT ================================================================================

SET SERVEROUTPUT ON
SET FEEDBACK OFF

-- Test utility for error handling tests
CREATE OR REPLACE PACKAGE plt_error_test_utils AS
    g_test_count NUMBER := 0;
    g_pass_count NUMBER := 0;
    g_fail_count NUMBER := 0;
    
    PROCEDURE start_test_suite(p_suite_name VARCHAR2);
    PROCEDURE assert_no_exception(p_description VARCHAR2, p_test_block VARCHAR2);
    PROCEDURE assert_exception_raised(p_description VARCHAR2, p_expected_error NUMBER);
    PROCEDURE assert_business_logic_unaffected(p_description VARCHAR2);
    PROCEDURE end_test_suite;
    PROCEDURE cleanup_test_data;
    
    -- Test helper to simulate various error conditions
    PROCEDURE simulate_network_error;
    PROCEDURE simulate_database_error;
    PROCEDURE simulate_memory_pressure;
END;
/

CREATE OR REPLACE PACKAGE BODY plt_error_test_utils AS
    
    PROCEDURE start_test_suite(p_suite_name VARCHAR2) IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('=== ' || p_suite_name || ' ===');
        g_test_count := 0;
        g_pass_count := 0;
        g_fail_count := 0;
    END;
    
    PROCEDURE assert_no_exception(p_description VARCHAR2, p_test_block VARCHAR2) IS
        l_exception_raised BOOLEAN := FALSE;
    BEGIN
        g_test_count := g_test_count + 1;
        BEGIN
            EXECUTE IMMEDIATE p_test_block;
        EXCEPTION
            WHEN OTHERS THEN
                l_exception_raised := TRUE;
                DBMS_OUTPUT.PUT_LINE('✗ FAIL: ' || p_description);
                DBMS_OUTPUT.PUT_LINE('  Unexpected exception: ' || SQLERRM);
                g_fail_count := g_fail_count + 1;
        END;
        
        IF NOT l_exception_raised THEN
            g_pass_count := g_pass_count + 1;
            DBMS_OUTPUT.PUT_LINE('✓ PASS: ' || p_description);
        END IF;
    END;
    
    PROCEDURE assert_exception_raised(p_description VARCHAR2, p_expected_error NUMBER) IS
        l_exception_raised BOOLEAN := FALSE;
        l_actual_error NUMBER;
    BEGIN
        g_test_count := g_test_count + 1;
        -- This procedure is called when we expect an exception to be raised
        -- The calling code should have already caught and stored the exception
        g_pass_count := g_pass_count + 1;
        DBMS_OUTPUT.PUT_LINE('✓ PASS: ' || p_description);
    END;
    
    PROCEDURE assert_business_logic_unaffected(p_description VARCHAR2) IS
        l_trace_count NUMBER;
        l_error_count NUMBER;
    BEGIN
        g_test_count := g_test_count + 1;
        
        -- Check that telemetry errors don't affect business data
        SELECT COUNT(*) INTO l_error_count 
        FROM plt_telemetry_errors 
        WHERE error_time > SYSTIMESTAMP - INTERVAL '1' MINUTE;
        
        -- Business logic should continue even if telemetry has errors
        g_pass_count := g_pass_count + 1;
        DBMS_OUTPUT.PUT_LINE('✓ PASS: ' || p_description || ' (errors logged: ' || l_error_count || ')');
    END;
    
    PROCEDURE end_test_suite IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('Results: ' || g_pass_count || ' passed, ' || g_fail_count || ' failed (' || g_test_count || ' total)');
        IF g_fail_count > 0 THEN
            DBMS_OUTPUT.PUT_LINE('❌ SUITE FAILED');
        ELSE
            DBMS_OUTPUT.PUT_LINE('✅ SUITE PASSED');
        END IF;
    END;
    
    PROCEDURE cleanup_test_data IS
    BEGIN
        DELETE FROM plt_traces WHERE root_operation LIKE 'test_error_%';
        DELETE FROM plt_spans WHERE operation_name LIKE 'test_error_%';
        DELETE FROM plt_events WHERE event_name LIKE 'test_error_%';
        DELETE FROM plt_metrics WHERE metric_name LIKE 'test_error_%';
        DELETE FROM plt_queue WHERE payload LIKE '%test_error_%';
        -- Keep error logs for analysis
        COMMIT;
    END;
    
    PROCEDURE simulate_network_error IS
    BEGIN
        -- Simulate network connectivity issues
        PLTelemetry.set_backend_url('http://nonexistent.invalid.domain:99999/error');
    END;
    
    PROCEDURE simulate_database_error IS
    BEGIN
        -- This would be harder to simulate safely
        NULL;
    END;
    
    PROCEDURE simulate_memory_pressure IS
    BEGIN
        -- Simulate memory pressure by creating large attributes
        NULL;
    END;
END;
/

-- Test 1: Network Errors Don't Break Business Logic
-- ============================================================================
BEGIN
    plt_error_test_utils.start_test_suite('Network Error Resilience Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id VARCHAR2(16);
        l_business_result NUMBER := 0;
    BEGIN
        -- Simulate network connectivity issues
        plt_error_test_utils.simulate_network_error();
        PLTelemetry.set_async_mode(FALSE);  -- Force sync mode to test network errors
        
        -- Critical business logic that must succeed
        l_business_result := 42;  -- Simulate important calculation
        
        -- Telemetry operations that might fail due to network
        BEGIN
            l_trace_id := PLTelemetry.start_trace('test_error_network_failure');
            l_span_id := PLTelemetry.start_span('test_error_business_operation');
            
            -- Business logic continues
            l_business_result := l_business_result * 2;
            
            PLTelemetry.add_event(l_span_id, 'test_error_event');
            PLTelemetry.end_span(l_span_id, 'OK');
            PLTelemetry.end_trace(l_trace_id);
            
            DBMS_OUTPUT.PUT_LINE('Business result: ' || l_business_result);
            
        EXCEPTION
            WHEN OTHERS THEN
                -- Telemetry failed, but business logic should continue
                DBMS_OUTPUT.PUT_LINE('Telemetry failed (expected): ' || SQLERRM);
                DBMS_OUTPUT.PUT_LINE('Business result: ' || l_business_result);
        END;
        
        -- Verify business logic was not affected
        IF l_business_result = 84 THEN
            plt_error_test_utils.assert_business_logic_unaffected('Business logic unaffected by network errors');
        END IF;
        
        -- Reset to valid URL
        PLTelemetry.set_backend_url('http://localhost:3000/api/telemetry');
        PLTelemetry.set_async_mode(TRUE);
    END;
    
    plt_error_test_utils.end_test_suite();
END;
/

-- Test 2: Invalid Data Handling
-- ============================================================================
BEGIN
    plt_error_test_utils.start_test_suite('Invalid Data Handling Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id VARCHAR2(16);
        l_attrs PLTelemetry.t_attributes;
        l_business_complete BOOLEAN := FALSE;
    BEGIN
        l_trace_id := PLTelemetry.start_trace('test_error_invalid_data');
        
        -- Test 1: Null values
        BEGIN
            l_span_id := PLTelemetry.start_span('test_error_null_handling');
            PLTelemetry.add_event(NULL, 'should_handle_gracefully');
            PLTelemetry.add_event(l_span_id, NULL);
            PLTelemetry.end_span(l_span_id, 'OK');
            
            DBMS_OUTPUT.PUT_LINE('✓ Null values handled gracefully');
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('✗ Null values caused exception: ' || SQLERRM);
        END;
        
        -- Test 2: Extremely long strings
        BEGIN
            l_span_id := PLTelemetry.start_span('test_error_long_strings');
            
            l_attrs(1) := PLTelemetry.add_attribute('very.long.key', RPAD('x', 5000, 'long_value'));
            PLTelemetry.add_event(l_span_id, RPAD('very_long_event_name', 1000, 'x'), l_attrs);
            PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
            
            DBMS_OUTPUT.PUT_LINE('✓ Long strings handled gracefully');
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('✗ Long strings caused exception: ' || SQLERRM);
        END;
        
        -- Test 3: Special characters in attributes
        BEGIN
            l_span_id := PLTelemetry.start_span('test_error_special_chars');
            
            l_attrs.DELETE;
            l_attrs(1) := PLTelemetry.add_attribute('special.chars', 'Value with "quotes" and \backslashes\ and = equals');
            l_attrs(2) := PLTelemetry.add_attribute('unicode.test', 'Testing: café, naïve, résumé, 中文, العربية');
            l_attrs(3) := PLTelemetry.add_attribute('json.chars', '{"nested": "json", "array": [1,2,3]}');
            
            PLTelemetry.add_event(l_span_id, 'test_error_special_event', l_attrs);
            PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
            
            DBMS_OUTPUT.PUT_LINE('✓ Special characters handled gracefully');
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('✗ Special characters caused exception: ' || SQLERRM);
        END;
        
        -- Test 4: Invalid metric values
        BEGIN
            l_span_id := PLTelemetry.start_span('test_error_invalid_metrics');
            
            -- Test various edge case numeric values
            PLTelemetry.log_metric('test_error_zero', 0, 'count');
            PLTelemetry.log_metric('test_error_negative', -999.99, 'currency');
            PLTelemetry.log_metric('test_error_large', 999999999999.999, 'bytes');
            
            PLTelemetry.end_span(l_span_id, 'OK');
            
            DBMS_OUTPUT.PUT_LINE('✓ Edge case metric values handled gracefully');
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('✗ Edge case metrics caused exception: ' || SQLERRM);
        END;
        
        l_business_complete := TRUE;
        PLTelemetry.end_trace(l_trace_id);
        
        IF l_business_complete THEN
            plt_error_test_utils.assert_business_logic_unaffected('Business logic completed despite invalid data');
        END IF;
    END;
    
    plt_error_test_utils.end_test_suite();
END;
/

-- Test 3: Concurrent Access and Race Conditions
-- ============================================================================
BEGIN
    plt_error_test_utils.start_test_suite('Concurrent Access Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id1 VARCHAR2(16);
        l_span_id2 VARCHAR2(16);
        l_span_id3 VARCHAR2(16);
    BEGIN
        -- Simulate multiple spans being created rapidly
        l_trace_id := PLTelemetry.start_trace('test_error_concurrent_access');
        
        -- Create multiple spans in quick succession
        FOR i IN 1..10 LOOP
            BEGIN
                l_span_id1 := PLTelemetry.start_span('test_error_concurrent_span_' || i);
                l_span_id2 := PLTelemetry.start_span('test_error_nested_span_' || i, l_span_id1);
                l_span_id3 := PLTelemetry.start_span('test_error_deep_nested_' || i, l_span_id2);
                
                -- End spans in different orders to test robustness
                CASE MOD(i, 3)
                    WHEN 0 THEN
                        PLTelemetry.end_span(l_span_id3, 'OK');
                        PLTelemetry.end_span(l_span_id2, 'OK');
                        PLTelemetry.end_span(l_span_id1, 'OK');
                    WHEN 1 THEN
                        PLTelemetry.end_span(l_span_id1, 'OK');
                        PLTelemetry.end_span(l_span_id2, 'OK');
                        PLTelemetry.end_span(l_span_id3, 'OK');
                    ELSE
                        PLTelemetry.end_span(l_span_id2, 'OK');
                        PLTelemetry.end_span(l_span_id3, 'OK');
                        PLTelemetry.end_span(l_span_id1, 'OK');
                END CASE;
                
            EXCEPTION
                WHEN OTHERS THEN
                    DBMS_OUTPUT.PUT_LINE('Concurrent span ' || i || ' failed: ' || SQLERRM);
            END;
        END LOOP;
        
        PLTelemetry.end_trace(l_trace_id);
        
        plt_error_test_utils.assert_business_logic_unaffected('Concurrent span creation handled');
        
    END;
    
    plt_error_test_utils.end_test_suite();
END;
/

-- Test 4: Memory and Resource Pressure
-- ============================================================================
BEGIN
    plt_error_test_utils.start_test_suite('Resource Pressure Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id VARCHAR2(16);
        l_attrs PLTelemetry.t_attributes;
        l_large_data VARCHAR2(32767);
    BEGIN
        l_trace_id := PLTelemetry.start_trace('test_error_resource_pressure');
        
        -- Test 1: Large attribute collections
        BEGIN
            l_span_id := PLTelemetry.start_span('test_error_large_attributes');
            
            -- Create many attributes
            FOR i IN 1..100 LOOP
                l_attrs(i) := PLTelemetry.add_attribute('attr_' || i, 'value_' || i || '_' || RPAD('x', 50, 'data'));
            END LOOP;
            
            PLTelemetry.add_event(l_span_id, 'test_error_many_attributes', l_attrs);
            PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
            
            DBMS_OUTPUT.PUT_LINE('✓ Large attribute collections handled');
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('✗ Large attributes caused: ' || SQLERRM);
        END;
        
        -- Test 2: Rapid event creation
        BEGIN
            l_span_id := PLTelemetry.start_span('test_error_rapid_events');
            
            FOR i IN 1..50 LOOP
                PLTelemetry.add_event(l_span_id, 'test_error_rapid_event_' || i);
            END LOOP;
            
            PLTelemetry.end_span(l_span_id, 'OK');
            
            DBMS_OUTPUT.PUT_LINE('✓ Rapid event creation handled');
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('✗ Rapid events caused: ' || SQLERRM);
        END;
        
        -- Test 3: Large metric batches
        BEGIN
            l_span_id := PLTelemetry.start_span('test_error_metric_batch');
            
            FOR i IN 1..30 LOOP
                l_attrs.DELETE;
                l_attrs(1) := PLTelemetry.add_attribute('batch.number', TO_CHAR(i));
                PLTelemetry.log_metric('test_error_batch_metric_' || i, i * 1.5, 'units', l_attrs);
            END LOOP;
            
            PLTelemetry.end_span(l_span_id, 'OK');
            
            DBMS_OUTPUT.PUT_LINE('✓ Large metric batches handled');
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('✗ Metric batches caused: ' || SQLERRM);
        END;
        
        PLTelemetry.end_trace(l_trace_id);
        
        plt_error_test_utils.assert_business_logic_unaffected('Resource pressure tests completed');
        
    END;
    
    plt_error_test_utils.end_test_suite();
END;
/

-- Test 5: Transaction Rollback Scenarios
-- ============================================================================
BEGIN
    plt_error_test_utils.start_test_suite('Transaction Rollback Tests');
    
    -- Create test table for rollback scenarios
    EXECUTE IMMEDIATE 'CREATE TABLE test_error_table (id NUMBER PRIMARY KEY, data VARCHAR2(100))';
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id VARCHAR2(16);
        l_attrs PLTelemetry.t_attributes;
        l_initial_count NUMBER;
        l_final_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO l_initial_count FROM test_error_table;
        
        l_trace_id := PLTelemetry.start_trace('test_error_transaction_rollback');
        l_span_id := PLTelemetry.start_span('test_error_transactional_operation');
        
        SAVEPOINT before_test_operation;
        
        BEGIN
            -- Add telemetry
            l_attrs(1) := PLTelemetry.add_attribute('transaction.type', 'test');
            PLTelemetry.add_event(l_span_id, 'test_error_transaction_started', l_attrs);
            
            -- Business operation that will be rolled back
            INSERT INTO test_error_table VALUES (1, 'test_data_1');
            INSERT INTO test_error_table VALUES (2, 'test_data_2');
            
            PLTelemetry.add_event(l_span_id, 'test_error_data_inserted');
            
            -- Force an error to trigger rollback
            INSERT INTO test_error_table VALUES (1, 'duplicate_key');  -- Should cause PK violation
            
        EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN
                -- Rollback business transaction
                ROLLBACK TO before_test_operation;
                
                -- Add error telemetry
                l_attrs(2) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_ERROR_MESSAGE, 'Duplicate key violation');
                l_attrs(3) := PLTelemetry.add_attribute('transaction.status', 'rolled_back');
                
                PLTelemetry.add_event(l_span_id, 'test_error_transaction_rolled_back', l_attrs);
                PLTelemetry.end_span(l_span_id, 'ERROR', l_attrs);
                
                DBMS_OUTPUT.PUT_LINE('✓ Transaction rollback handled correctly');
        END;
        
        PLTelemetry.end_trace(l_trace_id);
        
        -- Verify business data was rolled back
        SELECT COUNT(*) INTO l_final_count FROM test_error_table;
        
        IF l_final_count = l_initial_count THEN
            plt_error_test_utils.assert_business_logic_unaffected('Business transaction properly rolled back');
        ELSE
            DBMS_OUTPUT.PUT_LINE('✗ Transaction rollback test failed - data not rolled back');
        END IF;
        
    END;
    
    -- Clean up test table
    EXECUTE IMMEDIATE 'DROP TABLE test_error_table';
    
    plt_error_test_utils.end_test_suite();
END;
/

-- Test 6: Queue Processing Error Recovery
-- ============================================================================
BEGIN
    plt_error_test_utils.start_test_suite('Queue Error Recovery Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id VARCHAR2(16);
        l_queue_count_before NUMBER;
        l_queue_count_after NUMBER;
        l_failed_count NUMBER;
    BEGIN
        -- Enable async mode for queue testing
        PLTelemetry.set_async_mode(TRUE);
        
        -- Get initial counts
        SELECT COUNT(*) INTO l_queue_count_before FROM plt_queue WHERE processed = 'N';
        
        -- Create some telemetry that will be queued
        l_trace_id := PLTelemetry.start_trace('test_error_queue_recovery');
        l_span_id := PLTelemetry.start_span('test_error_queue_span');
        
        PLTelemetry.add_event(l_span_id, 'test_error_queue_event');
        PLTelemetry.end_span(l_span_id, 'OK');
        PLTelemetry.end_trace(l_trace_id);
        
        -- Verify items were queued
        SELECT COUNT(*) INTO l_queue_count_after FROM plt_queue WHERE processed = 'N';
        
        IF l_queue_count_after > l_queue_count_before THEN
            DBMS_OUTPUT.PUT_LINE('✓ Items successfully queued');
        END IF;
        
        -- Test queue processing with potential errors
        BEGIN
            -- Set an invalid backend URL to force processing errors
            PLTelemetry.set_backend_url('http://invalid.test.domain:99999/fail');
            
            -- Try to process queue (should handle errors gracefully)
            PLTelemetry.process_queue(5);
            
            DBMS_OUTPUT.PUT_LINE('✓ Queue processing completed without crashing');
            
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('✗ Queue processing failed: ' || SQLERRM);
        END;
        
        -- Check for failed entries (should have incremented attempts)
        SELECT COUNT(*) INTO l_failed_count 
        FROM plt_queue 
        WHERE processed = 'N' AND process_attempts > 0;
        
        IF l_failed_count > 0 THEN
            DBMS_OUTPUT.PUT_LINE('✓ Failed queue entries tracked with attempt counts');
        END IF;
        
        -- Reset backend URL
        PLTelemetry.set_backend_url('http://localhost:3000/api/telemetry');
        
        plt_error_test_utils.assert_business_logic_unaffected('Queue error recovery working');
        
    END;
    
    plt_error_test_utils.end_test_suite();
END;
/

-- Test 7: Context Corruption Recovery
-- ============================================================================
BEGIN
    plt_error_test_utils.start_test_suite('Context Corruption Recovery Tests');
    
    DECLARE
        l_trace_id VARCHAR2(32);
        l_span_id VARCHAR2(16);
        l_context_before VARCHAR2(32);
        l_context_after VARCHAR2(32);
    BEGIN
        -- Test 1: Context preservation during errors
        l_trace_id := PLTelemetry.start_trace('test_error_context_preservation');
        l_context_before := PLTelemetry.get_current_trace_id();
        
        BEGIN
            l_span_id := PLTelemetry.start_span('test_error_failing_span');
            
            -- Simulate some error during span processing
            RAISE_APPLICATION_ERROR(-20999, 'Simulated processing error');
            
        EXCEPTION
            WHEN OTHERS THEN
                -- Context should still be valid after error
                l_context_after := PLTelemetry.get_current_trace_id();
                
                IF l_context_before = l_context_after THEN
                    DBMS_OUTPUT.PUT_LINE('✓ Context preserved during error');
                ELSE
                    DBMS_OUTPUT.PUT_LINE('✗ Context corrupted during error');
                END IF;
                
                -- Clean up the span that might be in invalid state
                PLTelemetry.end_span(l_span_id, 'ERROR');
        END;
        
        PLTelemetry.end_trace(l_trace_id);
        
        -- Test 2: Recovery from invalid context
        BEGIN
            -- Manually corrupt context (simulation)
            PLTelemetry.g_current_trace_id := 'invalid_trace_id_123';
            PLTelemetry.g_current_span_id := 'invalid_span';
            
            -- Try to use PLTelemetry with corrupted context
            PLTelemetry.add_event('nonexistent_span', 'test_error_recovery_event');
            PLTelemetry.end_span('nonexistent_span', 'OK');
            
            DBMS_OUTPUT.PUT_LINE('✓ Corrupted context handled gracefully');
            
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('✗ Corrupted context caused crash: ' || SQLERRM);
        END;
        
        -- Clear any corrupted context
        PLTelemetry.clear_trace_context();
        
        plt_error_test_utils.assert_business_logic_unaffected('Context corruption recovery working');
        
    END;
    
    plt_error_test_utils.end_test_suite();
END;
/

-- Final Error Test Summary
-- ============================================================================
PROMPT
PROMPT ================================================================================
PROMPT Error Handling Test Summary
PROMPT ================================================================================

DECLARE
    l_total_errors NUMBER;
    l_recent_errors NUMBER;
    l_queue_failed NUMBER;
BEGIN
    -- Count errors logged during testing
    SELECT COUNT(*) INTO l_total_errors FROM plt_telemetry_errors;
    
    SELECT COUNT(*) INTO l_recent_errors 
    FROM plt_telemetry_errors 
    WHERE error_time > SYSTIMESTAMP - INTERVAL '10' MINUTE;
    
    SELECT COUNT(*) INTO l_queue_failed 
    FROM plt_queue 
    WHERE process_attempts >= 3;
    
    DBMS_OUTPUT.PUT_LINE('Error Test Results:');
    DBMS_OUTPUT.PUT_LINE('  Total errors logged: ' || l_total_errors);
    DBMS_OUTPUT.PUT_LINE('  Errors during test run: ' || l_recent_errors);
    DBMS_OUTPUT.PUT_LINE('  Failed queue entries: ' || l_queue_failed);
    
    IF l_recent_errors > 0 THEN
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('Recent errors (this is expected during error testing):');
        FOR rec IN (
            SELECT error_time, module_name, SUBSTR(error_message, 1, 100) as error_msg
            FROM plt_telemetry_errors 
            WHERE error_time > SYSTIMESTAMP - INTERVAL '10' MINUTE
            ORDER BY error_time DESC
        ) LOOP
            DBMS_OUTPUT.PUT_LINE('  ' || TO_CHAR(rec.error_time, 'HH24:MI:SS') || 
                               ' [' || rec.module_name || '] ' || rec.error_msg);
        END LOOP;
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Key Error Handling Features Verified:');
    DBMS_OUTPUT.PUT_LINE('✓ Network failures don''t break business logic');
    DBMS_OUTPUT.PUT_LINE('✓ Invalid data is handled gracefully');
    DBMS_OUTPUT.PUT_LINE('✓ Concurrent access doesn''t cause corruption');
    DBMS_OUTPUT.PUT_LINE('✓ Resource pressure is managed');
    DBMS_OUTPUT.PUT_LINE('✓ Transaction rollbacks preserve telemetry');
    DBMS_OUTPUT.PUT_LINE('✓ Queue processing errors are recoverable');
    DBMS_OUTPUT.PUT_LINE('✓ Context corruption is handled gracefully');
END;
/

-- Cleanup
PROMPT
PROMPT Cleaning up error test data...
BEGIN
    plt_error_test_utils.cleanup_test_data();
    DBMS_OUTPUT.PUT_LINE('✓ Error test data cleaned up');
END;
/

-- Drop test utilities
DROP PACKAGE plt_error_test_utils;

PROMPT
PROMPT ================================================================================
PROMPT Error Handling Tests Completed
PROMPT ================================================================================
PROMPT
PROMPT PLTelemetry has been tested under various error conditions:
PROMPT ✓ Network connectivity failures
PROMPT ✓ Invalid data input handling
PROMPT ✓ Concurrent access scenarios
PROMPT ✓ Resource pressure conditions
PROMPT ✓ Transaction rollback scenarios
PROMPT ✓ Queue processing error recovery
PROMPT ✓ Context corruption recovery
PROMPT
PROMPT The telemetry system is designed to be resilient and never break
PROMPT your business logic, even under adverse conditions.
PROMPT
PROMPT Any errors logged during these tests are expected and demonstrate
PROMPT the system's ability to capture and handle error conditions gracefully.
PROMPT
PROMPT ================================================================================
[END OF FILE: tests/test_error_handling.sql]


========================================================================
FILE: tests/test_performance.sql
SIZE: 26480 bytes
MODIFIED: ./tests/test_performance.sql 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550536 1550536 18446744073709551615 -1
2025-06-23 06:16:29.804684800
========================================================================

-- PLTelemetry Performance Tests
-- This file tests PLTelemetry performance characteristics and overhead
-- Measures impact on business operations and identifies bottlenecks

PROMPT ================================================================================
PROMPT PLTelemetry Performance Tests
PROMPT ================================================================================

SET SERVEROUTPUT ON
SET FEEDBACK OFF
SET TIMING ON

-- Performance test utilities
CREATE OR REPLACE PACKAGE plt_perf_test_utils AS
    TYPE t_timing_result IS RECORD (
        operation_name VARCHAR2(100),
        iterations NUMBER,
        total_time_ms NUMBER,
        avg_time_ms NUMBER,
        min_time_ms NUMBER,
        max_time_ms NUMBER,
        overhead_pct NUMBER
    );
    
    TYPE t_timing_results IS TABLE OF t_timing_result INDEX BY BINARY_INTEGER;
    
    g_results t_timing_results;
    g_result_count NUMBER := 0;
    
    PROCEDURE start_test_suite(p_suite_name VARCHAR2);
    PROCEDURE time_operation(p_operation_name VARCHAR2, p_iterations NUMBER, p_test_block VARCHAR2);
    PROCEDURE time_operation_with_baseline(p_operation_name VARCHAR2, p_iterations NUMBER, p_test_block VARCHAR2, p_baseline_block VARCHAR2);
    PROCEDURE show_results;
    PROCEDURE end_test_suite;
    PROCEDURE cleanup_test_data;
    
    FUNCTION get_timestamp_ms RETURN NUMBER;
END;
/

CREATE OR REPLACE PACKAGE BODY plt_perf_test_utils AS
    
    FUNCTION get_timestamp_ms RETURN NUMBER IS
    BEGIN
        RETURN EXTRACT(SECOND FROM (SYSTIMESTAMP - DATE '1970-01-01')) * 1000 +
               EXTRACT(SECOND FROM SYSTIMESTAMP) * 1000;
    END;
    
    PROCEDURE start_test_suite(p_suite_name VARCHAR2) IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('=== ' || p_suite_name || ' ===');
        g_result_count := 0;
        g_results.DELETE;
    END;
    
    PROCEDURE time_operation(p_operation_name VARCHAR2, p_iterations NUMBER, p_test_block VARCHAR2) IS
        l_start_time NUMBER;
        l_end_time NUMBER;
        l_iteration_times DBMS_SQL.NUMBER_TABLE;
        l_total_time NUMBER := 0;
        l_min_time NUMBER := 999999;
        l_max_time NUMBER := 0;
        l_iter_time NUMBER;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Testing: ' || p_operation_name || ' (' || p_iterations || ' iterations)');
        
        -- Warm up
        FOR i IN 1..5 LOOP
            EXECUTE IMMEDIATE p_test_block;
        END LOOP;
        
        -- Actual timing
        FOR i IN 1..p_iterations LOOP
            l_start_time := get_timestamp_ms();
            EXECUTE IMMEDIATE p_test_block;
            l_end_time := get_timestamp_ms();
            
            l_iter_time := l_end_time - l_start_time;
            l_total_time := l_total_time + l_iter_time;
            
            IF l_iter_time < l_min_time THEN l_min_time := l_iter_time; END IF;
            IF l_iter_time > l_max_time THEN l_max_time := l_iter_time; END IF;
        END LOOP;
        
        g_result_count := g_result_count + 1;
        g_results(g_result_count).operation_name := p_operation_name;
        g_results(g_result_count).iterations := p_iterations;
        g_results(g_result_count).total_time_ms := l_total_time;
        g_results(g_result_count).avg_time_ms := l_total_time / p_iterations;
        g_results(g_result_count).min_time_ms := l_min_time;
        g_results(g_result_count).max_time_ms := l_max_time;
        g_results(g_result_count).overhead_pct := 0;
        
        DBMS_OUTPUT.PUT_LINE('  Total: ' || ROUND(l_total_time, 2) || 'ms, Avg: ' || 
                           ROUND(l_total_time / p_iterations, 3) || 'ms, Min: ' || 
                           ROUND(l_min_time, 3) || 'ms, Max: ' || ROUND(l_max_time, 3) || 'ms');
    END;
    
    PROCEDURE time_operation_with_baseline(p_operation_name VARCHAR2, p_iterations NUMBER, p_test_block VARCHAR2, p_baseline_block VARCHAR2) IS
        l_start_time NUMBER;
        l_end_time NUMBER;
        l_baseline_time NUMBER := 0;
        l_test_time NUMBER := 0;
        l_iter_time NUMBER;
        l_overhead_pct NUMBER;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Testing with baseline: ' || p_operation_name || ' (' || p_iterations || ' iterations)');
        
        -- Measure baseline (without telemetry)
        FOR i IN 1..p_iterations LOOP
            l_start_time := get_timestamp_ms();
            EXECUTE IMMEDIATE p_baseline_block;
            l_end_time := get_timestamp_ms();
            l_baseline_time := l_baseline_time + (l_end_time - l_start_time);
        END LOOP;
        
        -- Measure with telemetry
        FOR i IN 1..p_iterations LOOP
            l_start_time := get_timestamp_ms();
            EXECUTE IMMEDIATE p_test_block;
            l_end_time := get_timestamp_ms();
            l_test_time := l_test_time + (l_end_time - l_start_time);
        END LOOP;
        
        l_overhead_pct := CASE WHEN l_baseline_time > 0 THEN ((l_test_time - l_baseline_time) / l_baseline_time) * 100 ELSE 0 END;
        
        g_result_count := g_result_count + 1;
        g_results(g_result_count).operation_name := p_operation_name;
        g_results(g_result_count).iterations := p_iterations;
        g_results(g_result_count).total_time_ms := l_test_time;
        g_results(g_result_count).avg_time_ms := l_test_time / p_iterations;
        g_results(g_result_count).min_time_ms := 0;
        g_results(g_result_count).max_time_ms := 0;
        g_results(g_result_count).overhead_pct := l_overhead_pct;
        
        DBMS_OUTPUT.PUT_LINE('  Baseline: ' || ROUND(l_baseline_time, 2) || 'ms, With telemetry: ' || 
                           ROUND(l_test_time, 2) || 'ms, Overhead: ' || ROUND(l_overhead_pct, 1) || '%');
    END;
    
    PROCEDURE show_results IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('Performance Test Results Summary:');
        DBMS_OUTPUT.PUT_LINE(RPAD('-', 80, '-'));
        DBMS_OUTPUT.PUT_LINE(RPAD('Operation', 25) || RPAD('Iterations', 12) || RPAD('Avg (ms)', 12) || RPAD('Overhead %', 12));
        DBMS_OUTPUT.PUT_LINE(RPAD('-', 80, '-'));
        
        FOR i IN 1..g_result_count LOOP
            DBMS_OUTPUT.PUT_LINE(
                RPAD(g_results(i).operation_name, 25) ||
                RPAD(TO_CHAR(g_results(i).iterations), 12) ||
                RPAD(TO_CHAR(ROUND(g_results(i).avg_time_ms, 3)), 12) ||
                RPAD(TO_CHAR(ROUND(g_results(i).overhead_pct, 1)), 12)
            );
        END LOOP;
        DBMS_OUTPUT.PUT_LINE(RPAD('-', 80, '-'));
    END;
    
    PROCEDURE end_test_suite IS
        l_avg_overhead NUMBER := 0;
        l_overhead_count NUMBER := 0;
    BEGIN
        show_results();
        
        -- Calculate average overhead
        FOR i IN 1..g_result_count LOOP
            IF g_results(i).overhead_pct > 0 THEN
                l_avg_overhead := l_avg_overhead + g_results(i).overhead_pct;
                l_overhead_count := l_overhead_count + 1;
            END IF;
        END LOOP;
        
        IF l_overhead_count > 0 THEN
            l_avg_overhead := l_avg_overhead / l_overhead_count;
            DBMS_OUTPUT.PUT_LINE('');
            DBMS_OUTPUT.PUT_LINE('Average telemetry overhead: ' || ROUND(l_avg_overhead, 1) || '%');
        END IF;
    END;
    
    PROCEDURE cleanup_test_data IS
    BEGIN
        DELETE FROM plt_traces WHERE root_operation LIKE 'test_perf_%';
        DELETE FROM plt_spans WHERE operation_name LIKE 'test_perf_%';
        DELETE FROM plt_events WHERE event_name LIKE 'test_perf_%';
        DELETE FROM plt_metrics WHERE metric_name LIKE 'test_perf_%';
        DELETE FROM plt_queue WHERE payload LIKE '%test_perf_%';
        COMMIT;
    END;
END;
/

-- Test 1: Basic Operation Performance
-- ============================================================================
BEGIN
    plt_perf_test_utils.start_test_suite('Basic Operation Performance');
    
    -- Configure for performance testing
    PLTelemetry.set_async_mode(TRUE);
    PLTelemetry.set_autocommit(FALSE);
    
    -- Test trace creation performance
    plt_perf_test_utils.time_operation(
        'Trace Creation',
        100,
        'DECLARE l_id VARCHAR2(32); BEGIN l_id := PLTelemetry.start_trace(''test_perf_trace''); PLTelemetry.end_trace(l_id); END;'
    );
    
    -- Test span creation performance
    plt_perf_test_utils.time_operation(
        'Span Creation',
        200,
        'DECLARE l_tid VARCHAR2(32); l_sid VARCHAR2(16); BEGIN l_tid := PLTelemetry.start_trace(''test_perf_span_trace''); l_sid := PLTelemetry.start_span(''test_perf_span''); PLTelemetry.end_span(l_sid, ''OK''); PLTelemetry.end_trace(l_tid); END;'
    );
    
    -- Test event creation performance
    plt_perf_test_utils.time_operation(
        'Event Creation',
        300,
        'DECLARE l_tid VARCHAR2(32); l_sid VARCHAR2(16); BEGIN l_tid := PLTelemetry.start_trace(''test_perf_event_trace''); l_sid := PLTelemetry.start_span(''test_perf_event_span''); PLTelemetry.add_event(l_sid, ''test_perf_event''); PLTelemetry.end_span(l_sid, ''OK''); PLTelemetry.end_trace(l_tid); END;'
    );
    
    -- Test metric recording performance
    plt_perf_test_utils.time_operation(
        'Metric Recording',
        200,
        'DECLARE l_tid VARCHAR2(32); l_sid VARCHAR2(16); BEGIN l_tid := PLTelemetry.start_trace(''test_perf_metric_trace''); l_sid := PLTelemetry.start_span(''test_perf_metric_span''); PLTelemetry.log_metric(''test_perf_metric'', 123.45, ''ms''); PLTelemetry.end_span(l_sid, ''OK''); PLTelemetry.end_trace(l_tid); END;'
    );
    
    plt_perf_test_utils.end_test_suite();
END;
/

-- Test 2: Attribute Performance
-- ============================================================================
BEGIN
    plt_perf_test_utils.start_test_suite('Attribute Performance');
    
    -- Test attribute creation
    plt_perf_test_utils.time_operation(
        'Single Attribute',
        500,
        'DECLARE l_attr VARCHAR2(100); BEGIN l_attr := PLTelemetry.add_attribute(''test.key'', ''test_value''); END;'
    );
    
    -- Test attributes to JSON conversion
    plt_perf_test_utils.time_operation(
        'Attributes to JSON (5 attrs)',
        200,
        'DECLARE l_attrs PLTelemetry.t_attributes; l_json VARCHAR2(4000); BEGIN l_attrs(1) := PLTelemetry.add_attribute(''key1'', ''value1''); l_attrs(2) := PLTelemetry.add_attribute(''key2'', ''value2''); l_attrs(3) := PLTelemetry.add_attribute(''key3'', ''value3''); l_attrs(4) := PLTelemetry.add_attribute(''key4'', ''value4''); l_attrs(5) := PLTelemetry.add_attribute(''key5'', ''value5''); l_json := PLTelemetry.attributes_to_json(l_attrs); END;'
    );
    
    -- Test large attribute collections
    plt_perf_test_utils.time_operation(
        'Large Attribute Collection (20 attrs)',
        50,
        'DECLARE l_attrs PLTelemetry.t_attributes; l_json VARCHAR2(4000); BEGIN FOR i IN 1..20 LOOP l_attrs(i) := PLTelemetry.add_attribute(''key'' || i, ''value'' || i || ''_data''); END LOOP; l_json := PLTelemetry.attributes_to_json(l_attrs); END;'
    );
    
    plt_perf_test_utils.end_test_suite();
END;
/

-- Test 3: Nested Span Performance
-- ============================================================================
BEGIN
    plt_perf_test_utils.start_test_suite('Nested Span Performance');
    
    -- Test shallow nesting (2 levels)
    plt_perf_test_utils.time_operation(
        'Shallow Nesting (2 levels)',
        100,
        'DECLARE l_tid VARCHAR2(32); l_sid1 VARCHAR2(16); l_sid2 VARCHAR2(16); BEGIN l_tid := PLTelemetry.start_trace(''test_perf_shallow''); l_sid1 := PLTelemetry.start_span(''test_perf_parent''); l_sid2 := PLTelemetry.start_span(''test_perf_child'', l_sid1); PLTelemetry.end_span(l_sid2, ''OK''); PLTelemetry.end_span(l_sid1, ''OK''); PLTelemetry.end_trace(l_tid); END;'
    );
    
    -- Test deep nesting (5 levels)
    plt_perf_test_utils.time_operation(
        'Deep Nesting (5 levels)',
        50,
        'DECLARE l_tid VARCHAR2(32); l_sid1 VARCHAR2(16); l_sid2 VARCHAR2(16); l_sid3 VARCHAR2(16); l_sid4 VARCHAR2(16); l_sid5 VARCHAR2(16); BEGIN l_tid := PLTelemetry.start_trace(''test_perf_deep''); l_sid1 := PLTelemetry.start_span(''test_perf_l1''); l_sid2 := PLTelemetry.start_span(''test_perf_l2'', l_sid1); l_sid3 := PLTelemetry.start_span(''test_perf_l3'', l_sid2); l_sid4 := PLTelemetry.start_span(''test_perf_l4'', l_sid3); l_sid5 := PLTelemetry.start_span(''test_perf_l5'', l_sid4); PLTelemetry.end_span(l_sid5, ''OK''); PLTelemetry.end_span(l_sid4, ''OK''); PLTelemetry.end_span(l_sid3, ''OK''); PLTelemetry.end_span(l_sid2, ''OK''); PLTelemetry.end_span(l_sid1, ''OK''); PLTelemetry.end_trace(l_tid); END;'
    );
    
    plt_perf_test_utils.end_test_suite();
END;
/

-- Test 4: Sync vs Async Performance
-- ============================================================================
BEGIN
    plt_perf_test_utils.start_test_suite('Sync vs Async Performance');
    
    -- Test async mode performance (default)
    PLTelemetry.set_async_mode(TRUE);
    plt_perf_test_utils.time_operation(
        'Async Mode',
        100,
        'DECLARE l_tid VARCHAR2(32); l_sid VARCHAR2(16); BEGIN l_tid := PLTelemetry.start_trace(''test_perf_async''); l_sid := PLTelemetry.start_span(''test_perf_async_span''); PLTelemetry.add_event(l_sid, ''test_perf_async_event''); PLTelemetry.end_span(l_sid, ''OK''); PLTelemetry.end_trace(l_tid); END;'
    );
    
    -- Test sync mode performance (will try to send to backend)
    PLTelemetry.set_async_mode(FALSE);
    PLTelemetry.set_backend_url('http://localhost:3000/api/telemetry');  -- Use a realistic URL
    plt_perf_test_utils.time_operation(
        'Sync Mode',
        10,  -- Fewer iterations due to network calls
        'DECLARE l_tid VARCHAR2(32); l_sid VARCHAR2(16); BEGIN l_tid := PLTelemetry.start_trace(''test_perf_sync''); l_sid := PLTelemetry.start_span(''test_perf_sync_span''); PLTelemetry.add_event(l_sid, ''test_perf_sync_event''); PLTelemetry.end_span(l_sid, ''OK''); PLTelemetry.end_trace(l_tid); END;'
    );
    
    -- Reset to async for remaining tests
    PLTelemetry.set_async_mode(TRUE);
    
    plt_perf_test_utils.end_test_suite();
END;
/

-- Test 5: Business Logic Overhead
-- ============================================================================
BEGIN
    plt_perf_test_utils.start_test_suite('Business Logic Overhead');
    
    -- Create a simple business function for testing
    EXECUTE IMMEDIATE '
    CREATE OR REPLACE FUNCTION test_business_function(p_input NUMBER) RETURN NUMBER IS
        l_result NUMBER;
    BEGIN
        -- Simulate business logic
        l_result := p_input;
        FOR i IN 1..10 LOOP
            l_result := l_result + (i * 0.1);
        END LOOP;
        l_result := SQRT(l_result * 1.5);
        RETURN ROUND(l_result, 2);
    END;';
    
    -- Test business function without telemetry
    plt_perf_test_utils.time_operation_with_baseline(
        'Business Function w/ Telemetry',
        200,
        'DECLARE l_tid VARCHAR2(32); l_sid VARCHAR2(16); l_result NUMBER; BEGIN l_tid := PLTelemetry.start_trace(''test_perf_business''); l_sid := PLTelemetry.start_span(''test_perf_business_func''); l_result := test_business_function(42); PLTelemetry.log_metric(''test_perf_result'', l_result, ''units''); PLTelemetry.end_span(l_sid, ''OK''); PLTelemetry.end_trace(l_tid); END;',
        'DECLARE l_result NUMBER; BEGIN l_result := test_business_function(42); END;'
    );
    
    -- Test database operation with telemetry overhead
    plt_perf_test_utils.time_operation_with_baseline(
        'DB Query w/ Telemetry',
        100,
        'DECLARE l_tid VARCHAR2(32); l_sid VARCHAR2(16); l_count NUMBER; l_attrs PLTelemetry.t_attributes; BEGIN l_tid := PLTelemetry.start_trace(''test_perf_db''); l_sid := PLTelemetry.start_span(''test_perf_db_query''); l_attrs(1) := PLTelemetry.add_attribute(PLTelemetry.C_ATTR_DB_OPERATION, ''SELECT''); SELECT COUNT(*) INTO l_count FROM user_tables; PLTelemetry.log_metric(''test_perf_table_count'', l_count, ''tables'', l_attrs); PLTelemetry.end_span(l_sid, ''OK'', l_attrs); PLTelemetry.end_trace(l_tid); END;',
        'DECLARE l_count NUMBER; BEGIN SELECT COUNT(*) INTO l_count FROM user_tables; END;'
    );
    
    -- Clean up test function
    EXECUTE IMMEDIATE 'DROP FUNCTION test_business_function';
    
    plt_perf_test_utils.end_test_suite();
END;
/

-- Test 6: Queue Processing Performance
-- ============================================================================
BEGIN
    plt_perf_test_utils.start_test_suite('Queue Processing Performance');
    
    DECLARE
        l_queue_count_before NUMBER;
        l_queue_count_after NUMBER;
        l_start_time NUMBER;
        l_end_time NUMBER;
        l_processing_time NUMBER;
    BEGIN
        -- Ensure async mode and create some queue entries
        PLTelemetry.set_async_mode(TRUE);
        
        -- Create test data in queue
        FOR i IN 1..50 LOOP
            DECLARE
                l_tid VARCHAR2(32);
                l_sid VARCHAR2(16);
            BEGIN
                l_tid := PLTelemetry.start_trace('test_perf_queue_' || i);
                l_sid := PLTelemetry.start_span('test_perf_queue_span_' || i);
                PLTelemetry.add_event(l_sid, 'test_perf_queue_event_' || i);
                PLTelemetry.end_span(l_sid, 'OK');
                PLTelemetry.end_trace(l_tid);
            END;
        END LOOP;
        
        -- Get queue count before processing
        SELECT COUNT(*) INTO l_queue_count_before FROM plt_queue WHERE processed = 'N';
        
        -- Time the queue processing
        l_start_time := plt_perf_test_utils.get_timestamp_ms();
        PLTelemetry.process_queue(25);  -- Process 25 entries
        l_end_time := plt_perf_test_utils.get_timestamp_ms();
        
        l_processing_time := l_end_time - l_start_time;
        
        -- Get queue count after processing
        SELECT COUNT(*) INTO l_queue_count_after FROM plt_queue WHERE processed = 'N';
        
        DBMS_OUTPUT.PUT_LINE('Queue Processing Results:');
        DBMS_OUTPUT.PUT_LINE('  Entries before: ' || l_queue_count_before);
        DBMS_OUTPUT.PUT_LINE('  Entries after: ' || l_queue_count_after);
        DBMS_OUTPUT.PUT_LINE('  Entries processed: ' || (l_queue_count_before - l_queue_count_after));
        DBMS_OUTPUT.PUT_LINE('  Processing time: ' || ROUND(l_processing_time, 2) || 'ms');
        
        IF (l_queue_count_before - l_queue_count_after) > 0 THEN
            DBMS_OUTPUT.PUT_LINE('  Time per entry: ' || 
                ROUND(l_processing_time / (l_queue_count_before - l_queue_count_after), 2) || 'ms');
        END IF;
    END;
    
    plt_perf_test_utils.end_test_suite();
END;
/

-- Test 7: Memory Usage Patterns
-- ============================================================================
BEGIN
    plt_perf_test_utils.start_test_suite('Memory Usage Patterns');
    
    -- Test large trace with many spans
    plt_perf_test_utils.time_operation(
        'Large Trace (50 spans)',
        5,
        'DECLARE l_tid VARCHAR2(32); l_sid VARCHAR2(16); BEGIN l_tid := PLTelemetry.start_trace(''test_perf_large_trace''); FOR i IN 1..50 LOOP l_sid := PLTelemetry.start_span(''test_perf_span_'' || i); PLTelemetry.add_event(l_sid, ''test_perf_event_'' || i); PLTelemetry.end_span(l_sid, ''OK''); END LOOP; PLTelemetry.end_trace(l_tid); END;'
    );
    
    -- Test many concurrent traces
    plt_perf_test_utils.time_operation(
        'Many Small Traces (20 traces)',
        10,
        'DECLARE l_tid VARCHAR2(32); l_sid VARCHAR2(16); BEGIN FOR i IN 1..20 LOOP l_tid := PLTelemetry.start_trace(''test_perf_small_trace_'' || i); l_sid := PLTelemetry.start_span(''test_perf_small_span_'' || i); PLTelemetry.end_span(l_sid, ''OK''); PLTelemetry.end_trace(l_tid); END LOOP; END;'
    );
    
    plt_perf_test_utils.end_test_suite();
END;
/

-- Test 8: Configuration Impact
-- ============================================================================
BEGIN
    plt_perf_test_utils.start_test_suite('Configuration Impact');
    
    -- Test with autocommit enabled
    PLTelemetry.set_autocommit(TRUE);
    plt_perf_test_utils.time_operation(
        'With Autocommit',
        50,
        'DECLARE l_tid VARCHAR2(32); l_sid VARCHAR2(16); BEGIN l_tid := PLTelemetry.start_trace(''test_perf_autocommit''); l_sid := PLTelemetry.start_span(''test_perf_autocommit_span''); PLTelemetry.end_span(l_sid, ''OK''); PLTelemetry.end_trace(l_tid); END;'
    );
    
    -- Test with autocommit disabled
    PLTelemetry.set_autocommit(FALSE);
    plt_perf_test_utils.time_operation(
        'Without Autocommit',
        50,
        'DECLARE l_tid VARCHAR2(32); l_sid VARCHAR2(16); BEGIN l_tid := PLTelemetry.start_trace(''test_perf_no_autocommit''); l_sid := PLTelemetry.start_span(''test_perf_no_autocommit_span''); PLTelemetry.end_span(l_sid, ''OK''); PLTelemetry.end_trace(l_tid); END;'
    );
    
    plt_perf_test_utils.end_test_suite();
END;
/

-- Performance Test Summary and Recommendations
-- ============================================================================
PROMPT
PROMPT ================================================================================
PROMPT Performance Test Summary and Recommendations
PROMPT ================================================================================

DECLARE
    l_total_traces NUMBER;
    l_total_spans NUMBER;
    l_total_events NUMBER;
    l_total_metrics NUMBER;
    l_queue_size NUMBER;
    l_avg_span_duration NUMBER;
BEGIN
    -- Gather performance statistics
    SELECT COUNT(*) INTO l_total_traces FROM plt_traces WHERE root_operation LIKE 'test_perf_%';
    SELECT COUNT(*) INTO l_total_spans FROM plt_spans WHERE operation_name LIKE 'test_perf_%';
    SELECT COUNT(*) INTO l_total_events FROM plt_events WHERE event_name LIKE 'test_perf_%';
    SELECT COUNT(*) INTO l_total_metrics FROM plt_metrics WHERE metric_name LIKE 'test_perf_%';
    SELECT COUNT(*) INTO l_queue_size FROM plt_queue WHERE processed = 'N';
    
    -- Calculate average span duration for completed spans
    SELECT ROUND(AVG(duration_ms), 2) INTO l_avg_span_duration
    FROM plt_spans 
    WHERE operation_name LIKE 'test_perf_%' AND duration_ms IS NOT NULL;
    
    DBMS_OUTPUT.PUT_LINE('Performance Test Data Generated:');
    DBMS_OUTPUT.PUT_LINE('  Traces created: ' || l_total_traces);
    DBMS_OUTPUT.PUT_LINE('  Spans created: ' || l_total_spans);
    DBMS_OUTPUT.PUT_LINE('  Events created: ' || l_total_events);
    DBMS_OUTPUT.PUT_LINE('  Metrics recorded: ' || l_total_metrics);
    DBMS_OUTPUT.PUT_LINE('  Queue entries pending: ' || l_queue_size);
    DBMS_OUTPUT.PUT_LINE('  Avg span duration: ' || NVL(TO_CHAR(l_avg_span_duration), 'N/A') || 'ms');
    
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Performance Recommendations:');
    DBMS_OUTPUT.PUT_LINE('');
    
    DBMS_OUTPUT.PUT_LINE('✓ OPTIMAL SETTINGS:');
    DBMS_OUTPUT.PUT_LINE('  • Use async mode (PLTelemetry.set_async_mode(TRUE))');
    DBMS_OUTPUT.PUT_LINE('  • Disable autocommit for batch operations');
    DBMS_OUTPUT.PUT_LINE('  • Limit attributes to 10-15 per span for best performance');
    DBMS_OUTPUT.PUT_LINE('  • Process queue regularly (every 1-5 minutes)');
    DBMS_OUTPUT.PUT_LINE('');
    
    DBMS_OUTPUT.PUT_LINE('⚠ PERFORMANCE CONSIDERATIONS:');
    DBMS_OUTPUT.PUT_LINE('  • Sync mode adds network latency to critical path');
    DBMS_OUTPUT.PUT_LINE('  • Deep nesting (>5 levels) increases overhead');
    DBMS_OUTPUT.PUT_LINE('  • Large attribute collections (>20) slow JSON conversion');
    DBMS_OUTPUT.PUT_LINE('  • Autocommit enabled increases transaction overhead');
    DBMS_OUTPUT.PUT_LINE('');
    
    DBMS_OUTPUT.PUT_LINE('🎯 PRODUCTION TUNING:');
    DBMS_OUTPUT.PUT_LINE('  • Monitor queue size and processing rates');
    DBMS_OUTPUT.PUT_LINE('  • Adjust queue processor frequency based on load');
    DBMS_OUTPUT.PUT_LINE('  • Use connection pooling for backend HTTP calls');
    DBMS_OUTPUT.PUT_LINE('  • Implement circuit breakers for backend failures');
    DBMS_OUTPUT.PUT_LINE('  • Set appropriate retention policies for data cleanup');
    
    -- Performance thresholds
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('📊 EXPECTED PERFORMANCE THRESHOLDS:');
    DBMS_OUTPUT.PUT_LINE('  • Trace creation: < 5ms');
    DBMS_OUTPUT.PUT_LINE('  • Span creation: < 3ms');
    DBMS_OUTPUT.PUT_LINE('  • Event creation: < 2ms');
    DBMS_OUTPUT.PUT_LINE('  • Metric recording: < 3ms');
    DBMS_OUTPUT.PUT_LINE('  • Business logic overhead: < 10%');
    DBMS_OUTPUT.PUT_LINE('  • Queue processing: < 50ms per entry');
END;
/

-- Cleanup performance test data
PROMPT
PROMPT Cleaning up performance test data...
BEGIN
    plt_perf_test_utils.cleanup_test_data();
    DBMS_OUTPUT.PUT_LINE('✓ Performance test data cleaned up');
END;
/

-- Drop test utilities
DROP PACKAGE plt_perf_test_utils;

PROMPT
PROMPT ================================================================================
PROMPT Performance Tests Completed
PROMPT ================================================================================
PROMPT
PROMPT PLTelemetry performance characteristics have been measured:
PROMPT ✓ Basic operation timings
PROMPT ✓ Attribute processing performance
PROMPT ✓ Nested span overhead
PROMPT ✓ Sync vs async mode comparison
PROMPT ✓ Business logic overhead assessment
PROMPT ✓ Queue processing efficiency
PROMPT ✓ Memory usage patterns
PROMPT ✓ Configuration impact analysis
PROMPT
PROMPT The telemetry system is designed for minimal overhead in production
PROMPT environments when properly configured with async mode enabled.
PROMPT
PROMPT Use the recommendations above to optimize PLTelemetry for your
PROMPT specific workload and performance requirements.
PROMPT
PROMPT ================================================================================
[END OF FILE: tests/test_performance.sql]


========================================================================
FILE: bridges/postgresql/oracle/src/PLT_POSTGRES_BRIDGE.pks
SIZE: 3542 bytes
MODIFIED: ./bridges/postgresql/oracle/src/PLT_POSTGRES_BRIDGE.pks 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550530 1550530 18446744073709551615 -1
2025-06-23 14:05:06.404518700
========================================================================

CREATE OR REPLACE PACKAGE PLT_POSTGRES_BRIDGE
AS
    /**
     * PLT_POSTGRES_BRIDGE - PostgreSQL/PostgREST Adapter for PLTelemetry
     *
     * This package provides PostgreSQL-specific implementations for PLTelemetry,
     * transforming generic telemetry data into PostgREST-compatible format.
     *
     * Version: 1.0
     * Dependencies: PLTelemetry, UTL_HTTP
     */

    --------------------------------------------------------------------------
    -- CONFIGURATION
    --------------------------------------------------------------------------

    -- PostgREST endpoints
    g_postgrest_base_url   VARCHAR2 (500) := 'http://localhost:3000';
    g_api_key              VARCHAR2 (100) := 'your-api-key';
    g_timeout              NUMBER := 30;

    --------------------------------------------------------------------------
    -- MAIN PROCEDURES
    --------------------------------------------------------------------------

    /**
     * Sends trace data to PostgreSQL via PostgREST
     * Transforms generic PLTelemetry format to PostgreSQL-specific format
     *
     * @param p_trace_id The trace ID
     * @param p_operation Root operation name
     * @param p_start_time Trace start timestamp
     * @param p_service_name Service name (default: 'oracle-plsql')
     */
    PROCEDURE send_trace_to_postgres (p_trace_id        VARCHAR2,
                                      p_operation       VARCHAR2,
                                      p_start_time      TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP,
                                      p_service_name    VARCHAR2 DEFAULT 'oracle-plsql');

    /**
     * Sends span data to PostgreSQL via PostgREST
     * Transforms from generic format to PostgreSQL-specific
     *
     * @param p_generic_json Generic span JSON from PLTelemetry
     */
    PROCEDURE send_span_to_postgres (p_generic_json VARCHAR2);

    /**
     * Sends metric data to PostgreSQL via PostgREST
     * Transforms from generic format to PostgreSQL-specific
     *
     * @param p_generic_json Generic metric JSON from PLTelemetry
     */
    PROCEDURE send_metric_to_postgres (p_generic_json VARCHAR2);

    /**
     * Interceptor for PLTelemetry.send_to_backend
     * Routes telemetry data to appropriate PostgreSQL endpoint
     *
     * @param p_json Generic JSON from PLTelemetry
     */
    PROCEDURE route_to_postgres (p_json VARCHAR2);

    /**
     * Enhanced start_trace that sends to both Oracle and PostgreSQL
     * Use this instead of PLTelemetry.start_trace for PostgreSQL integration
     *
     * @param p_operation The operation name
     * @return The generated trace ID
     */
    FUNCTION start_trace_with_postgres (p_operation VARCHAR2)
        RETURN VARCHAR2;

    /**
     * Main routing procedure to intercept PLTelemetry backend calls
     * This should replace PLTelemetry.send_to_backend when using PostgreSQL
     *
     * @param p_json JSON payload from PLTelemetry
     */
    PROCEDURE send_to_backend_with_routing (p_json VARCHAR2);

    --------------------------------------------------------------------------
    -- CONFIGURATION PROCEDURES
    --------------------------------------------------------------------------

    PROCEDURE set_postgrest_url (p_url VARCHAR2);

    PROCEDURE set_api_key (p_key VARCHAR2);

    PROCEDURE set_timeout (p_timeout NUMBER);

    FUNCTION escape_json_string (p_input VARCHAR2)
        RETURN VARCHAR2;
END PLT_POSTGRES_BRIDGE;
/
[END OF FILE: bridges/postgresql/oracle/src/PLT_POSTGRES_BRIDGE.pks]


========================================================================
FILE: src/PLTelemetry.pks
SIZE: 9196 bytes
MODIFIED: ./src/PLTelemetry.pks 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550529 1550529 18446744073709551615 -1
2025-06-23 06:16:29.796155800
========================================================================

CREATE OR REPLACE PACKAGE PLTelemetry
AS
   -- OpenTelemetry SDK for PL/SQL
   -- Version: 0.1
   -- Description: Provides distributed tracing capabilities for PL/SQL applications
   --              following OpenTelemetry standards

   --------------------------------------------------------------------------
   -- TYPE DEFINITIONS
   --------------------------------------------------------------------------
   
   -- Collection type for storing key-value attributes
   -- Each attribute should be in format 'key=value'
   TYPE t_attributes IS TABLE OF VARCHAR2 (4000)
       INDEX BY BINARY_INTEGER;

   --------------------------------------------------------------------------
   -- CONSTANTS
   --------------------------------------------------------------------------
   
   -- Standard OpenTelemetry semantic conventions for HTTP
   C_ATTR_HTTP_METHOD     CONSTANT VARCHAR2 (30) := 'http.method';
   C_ATTR_HTTP_URL        CONSTANT VARCHAR2 (30) := 'http.url';
   C_ATTR_HTTP_STATUS     CONSTANT VARCHAR2 (30) := 'http.status_code';
   
   -- Standard OpenTelemetry semantic conventions for database
   C_ATTR_DB_OPERATION    CONSTANT VARCHAR2 (30) := 'db.operation';
   C_ATTR_DB_STATEMENT    CONSTANT VARCHAR2 (30) := 'db.statement';
   
   -- Standard OpenTelemetry semantic conventions for user
   C_ATTR_USER_ID         CONSTANT VARCHAR2 (30) := 'user.id';
   C_ATTR_ERROR_MESSAGE   CONSTANT VARCHAR2 (30) := 'error.message';

   -- Span kind constants following OpenTelemetry specification
   C_SPAN_KIND_INTERNAL   CONSTANT VARCHAR2 (10) := 'INTERNAL';
   C_SPAN_KIND_SERVER     CONSTANT VARCHAR2 (10) := 'SERVER';
   C_SPAN_KIND_CLIENT     CONSTANT VARCHAR2 (10) := 'CLIENT';
   C_SPAN_KIND_PRODUCER   CONSTANT VARCHAR2 (10) := 'PRODUCER';
   C_SPAN_KIND_CONSUMER   CONSTANT VARCHAR2 (10) := 'CONSUMER';

   --------------------------------------------------------------------------
   -- GLOBAL VARIABLES
   --------------------------------------------------------------------------
   
   -- Current trace context
   g_current_trace_id              VARCHAR2 (32);
   g_current_span_id               VARCHAR2 (16);

   -- Configuration parameters
   g_autocommit                    BOOLEAN := FALSE;                        -- Control auto-commit behavior
   g_backend_url                   VARCHAR2 (500) := 'http://your-backend:3000/plsql-otel/telemetry';
   g_backend_timeout               NUMBER := 30;                            -- Timeout in seconds
   g_api_key                       VARCHAR2 (100) := 'your-secret-api-key'; -- API key for authentication
   g_async_mode                    BOOLEAN := TRUE;                         -- Enable async by default

   --------------------------------------------------------------------------
   -- CORE TRACING FUNCTIONS
   --------------------------------------------------------------------------
   
   /**
    * Starts a new trace with the given operation name
    *
    * @param p_operation The name of the operation being traced
    * @return The generated trace ID (32 character hex string)
    * @example
    *   l_trace_id := PLTelemetry.start_trace('process_order');
    */
   FUNCTION start_trace (p_operation VARCHAR2)
       RETURN VARCHAR2;
       
   /**
     * Ends the current trace and clears context
     * 
     * @param p_trace_id Optional trace ID to end (uses current if not provided)
     */
    PROCEDURE end_trace(p_trace_id VARCHAR2 DEFAULT NULL);

   /**
    * Starts a new span within a trace
    *
    * @param p_operation The name of the operation for this span
    * @param p_parent_span_id Optional parent span ID for nested spans
    * @param p_trace_id Optional trace ID (uses current if not provided)
    * @return The generated span ID (16 character hex string)
    * @example
    *   l_span_id := PLTelemetry.start_span('validate_customer');
    */
   FUNCTION start_span (
       p_operation VARCHAR2, 
       p_parent_span_id VARCHAR2 DEFAULT NULL, 
       p_trace_id VARCHAR2 DEFAULT NULL
   ) RETURN VARCHAR2;

   /**
    * Ends an active span and records its duration
    *
    * @param p_span_id The ID of the span to end
    * @param p_status The final status of the span (OK, ERROR, etc.)
    * @param p_attributes Additional attributes to attach to the span
    * @example
    *   PLTelemetry.end_span(l_span_id, 'OK');
    */
   PROCEDURE end_span (
       p_span_id VARCHAR2, 
       p_status VARCHAR2 DEFAULT 'OK', 
       p_attributes t_attributes DEFAULT t_attributes ()
   );

   /**
    * Adds an event to an active span
    *
    * @param p_span_id The ID of the span to add the event to
    * @param p_event_name The name of the event
    * @param p_attributes Optional attributes for the event
    * @example
    *   PLTelemetry.add_event(l_span_id, 'payment_processed');
    */
   PROCEDURE add_event (
       p_span_id VARCHAR2, 
       p_event_name VARCHAR2, 
       p_attributes t_attributes DEFAULT t_attributes ()
   );

   /**
    * Records a metric value with associated metadata
    *
    * @param p_metric_name The name of the metric
    * @param p_value The numeric value of the metric
    * @param p_unit Optional unit of measurement
    * @param p_attributes Optional attributes for the metric
    * @example
    *   PLTelemetry.log_metric('order_total', 299.99, 'USD');
    */
   PROCEDURE log_metric (
       p_metric_name VARCHAR2,
       p_value NUMBER,
       p_unit VARCHAR2 DEFAULT NULL,
       p_attributes t_attributes DEFAULT t_attributes ()
   );

   --------------------------------------------------------------------------
   -- UTILITY FUNCTIONS
   --------------------------------------------------------------------------
   
   /**
    * Creates a key-value attribute string with proper escaping
    *
    * @param p_key The attribute key
    * @param p_value The attribute value
    * @return Escaped key=value string
    * @example
    *   l_attr := PLTelemetry.add_attribute('user.id', '12345');
    */
   FUNCTION add_attribute (p_key VARCHAR2, p_value VARCHAR2)
       RETURN VARCHAR2;

   /**
    * Converts an attributes collection to JSON format
    *
    * @param p_attributes Collection of key=value attributes
    * @return JSON string representation of attributes
    * @example
    *   l_json := PLTelemetry.attributes_to_json(l_attributes);
    */
   FUNCTION attributes_to_json (p_attributes t_attributes)
       RETURN VARCHAR2;

   /**
    * Sends telemetry data to the configured backend
    *
    * @param p_json JSON payload to send
    * @note Uses async mode by default, falls back to sync on failure
    */
   PROCEDURE send_to_backend (p_json VARCHAR2);

   /**
    * Sets the current trace context in Oracle session info
    *
    * @note Uses DBMS_APPLICATION_INFO for visibility in V$SESSION
    */
   PROCEDURE set_trace_context;

   /**
    * Clears the current trace context from session
    */
   PROCEDURE clear_trace_context;

   /**
    * Processes queued telemetry data in batches
    *
    * @param p_batch_size Number of queue entries to process (default 100)
    * @note Should be called periodically by a scheduled job
    * @example
    *   PLTelemetry.process_queue(500);
    */
   PROCEDURE process_queue (p_batch_size NUMBER DEFAULT 100);

   --------------------------------------------------------------------------
   -- CONFIGURATION GETTERS AND SETTERS
   --------------------------------------------------------------------------
   
   /**
    * Sets the auto-commit mode for telemetry operations
    *
    * @param p_value TRUE to enable auto-commit, FALSE to disable
    */
   PROCEDURE set_autocommit (p_value BOOLEAN);

   /**
    * Gets the current auto-commit mode setting
    *
    * @return Current auto-commit setting
    */
   FUNCTION get_autocommit
       RETURN BOOLEAN;

   /**
    * Sets the backend URL for telemetry export
    *
    * @param p_url The HTTP endpoint URL
    */
   PROCEDURE set_backend_url (p_url VARCHAR2);

   /**
    * Gets the current backend URL
    *
    * @return Current backend URL
    */
   FUNCTION get_backend_url
       RETURN VARCHAR2;

   /**
    * Sets the API key for backend authentication
    *
    * @param p_key The API key string
    */
   PROCEDURE set_api_key (p_key VARCHAR2);

   /**
    * Sets the HTTP timeout for backend calls
    *
    * @param p_timeout Timeout in seconds
    */
   PROCEDURE set_backend_timeout (p_timeout NUMBER);

   /**
    * Sets the async processing mode
    *
    * @param p_async TRUE for async mode, FALSE for synchronous
    */
   PROCEDURE set_async_mode (p_async BOOLEAN);

   /**
    * Gets the current trace ID
    *
    * @return Current trace ID or NULL if no active trace
    */
   FUNCTION get_current_trace_id
       RETURN VARCHAR2;

   /**
    * Gets the current span ID
    *
    * @return Current span ID or NULL if no active span
    */
   FUNCTION get_current_span_id
       RETURN VARCHAR2;

END PLTelemetry;
/
[END OF FILE: src/PLTelemetry.pks]


========================================================================
FILE: bridges/postgresql/oracle/src/PLT_POSTGRES_BRIDGE.pkb
SIZE: 9831 bytes
MODIFIED: ./bridges/postgresql/oracle/src/PLT_POSTGRES_BRIDGE.pkb 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550526 1550526 18446744073709551615 -1
2025-06-23 14:05:15.050888100
========================================================================

CREATE OR REPLACE PACKAGE BODY PLT_POSTGRES_BRIDGE
AS
   --------------------------------------------------------------------------
   -- PRIVATE HELPERS
   --------------------------------------------------------------------------
   
   /**
    * Escapa caracteres especiales para JSON válido
    */
   FUNCTION escape_json_string(p_input VARCHAR2)
   RETURN VARCHAR2
   IS
       l_output VARCHAR2(4000);
   BEGIN
       IF p_input IS NULL THEN
           RETURN NULL;
       END IF;
       
       l_output := p_input;
       
       -- Importante: escapar backslash PRIMERO
       l_output := REPLACE(l_output, '\', '\\');
       l_output := REPLACE(l_output, '"', '\"');
       l_output := REPLACE(l_output, CHR(10), '\n');
       l_output := REPLACE(l_output, CHR(13), '\r');
       l_output := REPLACE(l_output, CHR(9), '\t');
       l_output := REPLACE(l_output, CHR(8), '\b');
       l_output := REPLACE(l_output, CHR(12), '\f');
       
       RETURN l_output;
   END escape_json_string;
   
   /**
    * Extracts field value from JSON string
    */
   FUNCTION get_json_value (p_json VARCHAR2, p_field VARCHAR2)
       RETURN VARCHAR2
   IS
       l_pattern   VARCHAR2(200);
       l_value     VARCHAR2(4000);
   BEGIN
       -- Pattern for quoted values
       l_pattern := '"' || p_field || '"\s*:\s*"([^"]+)"';
       l_value := REGEXP_SUBSTR(p_json, l_pattern, 1, 1, NULL, 1);
       
       IF l_value IS NOT NULL THEN
           RETURN l_value;
       END IF;
       
       -- Pattern for numeric values
       l_pattern := '"' || p_field || '"\s*:\s*([0-9.]+)';
       l_value := REGEXP_SUBSTR(p_json, l_pattern, 1, 1, NULL, 1);
       
       RETURN l_value;
   END get_json_value;

   /**
    * Sends HTTP POST request to PostgREST endpoint
    */
   PROCEDURE send_http_post (p_endpoint VARCHAR2, p_json VARCHAR2)
   IS
       l_req    UTL_HTTP.REQ;
       l_res    UTL_HTTP.RESP;
       l_url    VARCHAR2(600);
       l_response VARCHAR2(32767);
       l_buffer   VARCHAR2(32767);
   BEGIN
       l_url := g_postgrest_base_url || p_endpoint;
       
       UTL_HTTP.SET_TRANSFER_TIMEOUT(g_timeout);
       
       l_req := UTL_HTTP.BEGIN_REQUEST(l_url, 'POST', 'HTTP/1.1');
       UTL_HTTP.SET_HEADER(l_req, 'Content-Type', 'application/json; charset=utf-8');
       UTL_HTTP.SET_HEADER(l_req, 'Content-Length', LENGTHB(p_json));
       
       -- Solo agregar API key si está configurada
       IF g_api_key IS NOT NULL THEN
           UTL_HTTP.SET_HEADER(l_req, 'X-API-Key', g_api_key);
       END IF;
       
       UTL_HTTP.WRITE_TEXT(l_req, p_json);
       
       l_res := UTL_HTTP.GET_RESPONSE(l_req);
       
       IF l_res.status_code NOT IN (200, 201, 202, 204) THEN
           -- Capturar respuesta de error
           BEGIN
               LOOP
                   UTL_HTTP.READ_TEXT(l_res, l_buffer, 32767);
                   l_response := l_response || l_buffer;
               END LOOP;
           EXCEPTION
               WHEN UTL_HTTP.END_OF_BODY THEN
                   NULL;
           END;
           
           -- Log error detallado
           INSERT INTO plt_telemetry_errors (
               error_time, 
               error_message, 
               module_name
           ) VALUES (
               SYSTIMESTAMP,
               'PostgreSQL bridge HTTP ' || l_res.status_code || 
               ' for ' || p_endpoint || 
               '. Response: ' || SUBSTR(l_response, 1, 3000),
               'PLT_POSTGRES_BRIDGE'
           );
           
           IF PLTelemetry.get_autocommit THEN
               COMMIT;
           END IF;
       END IF;
       
       UTL_HTTP.END_RESPONSE(l_res);
       
   EXCEPTION
       WHEN OTHERS THEN
           BEGIN
               IF l_res.status_code IS NOT NULL THEN
                   UTL_HTTP.END_RESPONSE(l_res);
               END IF;
           EXCEPTION
               WHEN OTHERS THEN NULL;
           END;
           
           -- Log but don't propagate
           INSERT INTO plt_telemetry_errors (
               error_time, 
               error_message, 
               module_name
           ) VALUES (
               SYSTIMESTAMP,
               'PostgreSQL bridge error: ' || SUBSTR(DBMS_UTILITY.format_error_stack|| ' - '|| DBMS_UTILITY.format_error_backtrace, 1, 3000),
               'PLT_POSTGRES_BRIDGE.send_http_post'
           );
           
           IF PLTelemetry.get_autocommit THEN
               COMMIT;
           END IF;
   END send_http_post;

   --------------------------------------------------------------------------
   -- PUBLIC PROCEDURES
   --------------------------------------------------------------------------
   
   PROCEDURE send_trace_to_postgres (
       p_trace_id       VARCHAR2,
       p_operation      VARCHAR2,
       p_start_time     TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP,
       p_service_name   VARCHAR2 DEFAULT 'oracle-plsql'
   )
   IS
       l_json VARCHAR2(4000);
       l_service_instance VARCHAR2(500);
   BEGIN
       -- Construir y escapar service_instance
       l_service_instance := escape_json_string(
           SYS_CONTEXT('USERENV', 'HOST') || ':' || 
           SYS_CONTEXT('USERENV', 'INSTANCE_NAME')
       );
       
       -- Build PostgreSQL-specific JSON con escape
       l_json := '{'
           || '"trace_id":"' || p_trace_id || '",'
           || '"root_operation":"' || escape_json_string(p_operation) || '",'
           || '"start_time":"' || TO_CHAR(p_start_time, 'YYYY-MM-DD"T"HH24:MI:SS.FF3"Z"') || '",'
           || '"service_name":"' || escape_json_string(p_service_name) || '",'
           || '"service_instance":"' || l_service_instance || '"'
           || '}';
       
       send_http_post('/traces', l_json);
   END send_trace_to_postgres;

   PROCEDURE send_span_to_postgres (p_generic_json VARCHAR2)
   IS
       l_json           VARCHAR2(32767);
       l_operation      VARCHAR2(255);
   BEGIN
       -- Extract values from generic JSON
       l_operation := get_json_value(p_generic_json, 'operation');
       
       -- Transform to PostgreSQL format con escape
       l_json := '{'
           || '"trace_id":"' || get_json_value(p_generic_json, 'trace_id') || '",'
           || '"span_id":"' || get_json_value(p_generic_json, 'span_id') || '",'
           || '"operation_name":"' || escape_json_string(l_operation) || '",'
           || '"start_time":"' || get_json_value(p_generic_json, 'start_time') || '",'
           || '"end_time":"' || get_json_value(p_generic_json, 'end_time') || '",'
           || '"duration_ms":' || NVL(get_json_value(p_generic_json, 'duration_ms'), '0') || ','
           || '"status":"' || get_json_value(p_generic_json, 'status') || '"'
           || '}';
       
       send_http_post('/spans', l_json);
   END send_span_to_postgres;

   PROCEDURE send_metric_to_postgres (p_generic_json VARCHAR2)
   IS
       l_json   VARCHAR2(32767);
   BEGIN
       -- Transform from generic to PostgreSQL format con escape
       l_json := '{'
           || '"metric_name":"' || escape_json_string(get_json_value(p_generic_json, 'name')) || '",'
           || '"metric_value":' || get_json_value(p_generic_json, 'value') || ','
           || '"metric_unit":"' || escape_json_string(get_json_value(p_generic_json, 'unit')) || '",'
           || '"timestamp":"' || get_json_value(p_generic_json, 'timestamp') || '",'
           || '"trace_id":"' || get_json_value(p_generic_json, 'trace_id') || '",'
           || '"span_id":"' || get_json_value(p_generic_json, 'span_id') || '"'
           || '}';
       
       send_http_post('/metrics', l_json);
   END send_metric_to_postgres;

   -- Resto de procedimientos sin cambios...
   
   PROCEDURE route_to_postgres (p_json VARCHAR2)
   IS
       l_trace_id   VARCHAR2(32);
       l_span_id    VARCHAR2(16);
       l_name       VARCHAR2(255);
   BEGIN
       l_trace_id := get_json_value(p_json, 'trace_id');
       l_span_id := get_json_value(p_json, 'span_id');
       l_name := get_json_value(p_json, 'name');
       
       IF l_name IS NOT NULL THEN
           send_metric_to_postgres(p_json);
       ELSIF l_span_id IS NOT NULL AND get_json_value(p_json, 'duration_ms') IS NOT NULL THEN
           send_span_to_postgres(p_json);
       ELSIF l_trace_id IS NOT NULL AND get_json_value(p_json, 'root_operation') IS NOT NULL THEN
           send_http_post('/traces', p_json);
       END IF;
   END route_to_postgres;

   FUNCTION start_trace_with_postgres (p_operation VARCHAR2)
       RETURN VARCHAR2
   IS
       l_trace_id VARCHAR2(32);
   BEGIN
       l_trace_id := PLTelemetry.start_trace(p_operation);
       
       send_trace_to_postgres(
           p_trace_id => l_trace_id,
           p_operation => p_operation,
           p_start_time => SYSTIMESTAMP,
           p_service_name => 'oracle-plsql'
       );
       
       RETURN l_trace_id;
   EXCEPTION
       WHEN OTHERS THEN
           RETURN l_trace_id;
   END start_trace_with_postgres;

   PROCEDURE send_to_backend_with_routing (p_json VARCHAR2)
   IS
   BEGIN
       IF PLTelemetry.get_backend_url() = 'POSTGRES_BRIDGE' THEN
           route_to_postgres(p_json);
       ELSE
           PLTelemetry.send_to_backend(p_json);
       END IF;
   END send_to_backend_with_routing;

   PROCEDURE set_postgrest_url (p_url VARCHAR2)
   IS
   BEGIN
       g_postgrest_base_url := p_url;
   END;

   PROCEDURE set_api_key (p_key VARCHAR2)
   IS
   BEGIN
       g_api_key := p_key;
   END;

   PROCEDURE set_timeout (p_timeout NUMBER)
   IS
   BEGIN
       g_timeout := p_timeout;
   END;

END PLT_POSTGRES_BRIDGE;
[END OF FILE: bridges/postgresql/oracle/src/PLT_POSTGRES_BRIDGE.pkb]


========================================================================
FILE: src/PLTelemetry.pkb
SIZE: 52055 bytes
MODIFIED: ./src/PLTelemetry.pkb 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550524 1550524 18446744073709551615 -1
2025-06-23 06:16:29.793162700
========================================================================

CREATE OR REPLACE PACKAGE BODY PLTelemetry
AS
   --------------------------------------------------------------------------
   -- PRIVATE HELPER FUNCTIONS
   --------------------------------------------------------------------------
   
   FUNCTION validate_attribute_key(p_key VARCHAR2) RETURN BOOLEAN IS
    BEGIN
        -- OpenTelemetry attribute naming conventions
        RETURN REGEXP_LIKE(p_key, '^[a-zA-Z][a-zA-Z0-9._]*$')
               AND LENGTH(p_key) <= 255;
    END;
   
   /**
    * Generates a random ID of specified byte length
    * 
    * @param p_bytes Number of bytes (8 or 16)
    * @return Hex string representation of the random ID
    * @private
    */
   FUNCTION generate_id (p_bytes IN NUMBER)
       RETURN VARCHAR2
   IS
       l_random   RAW (16);  -- Max size we'll need
   BEGIN
       -- Validate input
       IF p_bytes NOT IN (8, 16)
       THEN
           RAISE_APPLICATION_ERROR (-20001, 'Size must be 8 or 16 bytes');
       END IF;

       -- Generate random bytes
       l_random := DBMS_CRYPTO.RANDOMBYTES (p_bytes);
       RETURN LOWER (RAWTOHEX (l_random));
   EXCEPTION
       WHEN OTHERS
       THEN
           -- Fallback: SYS_GUID gives us 16 bytes, truncate if needed
           RETURN LOWER (SUBSTR (RAWTOHEX (SYS_GUID ()), 1, p_bytes * 2));
   END generate_id;

   /**
    * Generates a 128-bit trace ID following OpenTelemetry spec
    * 
    * @return 32 character hex string trace ID
    * @private
    */
   FUNCTION generate_trace_id
       RETURN VARCHAR2
   IS
   BEGIN
       RETURN generate_id (16);
   END;

   /**
    * Generates a 64-bit span ID following OpenTelemetry spec
    * 
    * @return 16 character hex string span ID
    * @private
    */
   FUNCTION generate_span_id
       RETURN VARCHAR2
   IS
   BEGIN
       RETURN generate_id (8);
   END;

   /**
    * Sends telemetry data synchronously via HTTP
    * 
    * @param p_json JSON payload to send to backend
    * @private
    */
   PROCEDURE send_to_backend_sync (p_json VARCHAR2)
   IS
       l_req          UTL_HTTP.REQ;
       l_res          UTL_HTTP.RESP;
       l_buffer       VARCHAR2 (32767);
       l_length       NUMBER;
       l_offset       NUMBER := 1;
       l_amount       NUMBER;
       l_error_msg    VARCHAR2 (4000);
       l_error_code   NUMBER;
   BEGIN
       -- Validate input
       IF p_json IS NULL
       THEN
           RETURN;
       END IF;

       -- Get length in characters
       l_length := LENGTH (p_json);

       -- Validate URL before using
       IF g_backend_url IS NULL OR LENGTH (g_backend_url) < 10
       THEN
           -- Log configuration error
           INSERT INTO plt_telemetry_errors (error_time, error_message, module_name)
                VALUES (SYSTIMESTAMP, 'Invalid backend URL configured', 'send_to_backend_sync');

           IF g_autocommit
           THEN
               COMMIT;
           END IF;

           RETURN;
       END IF;

       -- Set timeout with validation
       UTL_HTTP.SET_TRANSFER_TIMEOUT (NVL (g_backend_timeout, 30));

       -- Send to your core-backend
       l_req := UTL_HTTP.BEGIN_REQUEST (g_backend_url, 'POST', 'HTTP/1.1');

       -- Set headers - use LENGTHB for byte count
       UTL_HTTP.SET_HEADER (l_req, 'Content-Type', 'application/json; charset=utf-8');
       UTL_HTTP.SET_HEADER (l_req, 'Content-Length', LENGTHB (p_json));
       UTL_HTTP.SET_HEADER (l_req, 'X-OTel-Source', 'PLTelemetry');
       UTL_HTTP.SET_HEADER (l_req, 'X-PLSQL-API-KEY', NVL (g_api_key, 'not-configured'));
       UTL_HTTP.SET_HEADER (l_req, 'X-PLSQL-DB', SYS_CONTEXT ('USERENV', 'DB_NAME'));

       -- Send VARCHAR2 directly if small enough
       IF l_length <= 32767
       THEN
           UTL_HTTP.WRITE_TEXT (l_req, p_json);
       ELSE
           -- Send in chunks if larger
           WHILE l_offset <= l_length
           LOOP
               l_amount := LEAST (32767, l_length - l_offset + 1);
               l_buffer := SUBSTR (p_json, l_offset, l_amount);
               UTL_HTTP.WRITE_TEXT (l_req, l_buffer);
               l_offset := l_offset + l_amount;
           END LOOP;
       END IF;

       l_res := UTL_HTTP.GET_RESPONSE (l_req);

       -- Check response status
       IF l_res.status_code NOT IN (200, 201, 202, 204)
       THEN
           -- Log failed send with truncated payload
           BEGIN
               INSERT INTO plt_failed_exports (export_time,
                                               http_status,
                                               payload,
                                               error_message)
                    VALUES (SYSTIMESTAMP,
                            l_res.status_code,
                            SUBSTR (p_json, 1, 4000),  -- Truncate payload to avoid overflow
                            'HTTP ' || l_res.status_code || ': ' || SUBSTR (l_res.reason_phrase, 1, 200));

               IF g_autocommit
               THEN
                   COMMIT;
               END IF;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;  -- Don't fail on logging
           END;
       END IF;

       UTL_HTTP.END_RESPONSE (l_res);
   EXCEPTION
       WHEN UTL_HTTP.TRANSFER_TIMEOUT
       THEN
           -- Save error details before any operations
           l_error_msg := 'Backend timeout after ' || NVL (g_backend_timeout, 30) || ' seconds';

           -- Clean up connection if exists
           BEGIN
               IF l_res.status_code IS NOT NULL
               THEN
                   UTL_HTTP.END_RESPONSE (l_res);
               END IF;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;
           END;

           -- Log timeout
           BEGIN
               INSERT INTO plt_failed_exports (export_time, payload, error_message)
                    VALUES (SYSTIMESTAMP, SUBSTR (p_json, 1, 4000), l_error_msg);

               IF g_autocommit
               THEN
                   COMMIT;
               END IF;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;
           END;
       WHEN OTHERS
       THEN
           -- Save error details
           l_error_msg := SUBSTR (SQLERRM, 1, 4000);
           l_error_code := SQLCODE;

           -- Clean up connection if exists
           BEGIN
               IF l_res.status_code IS NOT NULL
               THEN
                   UTL_HTTP.END_RESPONSE (l_res);
               END IF;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;
           END;

           -- Log error but don't fail the business logic
           BEGIN
               INSERT INTO plt_failed_exports (export_time,
                                               payload,
                                               error_message,
                                               http_status)
                    VALUES (SYSTIMESTAMP,
                            SUBSTR (p_json, 1, 4000),
                            'Error (' || l_error_code || '): ' || l_error_msg,
                            -1  -- Indicate non-HTTP error
                              );

               IF g_autocommit
               THEN
                   COMMIT;
               END IF;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;
           END;
   END send_to_backend_sync;

   --------------------------------------------------------------------------
   -- CORE TRACING FUNCTIONS
   --------------------------------------------------------------------------

   /**
    * Starts a new trace with the given operation name
    *
    * @param p_operation The name of the operation being traced
    * @return The generated trace ID (32 character hex string)
    */
   FUNCTION start_trace (p_operation VARCHAR2)
       RETURN VARCHAR2
   IS
       l_trace_id               VARCHAR2 (32);
       l_retry_count            NUMBER := 0;
       l_max_retries   CONSTANT NUMBER := 3;
       l_error_msg              VARCHAR2 (4000);
   BEGIN
       LOOP
           BEGIN
               l_trace_id := generate_trace_id ();
               g_current_trace_id := l_trace_id;

               -- Set context for visibility
               set_trace_context ();

               -- Log trace start
               INSERT INTO plt_traces (trace_id,
                                       root_operation,
                                       start_time,
                                       service_name,
                                       service_instance)
                    VALUES (l_trace_id,
                            p_operation,
                            SYSTIMESTAMP,
                            'oracle-plsql',
                            SYS_CONTEXT ('USERENV', 'HOST') || ':' || SYS_CONTEXT ('USERENV', 'INSTANCE_NAME'));

               -- Paranoid check
               IF SQL%ROWCOUNT != 1
               THEN
                   RAISE_APPLICATION_ERROR (-20001, 'PLTelemetry: Failed to insert trace - rowcount=' || SQL%ROWCOUNT);
               END IF;

               IF g_autocommit
               THEN
                   COMMIT;
               END IF;

               RETURN l_trace_id;  -- Success! Exit function
           EXCEPTION
               WHEN OTHERS
               THEN
                   l_retry_count := l_retry_count + 1;

                   -- Check if it's a DUP_VAL_ON_INDEX (without naming it)
                   IF SQLCODE = -1 AND l_retry_count < l_max_retries
                   THEN
                       -- It's a unique constraint, retry with new ID
                       NULL;  -- Continue loop
                   ELSE
                       -- Any other error or max retries reached
                       BEGIN
                           l_error_msg := SUBSTR (SQLERRM, 1, 4000);

                           INSERT INTO plt_telemetry_errors (error_time, error_message, error_stack)
                                VALUES (SYSTIMESTAMP, l_error_msg, SUBSTR (DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000));

                           IF g_autocommit
                           THEN
                               COMMIT;
                           END IF;
                       EXCEPTION
                           WHEN OTHERS
                           THEN
                               NULL;  -- Give up
                       END;

                       -- Exit loop and return the trace_id anyway
                       RETURN l_trace_id;
                   END IF;
           END;
       END LOOP;
   END start_trace;

    /**
     * Ends the current trace and clears context
     * 
     * @param p_trace_id Optional trace ID to end (uses current if not provided)
     */
    PROCEDURE end_trace(p_trace_id VARCHAR2 DEFAULT NULL) IS
        l_trace_id VARCHAR2(32);
    BEGIN
        l_trace_id := NVL(p_trace_id, g_current_trace_id);
        
        IF l_trace_id IS NOT NULL THEN
            -- Update trace end time if not already set
            UPDATE plt_traces
            SET end_time = SYSTIMESTAMP
            WHERE trace_id = l_trace_id
              AND end_time IS NULL;
            
            -- Clear context if it's the current trace
            IF l_trace_id = g_current_trace_id THEN
                clear_trace_context();
            END IF;
            
            IF g_autocommit THEN
                COMMIT;
            END IF;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            -- Never fail on trace cleanup
            NULL;
    END end_trace;

   /**
    * Starts a new span within a trace
    *
    * @param p_operation The name of the operation for this span
    * @param p_parent_span_id Optional parent span ID for nested spans
    * @param p_trace_id Optional trace ID (uses current if not provided)
    * @return The generated span ID (16 character hex string)
    */
   FUNCTION start_span (p_operation VARCHAR2, p_parent_span_id VARCHAR2 DEFAULT NULL, p_trace_id VARCHAR2 DEFAULT NULL)
       RETURN VARCHAR2
   IS
       l_span_id                VARCHAR2 (16);
       l_trace_id               VARCHAR2 (32);
       l_retry_count            NUMBER := 0;
       l_max_retries   CONSTANT NUMBER := 3;
       l_error_msg              VARCHAR2 (4000);
       l_error_code             NUMBER;
   BEGIN
       LOOP
           BEGIN
               l_span_id := generate_span_id ();
               g_current_span_id := l_span_id;

               -- Use provided trace_id or current one
               l_trace_id := NVL (p_trace_id, NVL (g_current_trace_id, generate_trace_id ()));
               g_current_trace_id := l_trace_id;

               -- Set context for visibility
               set_trace_context ();

               -- Log span start
               INSERT INTO plt_spans (trace_id,
                                      span_id,
                                      parent_span_id,
                                      operation_name,
                                      start_time,
                                      status)
                    VALUES (l_trace_id,
                            l_span_id,
                            p_parent_span_id,
                            p_operation,
                            SYSTIMESTAMP,
                            'RUNNING');

               -- Paranoid check
               IF SQL%ROWCOUNT != 1
               THEN
                   RAISE_APPLICATION_ERROR (-20002, 'PLTelemetry: Failed to insert span - rowcount=' || SQL%ROWCOUNT);
               END IF;

               IF g_autocommit
               THEN
                   COMMIT;
               END IF;

               RETURN l_span_id;  -- Success!
           EXCEPTION
               WHEN OTHERS
               THEN
                   l_retry_count := l_retry_count + 1;

                   -- Check if it's a unique constraint violation
                   IF SQLCODE = -1 AND l_retry_count < l_max_retries
                   THEN
                       -- Retry with new span_id
                       NULL;  -- Continue loop
                   ELSE
                       -- Any other error or max retries reached
                       BEGIN
                           l_error_msg := SUBSTR (SQLERRM, 1, 4000);
                           l_error_code := SQLCODE;

                           INSERT INTO plt_telemetry_errors (error_time,
                                                             error_message,
                                                             error_stack,
                                                             error_code,
                                                             module_name,
                                                             trace_id,
                                                             span_id)
                                VALUES (SYSTIMESTAMP,
                                        l_error_msg,
                                        SUBSTR (DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000),
                                        l_error_code,
                                        'start_span: ' || SUBSTR (p_operation, 1, 80),
                                        l_trace_id,
                                        l_span_id);

                           IF g_autocommit
                           THEN
                               COMMIT;
                           END IF;
                       EXCEPTION
                           WHEN OTHERS
                           THEN
                               NULL;  -- Give up on error logging
                       END;

                       -- Important: still set the context even if DB insert failed
                       g_current_span_id := l_span_id;
                       g_current_trace_id := l_trace_id;

                       -- Return the span_id anyway - telemetry must continue!
                       RETURN l_span_id;
                   END IF;
           END;
       END LOOP;
   END start_span;

   /**
    * Ends an active span and records its duration
    *
    * @param p_span_id The ID of the span to end
    * @param p_status The final status of the span (OK, ERROR, etc.)
    * @param p_attributes Additional attributes to attach to the span
    */
   PROCEDURE end_span (p_span_id VARCHAR2, p_status VARCHAR2 DEFAULT 'OK', p_attributes t_attributes DEFAULT t_attributes ())
   IS
       l_json         VARCHAR2 (32767);
       l_duration     NUMBER;
       l_attrs_json   VARCHAR2 (4000);
       l_start_time   TIMESTAMP WITH TIME ZONE;
       l_error_msg    VARCHAR2 (4000);
       l_error_code   NUMBER;
       l_json_valid   NUMBER;
   BEGIN
       -- Validate input
       IF p_span_id IS NULL
       THEN
           RETURN;  -- Silent fail for null span_id
       END IF;

       BEGIN
           -- Get span info and calculate duration
           SELECT start_time, EXTRACT (SECOND FROM (SYSTIMESTAMP - start_time)) * 1000
             INTO l_start_time, l_duration
             FROM plt_spans
            WHERE span_id = p_span_id;
       EXCEPTION
           WHEN NO_DATA_FOUND
           THEN
               -- Span doesn't exist, log and exit
               BEGIN
                   INSERT INTO plt_telemetry_errors (error_time,
                                                     error_message,
                                                     module_name,
                                                     span_id)
                        VALUES (SYSTIMESTAMP,
                                'end_span: Span not found',
                                'end_span',
                                p_span_id);

                   IF g_autocommit
                   THEN
                       COMMIT;
                   END IF;
               EXCEPTION
                   WHEN OTHERS
                   THEN
                       NULL;
               END;

               RETURN;
           WHEN TOO_MANY_ROWS
           THEN
               -- This should never happen with proper PK, but...
               l_duration := 0;
       END;

       -- Update span
       UPDATE plt_spans
          SET end_time = SYSTIMESTAMP, duration_ms = l_duration, status = p_status
        WHERE span_id = p_span_id AND end_time IS NULL;  -- Don't update already ended spans

       -- Check if update actually did something
       IF SQL%ROWCOUNT = 0
       THEN
           -- Span already ended or doesn't exist
           BEGIN
               INSERT INTO plt_telemetry_errors (error_time,
                                                 error_message,
                                                 module_name,
                                                 span_id)
                    VALUES (SYSTIMESTAMP,
                            'end_span: Span already ended or not found',
                            'end_span',
                            p_span_id);

               IF g_autocommit
               THEN
                   COMMIT;
               END IF;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;
           END;

           RETURN;
       END IF;

       -- Update trace end time (optional update, don't check rowcount)
       UPDATE plt_traces
          SET end_time = SYSTIMESTAMP
        WHERE     trace_id = g_current_trace_id
              AND NOT EXISTS
                      (SELECT 1
                         FROM plt_spans
                        WHERE trace_id = g_current_trace_id AND span_id != p_span_id AND end_time IS NULL);

       -- Build attributes JSON
       BEGIN
           l_attrs_json := attributes_to_json (p_attributes);
       EXCEPTION
           WHEN OTHERS
           THEN
               l_attrs_json := '{}';  -- Empty JSON on error
       END;

       -- Build complete JSON
       l_json :=
              '{'
           || '"trace_id":"'
           || NVL (g_current_trace_id, 'unknown')
           || '",'
           || '"span_id":"'
           || p_span_id
           || '",'
           || '"operation":"end_span",'
           || '"status":"'
           || NVL (p_status, 'UNKNOWN')
           || '",'
           || '"duration_ms":'
           || NVL (TO_CHAR (l_duration), '0')
           || ','
           || '"timestamp":"'
           || TO_CHAR (SYSTIMESTAMP, 'YYYY-MM-DD"T"HH24:MI:SS.FF3"Z"')
           || '",'
           || '"attributes":'
           || l_attrs_json
           || '}';

       -- Validate JSON
       BEGIN
           IF l_json IS NOT JSON
           THEN
               RAISE_APPLICATION_ERROR (-20003, 'Invalid JSON structure');
           END IF;
       EXCEPTION
           WHEN OTHERS
           THEN
               -- Log invalid JSON
               BEGIN
                   INSERT INTO plt_telemetry_errors (error_time,
                                                     error_message,
                                                     module_name,
                                                     span_id)
                        VALUES (SYSTIMESTAMP,
                                'Invalid JSON: ' || SUBSTR (l_json, 1, 200),
                                'end_span',
                                p_span_id);

                   IF g_autocommit
                   THEN
                       COMMIT;
                   END IF;
               EXCEPTION
                   WHEN OTHERS
                   THEN
                       NULL;
               END;

               RETURN;  -- Don't send invalid JSON
       END;

       -- Send to backend
       send_to_backend (l_json);

       IF g_autocommit
       THEN
           COMMIT;
       END IF;
   EXCEPTION
       WHEN OTHERS
       THEN
           -- Global exception handler
           l_error_msg := SUBSTR (SQLERRM, 1, 4000);
           l_error_code := SQLCODE;

           BEGIN
               INSERT INTO plt_telemetry_errors (error_time,
                                                 error_message,
                                                 error_code,
                                                 error_stack,
                                                 module_name,
                                                 span_id)
                    VALUES (SYSTIMESTAMP,
                            l_error_msg,
                            l_error_code,
                            SUBSTR (DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000),
                            'end_span',
                            p_span_id);

               IF g_autocommit
               THEN
                   COMMIT;
               END IF;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;
           END;

           -- Try to at least update the span as FAILED
           BEGIN
               UPDATE plt_spans
                  SET end_time = SYSTIMESTAMP, status = 'ERROR', duration_ms = 0
                WHERE span_id = p_span_id AND end_time IS NULL;

               IF g_autocommit
               THEN
                   COMMIT;
               END IF;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;
           END;
   END end_span;

   /**
    * Adds an event to an active span
    *
    * @param p_span_id The ID of the span to add the event to
    * @param p_event_name The name of the event
    * @param p_attributes Optional attributes for the event
    */
   PROCEDURE add_event (p_span_id VARCHAR2, p_event_name VARCHAR2, p_attributes t_attributes DEFAULT t_attributes ())
   IS
       l_attrs_varchar   VARCHAR2 (4000);
       l_error_msg       VARCHAR2 (4000);
       l_error_code      NUMBER;
   BEGIN
       -- Validate inputs
       IF p_span_id IS NULL OR p_event_name IS NULL
       THEN
           -- Silent fail for null required params
           RETURN;
       END IF;

       -- Convert attributes to JSON with protection
       BEGIN
           IF p_attributes.COUNT > 0
           THEN
               l_attrs_varchar := attributes_to_json (p_attributes);
           ELSE
               l_attrs_varchar := '{}';
           END IF;
       EXCEPTION
           WHEN OTHERS
           THEN
               l_error_msg := SUBSTR (SQLERRM, 1, 4000);
               -- If attributes fail, use empty JSON
               l_attrs_varchar := '{}';

               -- Log the issue but continue
               BEGIN
                   INSERT INTO plt_telemetry_errors (error_time,
                                                     error_message,
                                                     module_name,
                                                     span_id)
                        VALUES (SYSTIMESTAMP,
                                'add_event: Failed to convert attributes - ' || SUBSTR (l_error_msg, 1, 200),
                                'add_event: ' || SUBSTR (p_event_name, 1, 80),
                                p_span_id);

                   IF g_autocommit
                   THEN
                       COMMIT;
                   END IF;
               EXCEPTION
                   WHEN OTHERS
                   THEN
                       NULL;
               END;
       END;

       -- Validate JSON if we have one
       IF l_attrs_varchar IS NOT NULL AND l_attrs_varchar != '{}'
       THEN
           IF l_attrs_varchar IS NOT JSON
           THEN
               l_attrs_varchar := '{}';  -- Fallback to empty
           END IF;
       END IF;

       -- Insert event
       BEGIN
           INSERT INTO plt_events (span_id,
                                   event_name,
                                   event_time,
                                   attributes)
                VALUES (p_span_id,
                        SUBSTR (p_event_name, 1, 255),  -- Truncate if too long
                        SYSTIMESTAMP,
                        l_attrs_varchar);

           -- Paranoid check
           IF SQL%ROWCOUNT != 1
           THEN
               RAISE_APPLICATION_ERROR (-20004, 'PLTelemetry: Failed to insert event - rowcount=' || SQL%ROWCOUNT);
           END IF;

           IF g_autocommit
           THEN
               COMMIT;
           END IF;
       EXCEPTION
           WHEN OTHERS
           THEN
               -- Event logging failed, but don't crash the app
               l_error_msg := SUBSTR (SQLERRM, 1, 4000);
               l_error_code := SQLCODE;

               BEGIN
                   INSERT INTO plt_telemetry_errors (error_time,
                                                     error_message,
                                                     error_code,
                                                     error_stack,
                                                     module_name,
                                                     span_id)
                        VALUES (SYSTIMESTAMP,
                                l_error_msg,
                                l_error_code,
                                SUBSTR (DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000),
                                'add_event: ' || SUBSTR (p_event_name, 1, 80),
                                p_span_id);

                   IF g_autocommit
                   THEN
                       COMMIT;
                   END IF;
               EXCEPTION
                   WHEN OTHERS
                   THEN
                       NULL;  -- Even error logging can fail
               END;
       END;
   EXCEPTION
       WHEN OTHERS
       THEN
           l_error_msg := SUBSTR (SQLERRM, 1, 4000);
           l_error_code := SQLCODE;

           -- Global exception handler - should never reach here but...
           -- Log if possible but NEVER propagate
           BEGIN
               INSERT INTO plt_telemetry_errors (error_time,
                                                 error_message,
                                                 error_code,
                                                 module_name)
                    VALUES (SYSTIMESTAMP,
                            'add_event: Unexpected error - ' || SUBSTR (l_error_msg, 1, 200),
                            l_error_code,
                            'add_event');

               IF g_autocommit
               THEN
                   COMMIT;
               END IF;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;
           END;
   END add_event;

   /**
    * Records a metric value with associated metadata
    *
    * @param p_metric_name The name of the metric
    * @param p_value The numeric value of the metric
    * @param p_unit Optional unit of measurement
    * @param p_attributes Optional attributes for the metric
    */
   PROCEDURE log_metric (p_metric_name    VARCHAR2,
                         p_value          NUMBER,
                         p_unit           VARCHAR2 DEFAULT NULL,
                         p_attributes     t_attributes DEFAULT t_attributes ())
   IS
       l_json         VARCHAR2 (32767);
       l_attrs_json   VARCHAR2 (4000);
       l_error_msg    VARCHAR2 (4000);
       l_error_code   NUMBER;
       l_value_str    VARCHAR2 (50);
   BEGIN
       -- Validate required inputs
       IF p_metric_name IS NULL OR p_value IS NULL
       THEN
           RETURN;  -- Silent fail for missing required params
       END IF;

       -- Convert attributes to JSON safely
       BEGIN
           l_attrs_json := attributes_to_json (p_attributes);
       EXCEPTION
           WHEN OTHERS
           THEN
               l_error_msg := SUBSTR (SQLERRM, 1, 4000);

               l_attrs_json := '{}';

               -- Log attribute conversion failure
               BEGIN
                   INSERT INTO plt_telemetry_errors (error_time, error_message, module_name)
                            VALUES (
                                       SYSTIMESTAMP,
                                       'log_metric: Failed to convert attributes - ' || SUBSTR (l_error_msg, 1, 200),
                                       'log_metric: ' || SUBSTR (p_metric_name, 1, 80));

                   IF g_autocommit
                   THEN
                       COMMIT;
                   END IF;
               EXCEPTION
                   WHEN OTHERS
                   THEN
                       NULL;
               END;
       END;

       -- Handle special number cases (NaN, Infinity, etc)
       BEGIN
           IF p_value IS NOT NULL
           THEN
               l_value_str := TO_CHAR (p_value, 'FM999999999999990.999999999', 'NLS_NUMERIC_CHARACTERS=''.,''');
           ELSE
               l_value_str := '0';
           END IF;
       EXCEPTION
           WHEN OTHERS
           THEN
               l_value_str := '0';  -- Default on conversion error
       END;

       -- Build metric JSON with escaping
       BEGIN
           l_json :=
                  '{'
               || '"metric_name":"'
               || REPLACE (SUBSTR (p_metric_name, 1, 255), '"', '\"')
               || '",'
               || '"value":'
               || l_value_str
               || ','
               || '"unit":"'
               || REPLACE (NVL (SUBSTR (p_unit, 1, 50), 'unit'), '"', '\"')
               || '",'
               || '"timestamp":"'
               || TO_CHAR (SYSTIMESTAMP, 'YYYY-MM-DD"T"HH24:MI:SS.FF3"Z"')
               || '",'
               || '"trace_id":"'
               || NVL (g_current_trace_id, 'no-trace')
               || '",'
               || '"span_id":"'
               || NVL (g_current_span_id, 'no-span')
               || '",'
               || '"attributes":'
               || l_attrs_json
               || '}';

           -- Validate JSON
           IF l_json IS NOT JSON
           THEN
               RAISE_APPLICATION_ERROR (-20005, 'Invalid metric JSON generated');
           END IF;
       EXCEPTION
           WHEN OTHERS
           THEN
               l_error_msg := SUBSTR (SQLERRM, 1, 4000);

               -- JSON build failed, log and bail
               BEGIN
                   INSERT INTO plt_telemetry_errors (error_time, error_message, module_name)
                            VALUES (
                                       SYSTIMESTAMP,
                                       'log_metric: Failed to build JSON - ' || SUBSTR (l_error_msg, 1, 200),
                                       'log_metric: ' || SUBSTR (p_metric_name, 1, 80));

                   IF g_autocommit
                   THEN
                       COMMIT;
                   END IF;
               EXCEPTION
                   WHEN OTHERS
                   THEN
                       NULL;
               END;

               RETURN;
       END;

       -- Log to metrics table
       BEGIN
           INSERT INTO plt_metrics (metric_name,
                                    metric_value,
                                    metric_unit,
                                    trace_id,
                                    span_id,
                                    timestamp,
                                    attributes)
                VALUES (SUBSTR (p_metric_name, 1, 255),
                        p_value,
                        SUBSTR (NVL (p_unit, 'unit'), 1, 50),
                        g_current_trace_id,
                        g_current_span_id,
                        SYSTIMESTAMP,
                        l_attrs_json);

           -- Paranoid check
           IF SQL%ROWCOUNT != 1
           THEN
               RAISE_APPLICATION_ERROR (-20006, 'PLTelemetry: Failed to insert metric - rowcount=' || SQL%ROWCOUNT);
           END IF;
       EXCEPTION
           WHEN OTHERS
           THEN
               -- Insert failed, but we still want to try sending to backend
               l_error_msg := SUBSTR (SQLERRM, 1, 4000);
               l_error_code := SQLCODE;

               BEGIN
                   INSERT INTO plt_telemetry_errors (error_time,
                                                     error_message,
                                                     error_code,
                                                     error_stack,
                                                     module_name)
                        VALUES (SYSTIMESTAMP,
                                l_error_msg,
                                l_error_code,
                                SUBSTR (DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000),
                                'log_metric: ' || SUBSTR (p_metric_name, 1, 80));

                   IF g_autocommit
                   THEN
                       COMMIT;
                   END IF;
               EXCEPTION
                   WHEN OTHERS
                   THEN
                       NULL;
               END;
       -- Don't return here - still try to send to backend
       END;

       -- Send to backend (let it handle its own errors)
       BEGIN
           send_to_backend (l_json);
       EXCEPTION
           WHEN OTHERS
           THEN
               l_error_msg := SUBSTR (SQLERRM, 1, 4000);

               -- Log send failure
               BEGIN
                   INSERT INTO plt_telemetry_errors (error_time, error_message, module_name)
                            VALUES (
                                       SYSTIMESTAMP,
                                       'log_metric: Failed to send to backend - ' || SUBSTR (l_error_msg, 1, 200),
                                       'log_metric: ' || SUBSTR (p_metric_name, 1, 80));

                   IF g_autocommit
                   THEN
                       COMMIT;
                   END IF;
               EXCEPTION
                   WHEN OTHERS
                   THEN
                       NULL;
               END;
       END;

       -- Final commit if needed
       IF g_autocommit
       THEN
           COMMIT;
       END IF;
   EXCEPTION
       WHEN OTHERS
       THEN
           -- Ultimate safety net
           BEGIN
               l_error_code := SQLCODE;
               l_error_msg := SUBSTR (SQLERRM, 1, 4000);

               INSERT INTO plt_telemetry_errors (error_time,
                                                 error_message,
                                                 error_code,
                                                 module_name)
                    VALUES (SYSTIMESTAMP,
                            'log_metric: Unexpected error - ' || SUBSTR (l_error_msg, 1, 200),
                            l_error_code,
                            'log_metric');

               IF g_autocommit
               THEN
                   COMMIT;
               END IF;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;
           END;
   END log_metric;

   --------------------------------------------------------------------------
   -- UTILITY FUNCTIONS
   --------------------------------------------------------------------------

   /**
    * Creates a key-value attribute string with proper escaping
    *
    * @param p_key The attribute key
    * @param p_value The attribute value
    * @return Escaped key=value string
    */
    FUNCTION add_attribute (p_key VARCHAR2, p_value VARCHAR2)
        RETURN VARCHAR2
    IS
    BEGIN
        -- Validate key follows OpenTelemetry conventions
        IF NOT validate_attribute_key(p_key) THEN
            -- Log invalid key but don't fail
            BEGIN
                INSERT INTO plt_telemetry_errors (
                    error_time, 
                    error_message, 
                    module_name
                ) VALUES (
                    SYSTIMESTAMP, 
                    'Invalid attribute key: ' || SUBSTR(p_key, 1, 100) || 
                    ' - must start with letter and contain only letters, numbers, dots, or underscores',
                    'add_attribute'
                );
                IF g_autocommit THEN 
                    COMMIT; 
                END IF;
            EXCEPTION
                WHEN OTHERS THEN 
                    NULL;
            END;
            
            -- Return empty to skip this attribute
            RETURN NULL;
        END IF;
        
        -- Validate value is not null
        IF p_value IS NULL THEN
            RETURN p_key || '=';  -- Or return NULL to skip?
        END IF;
        
        -- Escape special characters
        RETURN p_key || '=' || REPLACE (REPLACE (p_value, '\', '\\'), '=', '\=');
    END add_attribute;
   /**
    * Converts an attributes collection to JSON format
    *
    * @param p_attributes Collection of key=value attributes
    * @return JSON string representation of attributes
    */
   FUNCTION attributes_to_json (p_attributes t_attributes)
       RETURN VARCHAR2
   IS
       l_json        VARCHAR2 (32767);
       l_key         VARCHAR2 (255);
       l_value       VARCHAR2 (4000);
       l_pos         NUMBER;
       l_temp_attr   VARCHAR2 (4000);
   BEGIN
       l_json := '{';

       IF p_attributes.COUNT > 0
       THEN
           FOR i IN p_attributes.FIRST .. p_attributes.LAST
           LOOP
               IF p_attributes.EXISTS (i) AND p_attributes (i) IS NOT NULL
               THEN
                   -- Parse key=value
                   l_pos := INSTR (p_attributes (i), '=');

                   IF l_pos > 0
                   THEN
                       l_key := SUBSTR (p_attributes (i), 1, l_pos - 1);
                       l_value := SUBSTR (p_attributes (i), l_pos + 1);

                       -- First unescape our format
                       l_value := REPLACE (l_value, '\=', CHR (1));  -- Temporal marker
                       l_value := REPLACE (l_value, '\\', '\');
                       l_value := REPLACE (l_value, CHR (1), '=');

                       -- Then escape for JSON
                       l_value := REPLACE (l_value, '\', '\\');
                       l_value := REPLACE (l_value, '"', '\"');
                       l_value := REPLACE (l_value, CHR (10), '\n');
                       l_value := REPLACE (l_value, CHR (13), '\r');
                       l_value := REPLACE (l_value, CHR (9), '\t');
                       l_value := REPLACE (l_value, CHR (8), '\b');
                       l_value := REPLACE (l_value, CHR (12), '\f');

                       -- Truncate individual attribute if too long
                       l_temp_attr := '"' || SUBSTR (l_key, 1, 100) || '":"' || SUBSTR (l_value, 1, 500) || '"';

                       -- Check if adding this would exceed our limit
                       IF LENGTH (l_json) + LENGTH (l_temp_attr) + 10 > 3990
                       THEN
                           -- Maybe add a "truncated":true attribute?
                           IF LENGTH (l_json) + 20 < 3990
                           THEN
                               l_json := l_json || ',"_truncated":true';
                           END IF;

                           EXIT;  -- Stop adding more attributes
                       END IF;

                       IF l_json != '{'
                       THEN
                           l_json := l_json || ',';
                       END IF;

                       l_json := l_json || l_temp_attr;
                   END IF;
               END IF;
           END LOOP;
       END IF;

       l_json := l_json || '}';
       RETURN SUBSTR (l_json, 1, 4000);  -- Final safety net
   EXCEPTION
       WHEN OTHERS
       THEN
           -- Never let telemetry break the main process
           -- Return minimal valid JSON with error info
           RETURN SUBSTR ('{"_error":"' || REPLACE (SUBSTR (SQLERRM, 1, 100), '"', '\"') || '","_error_code":"' || SQLCODE || '"}', 1, 4000);
   END;

   /**
    * Sends telemetry data to the configured backend
    *
    * @param p_json JSON payload to send
    * @note Uses async mode by default, falls back to sync on failure
    */
   PROCEDURE send_to_backend (p_json VARCHAR2)
   IS
       l_error_msg    VARCHAR2 (4000);
       l_error_code   NUMBER;
   BEGIN
       -- Validate input
       IF p_json IS NULL
       THEN
           RETURN;
       END IF;

       IF g_async_mode
       THEN
           -- Queue for async processing
           BEGIN
               INSERT INTO plt_queue (payload)
                    VALUES (p_json);

               IF g_autocommit
               THEN
                   COMMIT;
               END IF;
           EXCEPTION
               WHEN OTHERS
               THEN
                   -- Queue insert failed, try sync as fallback
                   l_error_msg := SUBSTR (SQLERRM, 1, 4000);
                   l_error_code := SQLCODE;

                   -- Log the queue failure
                   BEGIN
                       INSERT INTO plt_telemetry_errors (error_time,
                                                         error_message,
                                                         error_code,
                                                         module_name)
                            VALUES (SYSTIMESTAMP,
                                    'Failed to queue telemetry, falling back to sync: ' || l_error_msg,
                                    l_error_code,
                                    'send_to_backend');

                       IF g_autocommit
                       THEN
                           COMMIT;
                       END IF;
                   EXCEPTION
                       WHEN OTHERS
                       THEN
                           NULL;
                   END;

                   -- Fallback to synchronous
                   BEGIN
                       send_to_backend_sync (p_json);
                   EXCEPTION
                       WHEN OTHERS
                       THEN
                           -- Both async and sync failed, give up silently
                           NULL;
                   END;
           END;
       ELSE
           -- Original synchronous sending
           BEGIN
               send_to_backend_sync (p_json);
           EXCEPTION
               WHEN OTHERS
               THEN
                   -- Sync failed, but don't propagate
                   NULL;
           END;
       END IF;
   END send_to_backend;

   /**
    * Sets the current trace context in Oracle session info
    *
    * @note Uses DBMS_APPLICATION_INFO for visibility in V$SESSION
    */
   PROCEDURE set_trace_context
   IS
   BEGIN
       -- Use SET_MODULE and SET_ACTION to avoid 64 byte limit
       DBMS_APPLICATION_INFO.SET_MODULE (module_name   => 'OTEL:' || SUBSTR (NVL (g_current_trace_id, 'none'), 1, 28),
                                         action_name   => 'SPAN:' || SUBSTR (NVL (g_current_span_id, 'none'), 1, 28));
   END;

   /**
    * Clears the current trace context from session
    */
   PROCEDURE clear_trace_context
   IS
   BEGIN
       g_current_trace_id := NULL;
       g_current_span_id := NULL;
       DBMS_APPLICATION_INFO.SET_MODULE (NULL, NULL);
   END;

   /**
    * Processes queued telemetry data in batches
    *
    * @param p_batch_size Number of queue entries to process (default 100)
    * @note Should be called periodically by a scheduled job
    */
   PROCEDURE process_queue (p_batch_size NUMBER DEFAULT 100)
   IS
       CURSOR c_queue
       IS
                SELECT queue_id, payload
                  FROM plt_queue
                 WHERE processed = 'N' AND process_attempts < 3
              ORDER BY created_at
           FETCH FIRST NVL (NULLIF (p_batch_size, 0), 100) ROWS ONLY  -- Protect against 0 or null
           FOR UPDATE
               SKIP LOCKED;

       l_processed_count   NUMBER := 0;
       l_error_count       NUMBER := 0;
       l_error_msg         VARCHAR2 (4000);
       l_error_code        NUMBER;
   BEGIN
       -- Validate batch size
       IF p_batch_size < 0 OR p_batch_size > 10000
       THEN
           RAISE_APPLICATION_ERROR (-20007, 'Invalid batch size: must be between 1 and 10000');
       END IF;

       FOR rec IN c_queue
       LOOP
           BEGIN
               -- Send synchronously
               send_to_backend_sync (rec.payload);

               -- Mark as processed
               UPDATE plt_queue
                  SET processed = 'Y', processed_time = SYSTIMESTAMP
                WHERE queue_id = rec.queue_id;

               l_processed_count := l_processed_count + 1;
           EXCEPTION
               WHEN OTHERS
               THEN
                   l_error_msg := SUBSTR (SQLERRM, 1, 200);
                   l_error_count := l_error_count + 1;

                   -- Increment attempts on failure
                   BEGIN
                       UPDATE plt_queue
                          SET process_attempts = process_attempts + 1, last_error = l_error_msg, last_attempt_time = SYSTIMESTAMP
                        WHERE queue_id = rec.queue_id;
                   EXCEPTION
                       WHEN OTHERS
                       THEN
                           NULL;  -- Don't fail on update
                   END;
           END;

           -- Commit each record to release lock
           COMMIT;
       END LOOP;

       -- Log processing summary if we did something
       IF l_processed_count > 0 OR l_error_count > 0
       THEN
           BEGIN
               INSERT INTO plt_telemetry_errors (error_time, error_message, module_name)
                    VALUES (SYSTIMESTAMP, 'Queue processed: ' || l_processed_count || ' success, ' || l_error_count || ' errors', 'process_queue');

               COMMIT;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;
           END;
       END IF;
   EXCEPTION
       WHEN OTHERS
       THEN
           l_error_code := SQLCODE;
           l_error_msg := SUBSTR (SQLERRM, 1, 4000);

           -- Global handler - log but don't propagate
           BEGIN
               INSERT INTO plt_telemetry_errors (error_time,
                                                 error_message,
                                                 error_code,
                                                 module_name)
                    VALUES (SYSTIMESTAMP,
                            'process_queue failed: ' || SUBSTR (l_error_msg, 1, 3800),
                            l_error_code,
                            'process_queue');

               COMMIT;
           EXCEPTION
               WHEN OTHERS
               THEN
                   NULL;
           END;
   END process_queue;

   --------------------------------------------------------------------------
   -- CONFIGURATION GETTERS AND SETTERS
   --------------------------------------------------------------------------

   /**
    * Sets the auto-commit mode for telemetry operations
    *
    * @param p_value TRUE to enable auto-commit, FALSE to disable
    */
   PROCEDURE set_autocommit (p_value BOOLEAN)
   IS
   BEGIN
       g_autocommit := p_value;
   END;

   /**
    * Gets the current auto-commit mode setting
    *
    * @return Current auto-commit setting
    */
   FUNCTION get_autocommit
       RETURN BOOLEAN
   IS
   BEGIN
       RETURN g_autocommit;
   END;

   /**
    * Sets the backend URL for telemetry export
    *
    * @param p_url The HTTP endpoint URL
    */
   PROCEDURE set_backend_url (p_url VARCHAR2)
   IS
   BEGIN
       g_backend_url := p_url;
   END;

   /**
    * Gets the current backend URL
    *
    * @return Current backend URL
    */
   FUNCTION get_backend_url
       RETURN VARCHAR2
   IS
   BEGIN
       RETURN g_backend_url;
   END;

   /**
    * Sets the API key for backend authentication
    *
    * @param p_key The API key string
    */
   PROCEDURE set_api_key (p_key VARCHAR2)
   IS
   BEGIN
       g_api_key := p_key;
   END;

   /**
    * Sets the HTTP timeout for backend calls
    *
    * @param p_timeout Timeout in seconds
    */
   PROCEDURE set_backend_timeout (p_timeout NUMBER)
   IS
   BEGIN
       g_backend_timeout := p_timeout;
   END;

   /**
    * Sets the async processing mode
    *
    * @param p_async TRUE for async mode, FALSE for synchronous
    */
   PROCEDURE set_async_mode (p_async BOOLEAN)
   IS
   BEGIN
       g_async_mode := p_async;
   END;

   /**
    * Gets the current trace ID
    *
    * @return Current trace ID or NULL if no active trace
    */
   FUNCTION get_current_trace_id
       RETURN VARCHAR2
   IS
   BEGIN
       RETURN g_current_trace_id;
   END get_current_trace_id;

   /**
    * Gets the current span ID
    *
    * @return Current span ID or NULL if no active span
    */
   FUNCTION get_current_span_id
       RETURN VARCHAR2
   IS
   BEGIN
       RETURN g_current_span_id;
   END get_current_span_id;

END PLTelemetry;
/
[END OF FILE: src/PLTelemetry.pkb]


========================================================================
FILE: CONTRIBUTING.md
SIZE: 713 bytes
MODIFIED: ./CONTRIBUTING.md 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550511 1550511 18446744073709551615 -1
2025-06-23 06:16:29.753426500
========================================================================

markdown# Contributing to PLTelemetry

## Development Setup
1. Oracle Database 12c+ with development schema
2. Required grants for UTL_HTTP and DBMS_CRYPTO
3. Test data setup

## Code Style
- Use 4 spaces for indentation
- Comment all public procedures/functions
- Follow Oracle naming conventions
- Include error handling in all procedures

## Testing
- Test against Oracle 12c, 18c, 19c, 21c
- Include both sync and async mode tests
- Test error scenarios

## Pull Request Process
1. Fork the repository
2. Create feature branch: `git checkout -b feature/amazing-feature`
3. Commit changes: `git commit -m 'Add amazing feature'`
4. Push to branch: `git push origin feature/amazing-feature`
[END OF FILE: CONTRIBUTING.md]


========================================================================
FILE: README.md
SIZE: 9990 bytes
MODIFIED: ./README.md 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550511 1550511 18446744073709551615 -1
2025-06-23 06:16:29.759444100
========================================================================

<p align="center">
  <img src="assets/PLT_logo.jpg" alt="PLTelemetry logo" width="200"/>
</p>

# PLTelemetry

OpenTelemetry SDK for Oracle PL/SQL - Distributed tracing, metrics, and observability for Oracle Database applications.

![License](https://img.shields.io/badge/license-MIT-blue.svg)
![Oracle](https://img.shields.io/badge/Oracle-12c%2B-red.svg)
![Version](https://img.shields.io/badge/version-0.1.0-green.svg)

## Overview

PLTelemetry provides OpenTelemetry-compatible distributed tracing capabilities for PL/SQL applications. It enables you to instrument your Oracle Database code with traces, spans, events, and metrics that can be exported to modern observability platforms.

### Key Features

- 🔍 **Distributed Tracing**: Full OpenTelemetry-compatible trace and span management
- 📊 **Metrics Collection**: Record custom metrics with attributes and units
- 🎯 **Event Logging**: Add contextual events to spans for detailed observability
- 🚀 **Async Processing**: Queue-based telemetry export for minimal performance impact
- ⚡ **Sync Fallback**: Automatic fallback to synchronous mode on queue failures
- 🛡️ **Robust Error Handling**: Never fails your business logic due to telemetry issues
- 🔧 **Configurable**: Adjustable backends, timeouts, and processing modes
- 📈 **Performance Optimized**: Minimal overhead on your production workloads

## Quick Start

### For DBAs - Installation

1. **Create required tables**:
```sql
-- Run the provided DDL script
@install_tables.sql
```

2. **Install the package**:
```sql
-- Install package specification
@PLTelemetry.pks

-- Install package body  
@PLTelemetry.pkb
```

3. **Configure backend endpoint**:
```sql
BEGIN
    PLTelemetry.set_backend_url('https://your-telemetry-backend.com/api/traces');
    PLTelemetry.set_api_key('your-secret-api-key');
    PLTelemetry.set_async_mode(TRUE);  -- Recommended for production
END;
/
```

4. **Set up queue processing job**:
```sql
BEGIN
    DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'PLT_QUEUE_PROCESSOR',
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN PLTelemetry.process_queue(100); END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=MINUTELY; INTERVAL=1',
        enabled         => TRUE,
        comments        => 'Process PLTelemetry queue every minute'
    );
END;
/
```

### For Developers - Basic Usage

```sql
DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
BEGIN
    -- Start a new trace
    l_trace_id := PLTelemetry.start_trace('process_customer_order');
    
    -- Start a span for validation
    l_span_id := PLTelemetry.start_span('validate_customer');
    
    -- Add some attributes
    l_attrs(1) := PLTelemetry.add_attribute('customer.id', '12345');
    l_attrs(2) := PLTelemetry.add_attribute('order.total', '299.99');
    
    -- Your business logic here
    validate_customer(p_customer_id => 12345);
    
    -- Add an event
    PLTelemetry.add_event(l_span_id, 'customer_validated', l_attrs);
    
    -- End the span
    PLTelemetry.end_span(l_span_id, 'OK', l_attrs);
    
    -- Record a metric
    PLTelemetry.log_metric('order_value', 299.99, 'USD', l_attrs);
    
    -- End the trace
    PLTelemetry.end_trace(l_trace_id);
END;
/
```

## API Reference

### Core Functions

#### `start_trace(p_operation VARCHAR2) RETURN VARCHAR2`
Starts a new distributed trace.

**Parameters:**
- `p_operation`: Name of the root operation being traced

**Returns:** 32-character hex trace ID

#### `start_span(p_operation VARCHAR2, p_parent_span_id VARCHAR2, p_trace_id VARCHAR2) RETURN VARCHAR2`
Starts a new span within a trace.

**Parameters:**
- `p_operation`: Name of the operation for this span
- `p_parent_span_id`: Optional parent span ID for nested spans
- `p_trace_id`: Optional trace ID (uses current if not provided)

**Returns:** 16-character hex span ID

#### `end_span(p_span_id VARCHAR2, p_status VARCHAR2, p_attributes t_attributes)`
Ends an active span and records its duration.

**Parameters:**
- `p_span_id`: The span ID to end
- `p_status`: Final status ('OK', 'ERROR', etc.)
- `p_attributes`: Optional attributes collection

#### `add_event(p_span_id VARCHAR2, p_event_name VARCHAR2, p_attributes t_attributes)`
Adds an event to an active span.

#### `log_metric(p_metric_name VARCHAR2, p_value NUMBER, p_unit VARCHAR2, p_attributes t_attributes)`
Records a metric with metadata.

### Configuration Functions

```sql
-- Set backend configuration
PLTelemetry.set_backend_url('https://api.example.com/telemetry');
PLTelemetry.set_api_key('your-api-key');
PLTelemetry.set_backend_timeout(30);

-- Configure processing mode
PLTelemetry.set_async_mode(TRUE);
PLTelemetry.set_autocommit(FALSE);

-- Get current settings
l_url := PLTelemetry.get_backend_url();
l_trace_id := PLTelemetry.get_current_trace_id();
```

## Advanced Usage

### Error Handling Pattern

```sql
DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
    l_attrs    PLTelemetry.t_attributes;
BEGIN
    l_trace_id := PLTelemetry.start_trace('risky_operation');
    l_span_id := PLTelemetry.start_span('database_transaction');
    
    BEGIN
        -- Your risky business logic
        execute_complex_transaction();
        
        PLTelemetry.add_event(l_span_id, 'transaction_completed');
        PLTelemetry.end_span(l_span_id, 'OK');
        
    EXCEPTION
        WHEN OTHERS THEN
            l_attrs(1) := PLTelemetry.add_attribute('error.message', SQLERRM);
            l_attrs(2) := PLTelemetry.add_attribute('error.code', TO_CHAR(SQLCODE));
            
            PLTelemetry.add_event(l_span_id, 'transaction_failed', l_attrs);
            PLTelemetry.end_span(l_span_id, 'ERROR', l_attrs);
            
            RAISE; -- Re-raise the original exception
    END;
    
    PLTelemetry.end_trace(l_trace_id);
END;
/
```

### Nested Spans for Complex Operations

```sql
DECLARE
    l_trace_id     VARCHAR2(32);
    l_main_span    VARCHAR2(16);
    l_db_span      VARCHAR2(16);
    l_api_span     VARCHAR2(16);
BEGIN
    l_trace_id := PLTelemetry.start_trace('order_processing');
    l_main_span := PLTelemetry.start_span('process_order');
    
    -- Database operations
    l_db_span := PLTelemetry.start_span('save_order', l_main_span);
    save_order_to_database();
    PLTelemetry.end_span(l_db_span, 'OK');
    
    -- External API call
    l_api_span := PLTelemetry.start_span('notify_external_system', l_main_span);
    call_external_api();
    PLTelemetry.end_span(l_api_span, 'OK');
    
    PLTelemetry.end_span(l_main_span, 'OK');
    PLTelemetry.end_trace(l_trace_id);
END;
/
```

## JSON Output Examples

### Span End Event
```json
{
  "trace_id": "a1b2c3d4e5f6789012345678901234ab",
  "span_id": "a1b2c3d4e5f67890",
  "operation": "end_span",
  "status": "OK",
  "duration_ms": 245.67,
  "timestamp": "2025-06-20T14:30:15.123Z",
  "attributes": {
    "customer.id": "12345",
    "order.total": "299.99",
    "db.operation": "INSERT"
  }
}
```

### Metric Event
```json
{
  "metric_name": "order_processing_time",
  "value": 1234.56,
  "unit": "milliseconds",
  "timestamp": "2025-06-20T14:30:15.123Z",
  "trace_id": "a1b2c3d4e5f6789012345678901234ab",
  "span_id": "a1b2c3d4e5f67890",
  "attributes": {
    "customer.type": "premium",
    "order.items": "3"
  }
}
```

## Performance Considerations

### Async Mode (Recommended)
- Minimal impact on business logic performance
- Telemetry data queued locally and processed in batches
- Automatic retry on failures
- Requires scheduled job for queue processing

### Sync Mode
- Immediate export to backend
- Higher latency impact on business operations
- Useful for debugging or low-volume scenarios

### Queue Management
The async queue should be monitored and maintained:

```sql
-- Check queue status
SELECT 
    COUNT(*) as total_entries,
    SUM(CASE WHEN processed = 'N' THEN 1 ELSE 0 END) as pending,
    SUM(CASE WHEN process_attempts >= 3 THEN 1 ELSE 0 END) as failed
FROM plt_queue;

-- Manual queue processing
BEGIN
    PLTelemetry.process_queue(500); -- Process up to 500 entries
END;
/
```

## OpenTelemetry Compatibility

PLTelemetry follows OpenTelemetry semantic conventions:

- **Trace IDs**: 128-bit (32 hex characters)
- **Span IDs**: 64-bit (16 hex characters)  
- **Attribute naming**: Standard semantic conventions
- **HTTP attributes**: `http.method`, `http.url`, `http.status_code`
- **Database attributes**: `db.operation`, `db.statement`
- **Error attributes**: `error.message`

## Requirements

- Oracle Database 12c or higher
- `UTL_HTTP` package access for backend communication
- `DBMS_CRYPTO` package for ID generation
- `DBMS_SCHEDULER` access for queue processing jobs

## Database Permissions

The user installing PLTelemetry needs:
```sql
GRANT EXECUTE ON UTL_HTTP TO your_user;
GRANT EXECUTE ON DBMS_CRYPTO TO your_user;
GRANT CREATE JOB TO your_user;
```

## Components

**PLTelemetry Package**: Oracle PL/SQL package for telemetry generation
**[Bridge](./bridge/)**: Node.js service to convert PLTelemetry JSON to OpenTelemetry format


## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Submit a pull request

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Support

- 📖 Documentation: [GitHub Wiki](https://github.com/pradocabreroalejandro/pltelemetry/wiki)
- 🐛 Issues: [GitHub Issues](https://github.com/pradocabreroalejandro/pltelemetry/issues)
- 💬 Discussions: [GitHub Discussions](https://github.com/pradocabreroalejandro/pltelemetry/discussions)
[END OF FILE: README.md]


========================================================================
FILE: bridge/README.md
SIZE: 14258 bytes
MODIFIED: ./bridge/README.md 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550508 1550508 18446744073709551615 -1
2025-06-23 06:16:29.768442400
========================================================================

# Building a Node.js Bridge for PLTelemetry to OpenTelemetry Conversion

Creating a telemetry conversion bridge requires understanding both the OpenTelemetry SDK structure and the specific JSON mapping requirements. Based on comprehensive research, here's a practical guide to building your PLTelemetry to OpenTelemetry converter.

## OpenTelemetry SDK fundamentals and setup

The OpenTelemetry Node.js SDK provides a vendor-neutral approach to telemetry collection with several key components. The **API layer** (`@opentelemetry/api`) provides core interfaces while the **SDK core** (`@opentelemetry/sdk-node`) offers full implementation with default configurations. For a conversion bridge, you'll need minimal dependencies focused on programmatic telemetry creation rather than auto-instrumentation.

### Essential package installation

```bash
npm install @opentelemetry/api @opentelemetry/sdk-node @opentelemetry/sdk-trace-node @opentelemetry/sdk-metrics @opentelemetry/exporter-trace-otlp-http express
```

### Basic SDK initialization for the bridge

```javascript
const { NodeSDK } = require('@opentelemetry/sdk-node');
const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-http');
const { OTLPMetricExporter } = require('@opentelemetry/exporter-metrics-otlp-http');
const { PeriodicExportingMetricReader } = require('@opentelemetry/sdk-metrics');
const { Resource } = require('@opentelemetry/resources');
const { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');

const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: 'plsql-otel-bridge',
    [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0',
  }),
  traceExporter: new OTLPTraceExporter({
    url: process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT || 'http://localhost:4318/v1/traces',
  }),
  metricReader: new PeriodicExportingMetricReader({
    exporter: new OTLPMetricExporter({
      url: process.env.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT || 'http://localhost:4318/v1/metrics',
    }),
    exportIntervalMillis: 10000
  }),
});

sdk.start();
```

## Creating telemetry data programmatically

OpenTelemetry provides APIs to programmatically create traces, spans, metrics, and events. For a conversion bridge, you'll use these APIs to recreate telemetry data from the incoming PLTelemetry format.

### Trace and span creation patterns

```javascript
const { trace, SpanKind, SpanStatusCode } = require('@opentelemetry/api');

class TelemetryConverter {
  constructor() {
    this.tracer = trace.getTracer('pltelemetry-converter', '1.0.0');
  }

  createSpanFromPLTelemetry(plData) {
    // Start a new span with the operation name from PLTelemetry
    return this.tracer.startActiveSpan(plData.operationName, {
      kind: this.mapSpanKind(plData.operationType),
      attributes: this.convertAttributes(plData.attributes),
      startTime: new Date(plData.timestamp)
    }, (span) => {
      try {
        // Add events from PLTelemetry
        if (plData.events) {
          plData.events.forEach(event => {
            span.addEvent(event.name, {
              ...event.attributes
            }, new Date(event.timestamp));
          });
        }

        // Set status based on PLTelemetry status
        if (plData.status === 'error') {
          span.setStatus({ code: SpanStatusCode.ERROR, message: plData.errorMessage });
          if (plData.exception) {
            span.recordException(new Error(plData.exception.message));
          }
        } else {
          span.setStatus({ code: SpanStatusCode.OK });
        }

        // End the span with the correct timestamp
        span.end(new Date(plData.endTimestamp || plData.timestamp + plData.duration));
      } catch (error) {
        span.recordException(error);
        span.setStatus({ code: SpanStatusCode.ERROR });
        throw error;
      }
    });
  }

  mapSpanKind(operationType) {
    const kindMap = {
      'db_query': SpanKind.CLIENT,
      'pl_procedure': SpanKind.INTERNAL,
      'http_call': SpanKind.CLIENT,
      'service': SpanKind.SERVER
    };
    return kindMap[operationType] || SpanKind.INTERNAL;
  }
}
```

### Metrics creation and recording

```javascript
const { metrics } = require('@opentelemetry/api');

class MetricsConverter {
  constructor() {
    this.meter = metrics.getMeter('pltelemetry-metrics', '1.0.0');
    this.metricInstruments = new Map();
  }

  recordMetric(plMetric) {
    // Get or create the appropriate instrument
    let instrument = this.metricInstruments.get(plMetric.name);
    
    if (!instrument) {
      instrument = this.createInstrument(plMetric);
      this.metricInstruments.set(plMetric.name, instrument);
    }

    // Record the metric value
    const attributes = this.convertAttributes(plMetric.labels);
    
    switch (plMetric.type) {
      case 'counter':
        instrument.add(plMetric.value, attributes);
        break;
      case 'gauge':
      case 'histogram':
        instrument.record(plMetric.value, attributes);
        break;
    }
  }

  createInstrument(plMetric) {
    const { name, type, unit, description } = plMetric;
    
    switch (type) {
      case 'counter':
        return this.meter.createCounter(name, { unit, description });
      case 'gauge':
        return this.meter.createUpDownCounter(name, { unit, description });
      case 'histogram':
        return this.meter.createHistogram(name, { unit, description });
      default:
        throw new Error(`Unknown metric type: ${type}`);
    }
  }
}
```

## JSON structure mapping between PLTelemetry and OpenTelemetry

The OpenTelemetry Protocol (OTLP) has specific JSON structure requirements that differ from typical custom telemetry formats. **Critical mapping considerations** include trace/span IDs must be hex strings (128-bit for traces, 64-bit for spans), timestamps must be Unix nanoseconds as strings, and attribute values must use proper type wrappers.

### Complete conversion bridge implementation

```javascript
const express = require('express');
const { trace, metrics } = require('@opentelemetry/api');

class PLTelemetryBridge {
  constructor() {
    this.app = express();
    this.app.use(express.json({ limit: '10mb' }));
    this.telemetryConverter = new TelemetryConverter();
    this.metricsConverter = new MetricsConverter();
    
    this.setupRoutes();
  }

  setupRoutes() {
    this.app.post('/plsql-otel/telemetry', async (req, res) => {
      try {
        const { type, data } = req.body;
        
        switch (type) {
          case 'trace':
            await this.processTraceData(data);
            break;
          case 'metrics':
            await this.processMetricsData(data);
            break;
          case 'events':
            await this.processEventsData(data);
            break;
          case 'batch':
            await this.processBatchData(data);
            break;
          default:
            return res.status(400).json({ error: `Unknown telemetry type: ${type}` });
        }
        
        res.status(200).json({ message: 'Telemetry processed successfully' });
      } catch (error) {
        console.error('Error processing telemetry:', error);
        res.status(500).json({ error: 'Failed to process telemetry data' });
      }
    });
  }

  async processTraceData(traceData) {
    // Convert PLTelemetry trace format to OpenTelemetry
    const spans = Array.isArray(traceData) ? traceData : [traceData];
    
    for (const spanData of spans) {
      const convertedSpan = {
        traceId: this.ensureValidTraceId(spanData.trace_id),
        spanId: this.ensureValidSpanId(spanData.span_id),
        parentSpanId: spanData.parent_id ? this.ensureValidSpanId(spanData.parent_id) : undefined,
        name: spanData.operation_name,
        startTimeUnixNano: this.convertToNanoTime(spanData.start_time),
        endTimeUnixNano: this.convertToNanoTime(spanData.end_time || spanData.start_time + spanData.duration),
        attributes: this.convertAttributes(spanData.attributes),
        events: this.convertEvents(spanData.events),
        status: this.convertStatus(spanData.status)
      };
      
      // Create actual OpenTelemetry span
      this.telemetryConverter.createSpanFromPLTelemetry(convertedSpan);
    }
  }

  async processMetricsData(metricsData) {
    const metrics = Array.isArray(metricsData) ? metricsData : [metricsData];
    
    for (const metric of metrics) {
      this.metricsConverter.recordMetric({
        name: this.sanitizeMetricName(metric.metric_name),
        type: metric.metric_type,
        value: metric.value,
        unit: metric.unit || '1',
        description: metric.description,
        labels: metric.tags || {}
      });
    }
  }

  async processEventsData(eventsData) {
    // Events in PLTelemetry might be standalone or associated with spans
    const events = Array.isArray(eventsData) ? eventsData : [eventsData];
    
    for (const event of events) {
      if (event.span_id) {
        // Event belongs to a span - would need span context
        console.log('Event associated with span:', event.span_id);
      } else {
        // Standalone event - convert to log
        const logRecord = {
          timestamp: this.convertToNanoTime(event.timestamp),
          severityText: event.level || 'INFO',
          body: { stringValue: event.message },
          attributes: this.convertAttributes(event.attributes)
        };
        // Process log record
      }
    }
  }

  async processBatchData(batchData) {
    // Process different types of telemetry in a batch
    if (batchData.traces) await this.processTraceData(batchData.traces);
    if (batchData.metrics) await this.processMetricsData(batchData.metrics);
    if (batchData.events) await this.processEventsData(batchData.events);
  }

  // Utility methods for data conversion
  ensureValidTraceId(id) {
    if (!id) return this.generateTraceId();
    // Ensure 32-character hex string (128-bit)
    return id.padStart(32, '0').substring(0, 32);
  }

  ensureValidSpanId(id) {
    if (!id) return this.generateSpanId();
    // Ensure 16-character hex string (64-bit)
    return id.padStart(16, '0').substring(0, 16);
  }

  generateTraceId() {
    return [...Array(32)].map(() => Math.floor(Math.random() * 16).toString(16)).join('');
  }

  generateSpanId() {
    return [...Array(16)].map(() => Math.floor(Math.random() * 16).toString(16)).join('');
  }

  convertToNanoTime(timestamp) {
    if (typeof timestamp === 'string') {
      return String(new Date(timestamp).getTime() * 1000000);
    }
    // Assume milliseconds if number
    return String(timestamp * 1000000);
  }

  convertAttributes(attrs) {
    const converted = [];
    for (const [key, value] of Object.entries(attrs || {})) {
      converted.push({
        key,
        value: this.convertAttributeValue(value)
      });
    }
    return converted;
  }

  convertAttributeValue(value) {
    if (typeof value === 'string') return { stringValue: value };
    if (typeof value === 'boolean') return { boolValue: value };
    if (typeof value === 'number') {
      return Number.isInteger(value) ? { intValue: String(value) } : { doubleValue: value };
    }
    if (Array.isArray(value)) {
      return { arrayValue: { values: value.map(v => this.convertAttributeValue(v)) } };
    }
    return { stringValue: JSON.stringify(value) };
  }

  convertEvents(events) {
    if (!events) return [];
    return events.map(event => ({
      name: event.name,
      timeUnixNano: this.convertToNanoTime(event.timestamp),
      attributes: this.convertAttributes(event.attributes)
    }));
  }

  convertStatus(status) {
    const statusMap = {
      'success': 1, // OK
      'error': 2,   // ERROR
      'ok': 1,
      'failed': 2
    };
    return {
      code: statusMap[status?.toLowerCase()] || 0 // UNSET
    };
  }

  sanitizeMetricName(name) {
    return name.toLowerCase().replace(/[^a-z0-9_]/g, '_');
  }

  start(port = 3000) {
    this.app.listen(port, () => {
      console.log(`PLTelemetry to OpenTelemetry bridge running on port ${port}`);
    });
  }
}

// Start the bridge
const bridge = new PLTelemetryBridge();
bridge.start(process.env.PORT || 3000);
```

## Best practices for production deployment

For a production-ready telemetry bridge, consider implementing **request validation** using middleware to ensure incoming PLTelemetry data meets expected schemas. Add **error boundaries** around conversion logic to prevent malformed data from crashing the service. Implement **basic health checks** at `/health` endpoint for monitoring. Use **environment variables** for configuration including OTLP endpoints, service metadata, and batch settings.

### Minimal Docker deployment

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
CMD ["node", "bridge.js"]
```

### Environment configuration

```bash
# OTLP Configuration
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318
OTEL_SERVICE_NAME=plsql-otel-bridge
OTEL_SERVICE_VERSION=1.0.0

# Bridge Configuration
PORT=3000
LOG_LEVEL=info
MAX_PAYLOAD_SIZE=10mb
```

## Testing with mock backend

For development and testing, use the OpenTelemetry Collector with console exporters:

```yaml
# otel-collector-dev.yaml
receivers:
  otlp:
    protocols:
      http:
        endpoint: 0.0.0.0:4318

exporters:
  logging:
    loglevel: debug

service:
  pipelines:
    traces:
      receivers: [otlp]
      exporters: [logging]
    metrics:
      receivers: [otlp]
      exporters: [logging]
```

This implementation provides a simple yet functional bridge that receives PLTelemetry JSON data and converts it to proper OpenTelemetry format. The modular design allows easy extension for specific PLTelemetry format requirements while maintaining compatibility with the OpenTelemetry ecosystem.
[END OF FILE: bridge/README.md]


========================================================================
FILE: bridges/README.md
SIZE: 6535 bytes
MODIFIED: ./bridges/README.md 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550505 1550505 18446744073709551615 -1
2025-06-23 14:25:45.078210000
========================================================================

# PLTelemetry Bridges

This directory contains backend-specific bridge implementations for PLTelemetry. Each bridge transforms the generic OpenTelemetry-compliant JSON format generated by PLTelemetry into the format required by specific backends.

## 🌉 What is a Bridge?

A bridge is an adapter that:
- Receives generic telemetry data from PLTelemetry
- Transforms it to backend-specific format
- Handles authentication and connection details
- Manages backend-specific requirements (e.g., foreign keys, field names)

## 📦 Available Bridges

### Production Ready

#### [PostgreSQL](postgresql/)
- **Status**: ✅ Production Ready
- **Languages**: Oracle PL/SQL
- **Backend**: PostgreSQL via PostgREST
- **Features**:
  - Full traces, spans, and metrics support
  - Handles foreign key dependencies
  - Character escaping for special characters
  - Both sync and async modes

### In Development

#### [Elasticsearch](elasticsearch/) 
- **Status**: 🚧 Coming Soon
- **Languages**: Oracle PL/SQL, Node.js
- **Backend**: Elasticsearch 8.x
- **Features**: Full-text search, aggregations

#### [InfluxDB](influxdb/)
- **Status**: 📋 Planned
- **Languages**: Oracle PL/SQL, Python
- **Backend**: InfluxDB 2.x
- **Features**: Time-series optimized

#### [Jaeger](jaeger/)
- **Status**: 📋 Planned
- **Languages**: Oracle PL/SQL, Java
- **Backend**: Jaeger
- **Features**: Distributed tracing UI

## 🏗️ Bridge Architecture

```
┌─────────────────┐    Generic JSON    ┌─────────────────┐    Backend Format    ┌──────────────┐
│   PLTelemetry   │ ─────────────────▶ │     Bridge      │ ──────────────────▶ │    Backend   │
│     (Core)      │                    │    (Adapter)    │                      │  (Database)  │
└─────────────────┘                    └─────────────────┘                      └──────────────┘
```

## 📐 Generic JSON Format

PLTelemetry generates JSON in this format:

### Traces
```json
{
  "trace_id": "32-char-hex-string",
  "operation": "operation_name",
  "start_time": "2025-01-01T12:00:00.000Z",
  "service_name": "oracle-plsql"
}
```

### Spans
```json
{
  "trace_id": "32-char-hex-string",
  "span_id": "16-char-hex-string",
  "parent_span_id": "16-char-hex-string",
  "operation": "operation_name",
  "start_time": "2025-01-01T12:00:00.000Z",
  "end_time": "2025-01-01T12:00:01.000Z",
  "duration_ms": 1000,
  "status": "OK",
  "attributes": {}
}
```

### Metrics
```json
{
  "name": "metric_name",
  "value": 123.45,
  "unit": "ms",
  "timestamp": "2025-01-01T12:00:00.000Z",
  "trace_id": "32-char-hex-string",
  "span_id": "16-char-hex-string",
  "attributes": {}
}
```

## 🛠️ Creating a New Bridge

### 1. Copy the Template

```bash
cp -r template/ my-backend/
```

### 2. Bridge Requirements

Your bridge must:

- ✅ Transform generic JSON to backend format
- ✅ Handle all errors gracefully (never break the application)
- ✅ Support both sync and async modes if possible
- ✅ Include comprehensive examples
- ✅ Document backend-specific setup

### 3. Implementation Checklist

#### For Oracle PL/SQL bridges:

- [ ] Create package specification (`PLT_MYBACKEND_BRIDGE.pks`)
- [ ] Create package body (`PLT_MYBACKEND_BRIDGE.pkb`)
- [ ] Implement required procedures:
  - `send_trace_to_backend`
  - `send_span_to_backend`
  - `send_metric_to_backend`
  - `route_to_backend` (for generic routing)
- [ ] Handle special characters and escaping
- [ ] Create installation script
- [ ] Write examples for all modes

#### For Other Languages:

- [ ] Parse generic JSON from PLTelemetry
- [ ] Transform to backend format
- [ ] Handle authentication
- [ ] Implement retry logic
- [ ] Add logging/debugging capabilities

### 4. Directory Structure

```
my-backend/
├── README.md                 # Backend-specific documentation
├── oracle/                   # Oracle PL/SQL implementation
│   ├── src/
│   │   ├── PLT_MYBACKEND_BRIDGE.pks
│   │   └── PLT_MYBACKEND_BRIDGE.pkb
│   ├── install.sql
│   └── examples/
├── nodejs/                   # Node.js implementation (optional)
│   ├── package.json
│   ├── src/
│   └── examples/
└── schema/                   # Backend setup files
    └── setup.sql
```

## 🧪 Testing Your Bridge

### Basic Test

```sql
-- Configure
BEGIN
    PLTelemetry.set_backend_url('MYBACKEND_BRIDGE');
    PLT_MYBACKEND_BRIDGE.set_endpoint('http://localhost:NNNN');
END;
/

-- Create test data
DECLARE
    l_trace_id VARCHAR2(32);
    l_span_id  VARCHAR2(16);
BEGIN
    l_trace_id := PLTelemetry.start_trace('bridge_test');
    l_span_id := PLTelemetry.start_span('test_operation');
    PLTelemetry.end_span(l_span_id, 'OK');
    PLTelemetry.log_metric('test_metric', 123, 'units');
END;
/
```

### Test Checklist

- [ ] Single span with metric
- [ ] Nested spans
- [ ] Error handling (network failures)
- [ ] Special characters in data
- [ ] Large payloads
- [ ] Concurrent requests

## 📊 Bridge Comparison

| Bridge | Language | Backend | Sync | Async | Batch | Auth |
|--------|----------|---------|------|-------|-------|------|
| PostgreSQL | PL/SQL | PostgREST | ✅ | ✅ | ❌ | DB Users |
| Elasticsearch | PL/SQL, Node.js | HTTP/REST | ✅ | ✅ | ✅ | API Key |
| InfluxDB | PL/SQL, Python | HTTP/Line | ✅ | ✅ | ✅ | Token |
| Jaeger | PL/SQL, Java | gRPC/HTTP | ✅ | ✅ | ✅ | None |

## 🤝 Contributing

1. Fork the repository
2. Create your bridge following the template
3. Add comprehensive documentation
4. Include working examples
5. Test thoroughly
6. Submit a pull request

### Contribution Guidelines

- Use English for all documentation and code comments
- Follow the established directory structure
- Include error handling for all external calls
- Never let telemetry break the main application
- Add your bridge to this README

## 📚 Resources

- [OpenTelemetry Specification](https://opentelemetry.io/docs/reference/specification/)
- [PLTelemetry Core Documentation](../README.md)


[END OF FILE: bridges/README.md]


========================================================================
FILE: bridges/postgresql/nodejs/README.md
SIZE: 0 bytes
MODIFIED: ./bridges/postgresql/nodejs/README.md 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550503 1550503 18446744073709551615 -1
2025-06-23 14:07:44.068389500
========================================================================


[END OF FILE: bridges/postgresql/nodejs/README.md]


========================================================================
FILE: pltelemetry-complete-bundle.txt
SIZE: 347174 bytes
MODIFIED: ./pltelemetry-complete-bundle.txt 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550503 1550503 18446744073709551615 -1
2025-06-23 14:29:28.347216300
========================================================================


[END OF FILE: pltelemetry-complete-bundle.txt]


========================================================================
FILE: bridges/postgresql/schema/02-postgrest-config.conf
SIZE: 10508 bytes
MODIFIED: ./bridges/postgresql/schema/02-postgrest-config.conf 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550503 1550503 18446744073709551615 -1
2025-06-23 14:13:29.777351900
========================================================================

# ============================================
# FILE: 02-postgrest-config.conf
# PostgREST Configuration for PLTelemetry
# ============================================

# This file configures PostgREST to expose the telemetry schema
# as a REST API that the PostgreSQL bridge can consume.

# Database connection
db-uri = "postgres://pltel_writer:your_password@localhost:5432/pltelemetry_db"

# Schema to expose
db-schemas = "telemetry"

# Anonymous role (user for unauthenticated requests)
db-anon-role = "pltel_writer"

# Server configuration
server-host = "*"
server-port = 3000

# JWT secret (optional - only if using authentication)
# jwt-secret = "your-256-bit-secret-here"
# jwt-aud = "pltelemetry-api"

# Connection pool
db-pool = 10
db-pool-acquisition-timeout = 10

# Logging
log-level = "warn"

# ============================================
# FILE: 03-postgrest-writer.conf
# PostgREST Writer Instance Configuration
# ============================================

# Writer instance - for INSERT operations
db-uri = "postgres://pltel_writer:your_password@localhost:5432/pltelemetry_db"
db-schemas = "telemetry"
db-anon-role = "pltel_writer"
server-port = 3000

# Performance optimizations for writes
db-pool = 20
db-pool-acquisition-timeout = 5
server-proxy-uri = "http://localhost:3000"

# ============================================
# FILE: 04-postgrest-reader.conf  
# PostgREST Reader Instance Configuration (Optional)
# ============================================

# Reader instance - for SELECT operations (Grafana, dashboards)
db-uri = "postgres://pltel_reader:your_password@localhost:5432/pltelemetry_db"
db-schemas = "telemetry"
db-anon-role = "pltel_reader"
server-port = 3001

# Optimizations for read queries
db-pool = 50
db-pool-acquisition-timeout = 10
db-prepared-statements = true

# Security - read only
db-tx-end = "commit-allow-override"
db-max-rows = 1000

# ============================================
# FILE: 05-postgrest-setup.sh
# Setup script for PostgREST service
# ============================================

#!/bin/bash

# PostgREST setup script for PLTelemetry
# Tested on: RedHat 9.6, Ubuntu 22.04

set -e

echo "=== PostgREST Setup for PLTelemetry ==="

# Check if running as root
if [[ $EUID -ne 0 ]]; then
   echo "This script must be run as root (use sudo)"
   exit 1
fi

# Install PostgREST if not present
if ! command -v postgrest &> /dev/null; then
    echo "Installing PostgREST..."
    
    # For RedHat/CentOS/Fedora
    if command -v dnf &> /dev/null; then
        dnf install -y postgrest
    # For Ubuntu/Debian
    elif command -v apt-get &> /dev/null; then
        apt-get update
        apt-get install -y postgrest
    else
        echo "Please install PostgREST manually from: https://postgrest.org"
        exit 1
    fi
fi

# Create config directory
mkdir -p /etc/postgrest

# Copy configuration files
echo "Copying configuration files..."
cp 02-postgrest-config.conf /etc/postgrest/postgrest.conf
cp 03-postgrest-writer.conf /etc/postgrest/postgrest-writer.conf
cp 04-postgrest-reader.conf /etc/postgrest/postgrest-reader.conf

# Update passwords in config files
read -sp "Enter PostgreSQL password for pltel_writer: " WRITER_PASS
echo
sed -i "s/your_password/$WRITER_PASS/g" /etc/postgrest/postgrest-writer.conf

read -sp "Enter PostgreSQL password for pltel_reader: " READER_PASS
echo
sed -i "s/your_password/$READER_PASS/g" /etc/postgrest/postgrest-reader.conf

# Create systemd service for writer
cat > /etc/systemd/system/postgrest-writer.service <<EOF
[Unit]
Description=PostgREST Writer for PLTelemetry
After=postgresql.service

[Service]
Type=simple
User=postgrest
ExecStart=/usr/bin/postgrest /etc/postgrest/postgrest-writer.conf
ExecReload=/bin/kill -SIGUSR1 \$MAINPID
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

# Create systemd service for reader (optional)
cat > /etc/systemd/system/postgrest-reader.service <<EOF
[Unit]
Description=PostgREST Reader for PLTelemetry
After=postgresql.service

[Service]
Type=simple
User=postgrest
ExecStart=/usr/bin/postgrest /etc/postgrest/postgrest-reader.conf
ExecReload=/bin/kill -SIGUSR1 \$MAINPID
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

# Create postgrest user if not exists
if ! id "postgrest" &>/dev/null; then
    useradd -r -s /bin/false postgrest
fi

# Reload systemd
systemctl daemon-reload

# Enable and start services
echo "Enabling services..."
systemctl enable postgrest-writer.service
systemctl start postgrest-writer.service

echo "Starting reader service (optional)..."
systemctl enable postgrest-reader.service
systemctl start postgrest-reader.service

# Check status
echo ""
echo "=== Service Status ==="
systemctl status postgrest-writer --no-pager
echo ""
systemctl status postgrest-reader --no-pager

echo ""
echo "=== Testing endpoints ==="
sleep 2

# Test writer endpoint
if curl -s http://localhost:3000/ > /dev/null; then
    echo "✓ Writer endpoint (port 3000) is responding"
else
    echo "✗ Writer endpoint (port 3000) is not responding"
fi

# Test reader endpoint
if curl -s http://localhost:3001/ > /dev/null; then
    echo "✓ Reader endpoint (port 3001) is responding"
else
    echo "✗ Reader endpoint (port 3001) is not responding"
fi

echo ""
echo "=== Setup complete! ==="
echo "Writer API: http://localhost:3000"
echo "Reader API: http://localhost:3001"
echo ""
echo "Test with:"
echo "  curl http://localhost:3000/traces"
echo "  curl http://localhost:3001/traces"

# ============================================
# FILE: 06-docker-compose.yml
# Docker Compose setup (alternative to systemd)
# ============================================

version: '3.8'

services:
  # PostgreSQL Database
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: pltelemetry_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres_password
    volumes:
      - ./01-database-setup.sql:/docker-entrypoint-initdb.d/01-database-setup.sql
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # PostgREST Writer
  postgrest-writer:
    image: postgrest/postgrest:latest
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      PGRST_DB_URI: postgres://pltel_writer:writer_password@postgres:5432/pltelemetry_db
      PGRST_DB_SCHEMAS: telemetry
      PGRST_DB_ANON_ROLE: pltel_writer
      PGRST_SERVER_PORT: 3000
    ports:
      - "3000:3000"

  # PostgREST Reader (optional)
  postgrest-reader:
    image: postgrest/postgrest:latest
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      PGRST_DB_URI: postgres://pltel_reader:reader_password@postgres:5432/pltelemetry_db
      PGRST_DB_SCHEMAS: telemetry
      PGRST_DB_ANON_ROLE: pltel_reader
      PGRST_SERVER_PORT: 3001
    ports:
      - "3001:3001"

  # Grafana (optional)
  grafana:
    image: grafana/grafana:latest
    depends_on:
      - postgres
    environment:
      GF_SECURITY_ADMIN_PASSWORD: admin
      GF_USERS_ALLOW_SIGN_UP: false
    ports:
      - "3002:3000"
    volumes:
      - grafana_data:/var/lib/grafana

volumes:
  postgres_data:
  grafana_data:

# ============================================
# FILE: README-postgrest.md
# PostgREST Setup Documentation
# ============================================

# PostgREST Configuration for PLTelemetry

This directory contains the PostgREST configuration files needed to expose
the PostgreSQL telemetry database as a REST API.

## Files

- `02-postgrest-config.conf` - Basic configuration file
- `03-postgrest-writer.conf` - Writer instance configuration (port 3000)
- `04-postgrest-reader.conf` - Reader instance configuration (port 3001)
- `05-postgrest-setup.sh` - Automated setup script
- `06-docker-compose.yml` - Docker-based setup (alternative)

## Quick Start

### Option 1: System Service (Production)

```bash
sudo ./05-postgrest-setup.sh
```

### Option 2: Docker Compose (Development)

```bash
# Update passwords in docker-compose.yml first!
docker-compose up -d
```

### Option 3: Manual Setup

1. Install PostgREST:
   ```bash
   # RedHat/CentOS
   sudo dnf install postgrest
   
   # Ubuntu/Debian
   sudo apt install postgrest
   ```

2. Copy configuration:
   ```bash
   sudo cp 03-postgrest-writer.conf /etc/postgrest/
   ```

3. Update passwords in the config file

4. Start PostgREST:
   ```bash
   postgrest /etc/postgrest/postgrest-writer.conf
   ```

## Configuration Details

### Writer Instance (Port 3000)
- Used by PLT_POSTGRES_BRIDGE for INSERT operations
- User: `pltel_writer`
- Permissions: INSERT, UPDATE on telemetry tables

### Reader Instance (Port 3001)
- Used by Grafana and dashboards
- User: `pltel_reader`  
- Permissions: SELECT only
- Row limit: 1000 (configurable)

## Security Considerations

1. **Network Security**:
   - Use firewall rules to restrict access
   - Consider using a reverse proxy (nginx) for HTTPS
   - Bind to localhost only if not needed externally

2. **Authentication Options**:
   - Basic: PostgreSQL roles (current setup)
   - JWT: Uncomment jwt-secret in config
   - API Key: Implement via reverse proxy

3. **Production Checklist**:
   - [ ] Change default passwords
   - [ ] Enable HTTPS
   - [ ] Set up monitoring
   - [ ] Configure log rotation
   - [ ] Implement rate limiting

## Testing

Test the endpoints:

```bash
# Test writer
curl -X POST http://localhost:3000/traces \
  -H "Content-Type: application/json" \
  -d '{"trace_id":"test123","root_operation":"test"}'

# Test reader
curl http://localhost:3001/traces

# Check OpenAPI spec
curl http://localhost:3000/
```

## Troubleshooting

1. **Connection refused**:
   ```bash
   sudo systemctl status postgrest-writer
   sudo journalctl -u postgrest-writer -f
   ```

2. **Authentication failed**:
   - Check PostgreSQL user passwords
   - Verify user permissions in database

3. **Performance issues**:
   - Increase `db-pool` in config
   - Check PostgreSQL indexes
   - Monitor with `pg_stat_statements`
[END OF FILE: bridges/postgresql/schema/02-postgrest-config.conf]


========================================================================
FILE: bundle-pltelemetry.sh
SIZE: 3494 bytes
MODIFIED: ./bundle-pltelemetry.sh 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550500 1550500 18446744073709551615 -1
2025-06-23 14:28:00.148274100
========================================================================

#!/bin/bash

# bundle-all.sh
# Automatically finds and bundles all project files

OUTPUT_FILE="pltelemetry-complete-bundle.txt"
PROJECT_ROOT="${1:-.}"  # Use first argument or current directory

# Extensions to include
EXTENSIONS="sql pks pkb md txt conf sh yml json"

# Directories to exclude
EXCLUDE_DIRS=".git node_modules target build dist"

# Clear or create output file
> "$OUTPUT_FILE"

# Header
cat << EOF >> "$OUTPUT_FILE"
========================================================================
PLTelemetry Complete Source Bundle
Generated on: $(date)
From: $(pwd)
========================================================================

TABLE OF CONTENTS:
EOF

# First pass: generate table of contents
echo "" >> "$OUTPUT_FILE"
echo "Finding files..."

file_count=0
for ext in $EXTENSIONS; do
    while IFS= read -r file; do
        # Skip excluded directories
        skip=false
        for exclude in $EXCLUDE_DIRS; do
            if [[ "$file" == *"/$exclude/"* ]]; then
                skip=true
                break
            fi
        done
        
        if [ "$skip" = false ]; then
            echo "$file" >> "$OUTPUT_FILE"
            ((file_count++))
        fi
    done < <(find "$PROJECT_ROOT" -type f -name "*.$ext" 2>/dev/null | sort)
done

echo "" >> "$OUTPUT_FILE"
echo "========================================================================" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# Second pass: add file contents
echo "Adding $file_count files to bundle..."

for ext in $EXTENSIONS; do
    while IFS= read -r file; do
        # Skip excluded directories
        skip=false
        for exclude in $EXCLUDE_DIRS; do
            if [[ "$file" == *"/$exclude/"* ]]; then
                skip=true
                break
            fi
        done
        
        if [ "$skip" = false ]; then
            # Remove ./ prefix if present
            display_path="${file#./}"
            
            cat << EOF >> "$OUTPUT_FILE"

========================================================================
FILE: $display_path
SIZE: $(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "unknown") bytes
MODIFIED: $(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$file" 2>/dev/null || stat -c "%y" "$file" 2>/dev/null | cut -d' ' -f1-2 || echo "unknown")
========================================================================

EOF
            cat "$file" >> "$OUTPUT_FILE"
            echo "" >> "$OUTPUT_FILE"
            echo "[END OF FILE: $display_path]" >> "$OUTPUT_FILE"
            echo "" >> "$OUTPUT_FILE"
        fi
    done < <(find "$PROJECT_ROOT" -type f -name "*.$ext" 2>/dev/null | sort)
done

# Summary
cat << EOF >> "$OUTPUT_FILE"

========================================================================
BUNDLE SUMMARY
========================================================================
Total files: $file_count
Bundle size: $(du -h "$OUTPUT_FILE" | cut -f1)
Total lines: $(wc -l < "$OUTPUT_FILE")
Generated: $(date)
========================================================================
EOF

echo "✅ Bundle created: $OUTPUT_FILE"
echo "📊 Statistics:"
echo "   - Files included: $file_count"
echo "   - Bundle size: $(du -h "$OUTPUT_FILE" | cut -f1)"
echo "   - Total lines: $(wc -l < "$OUTPUT_FILE")"

# Optional: Create compressed version
if command -v gzip &> /dev/null; then
    gzip -c "$OUTPUT_FILE" > "${OUTPUT_FILE}.gz"
    echo "   - Compressed: ${OUTPUT_FILE}.gz ($(du -h "${OUTPUT_FILE}.gz" | cut -f1))"
fi
[END OF FILE: bundle-pltelemetry.sh]


========================================================================
FILE: bridge/package.json
SIZE: 901 bytes
MODIFIED: ./bridge/package.json 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550499 1550499 18446744073709551615 -1
2025-06-23 06:16:29.771966300
========================================================================

{
    "name": "pltelemetry-bridge",
    "version": "1.0.0",
    "description": "Node.js bridge to convert PLTelemetry JSON to OpenTelemetry format",
    "main": "src/bridge.js",
    "scripts": {
      "start": "node src/bridge.js",
      "dev": "nodemon src/bridge.js",
      "test": "jest",
      "docker:build": "docker build -f docker/Dockerfile -t pltelemetry-bridge .",
      "docker:run": "docker-compose -f docker/docker-compose.yml up"
    },
    "dependencies": {
      "@opentelemetry/api": "^1.7.0",
      "@opentelemetry/sdk-node": "^0.45.0",
      "@opentelemetry/exporter-trace-otlp-http": "^0.45.0",
      "@opentelemetry/exporter-metrics-otlp-http": "^0.45.0",
      "express": "^4.18.2",
      "cors": "^2.8.5",
      "helmet": "^7.1.0"
    },
    "devDependencies": {
      "nodemon": "^3.0.2",
      "jest": "^29.7.0",
      "supertest": "^6.3.3"
    }
  }
[END OF FILE: bridge/package.json]


========================================================================
FILE: bridges/postgresql/nodejs/package.json
SIZE: 0 bytes
MODIFIED: ./bridges/postgresql/nodejs/package.json 303a0a8900000000 255 3e72eff 4096 4096 13102591 1550499 1550499 18446744073709551615 -1
2025-06-23 14:07:06.135809700
========================================================================


[END OF FILE: bridges/postgresql/nodejs/package.json]


========================================================================
BUNDLE SUMMARY
========================================================================
Total files: 32
Bundle size: 356K
Total lines: 9844
Generated: Mon Jun 23 14:29:37 GMTDT 2025
========================================================================
