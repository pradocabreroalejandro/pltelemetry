-- =====================================================
-- PLTelemetry - Unified DDL (Tables, Indexes, etc.)
-- All DDL operations for PLTelemetry
-- Execute as PLTELEMETRY user
-- =====================================================

SET SERVEROUTPUT ON

PROMPT Creating PLTelemetry complete database structure...

-- =====================================================
-- DROP EXISTING TABLES (for clean reinstall)
-- =====================================================

DECLARE
    l_sql VARCHAR2(1000);
BEGIN
    FOR rec IN (
        SELECT table_name 
        FROM user_tables 
        WHERE table_name IN (
            'PLT_TRACES', 'PLT_SPANS', 'PLT_EVENTS', 'PLT_METRICS', 
            'PLT_FAILED_EXPORTS', 'PLT_QUEUE', 'PLT_TELEMETRY_ERRORS',
            'PLT_LOGS', 'PLT_SPAN_ATTRIBUTES', 'PLT_AGENT_REGISTRY',
            'PLT_FAILOVER_CONFIG', 'PLT_FALLBACK_METRICS', 'PLT_RATE_LIMIT_CONFIG',
            'PLT_PULSE_THROTTLING_CONFIG', 'PLT_SERVICE_DISCOVERY_CONFIG',
            'DB_VALIDATION_TYPES', 'DB_VALIDATION_RULES', 'DB_VALIDATION_RESULTS'
        )
    ) LOOP
        l_sql := 'DROP TABLE ' || rec.table_name || ' CASCADE CONSTRAINTS';
        EXECUTE IMMEDIATE l_sql;
        DBMS_OUTPUT.PUT_LINE('Dropped existing table: ' || rec.table_name);
    END LOOP;
END;
/

-- =====================================================
-- CORE TELEMETRY TABLES
-- =====================================================

-- Main traces table
CREATE TABLE plt_traces (
    trace_id VARCHAR2(32) PRIMARY KEY,
    root_operation VARCHAR2(255) NOT NULL,
    start_time TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    end_time TIMESTAMP WITH TIME ZONE,
    service_name VARCHAR2(100) DEFAULT 'oracle-plsql',
    service_instance VARCHAR2(255),
    tenant_id VARCHAR2(100)
);

COMMENT ON TABLE plt_traces IS 'OpenTelemetry traces - root operations';
COMMENT ON COLUMN plt_traces.trace_id IS '128-bit trace ID (32 hex chars)';
COMMENT ON COLUMN plt_traces.root_operation IS 'Name of the root operation';
COMMENT ON COLUMN plt_traces.service_name IS 'Service identifier';
COMMENT ON COLUMN plt_traces.service_instance IS 'Service instance identifier';
COMMENT ON COLUMN plt_traces.tenant_id IS 'Tenant identifier for multi-tenancy';

-- Spans table
CREATE TABLE plt_spans (
    span_id VARCHAR2(16) PRIMARY KEY,
    trace_id VARCHAR2(32) NOT NULL,
    parent_span_id VARCHAR2(16),
    operation_name VARCHAR2(255) NOT NULL,
    start_time TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    end_time TIMESTAMP WITH TIME ZONE,
    duration_ms NUMBER,
    status VARCHAR2(50) DEFAULT 'RUNNING',
    tenant_id VARCHAR2(100),
    CONSTRAINT fk_spans_trace FOREIGN KEY (trace_id) REFERENCES plt_traces(trace_id),
    CONSTRAINT fk_spans_parent FOREIGN KEY (parent_span_id) REFERENCES plt_spans(span_id),
    CONSTRAINT chk_spans_status CHECK (status IN ('RUNNING', 'OK', 'ERROR', 'CANCELLED'))
);

COMMENT ON TABLE plt_spans IS 'OpenTelemetry spans - individual operations within traces';
COMMENT ON COLUMN plt_spans.span_id IS '64-bit span ID (16 hex chars)';
COMMENT ON COLUMN plt_spans.parent_span_id IS 'Parent span for nested operations';
COMMENT ON COLUMN plt_spans.duration_ms IS 'Span duration in milliseconds';
COMMENT ON COLUMN plt_spans.tenant_id IS 'Tenant identifier for multi-tenancy';

-- Events table
CREATE TABLE plt_events (
    event_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    span_id VARCHAR2(16) NOT NULL,
    event_name VARCHAR2(255) NOT NULL,
    event_time TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    attributes VARCHAR2(4000),
    tenant_id VARCHAR2(100),
    CONSTRAINT fk_events_span FOREIGN KEY (span_id) REFERENCES plt_spans(span_id)
);

COMMENT ON TABLE plt_events IS 'Events within spans - point-in-time occurrences';
COMMENT ON COLUMN plt_events.attributes IS 'JSON attributes for the event';
COMMENT ON COLUMN plt_events.tenant_id IS 'Tenant identifier for multi-tenancy';

-- Metrics table
CREATE TABLE plt_metrics (
    metric_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    metric_name VARCHAR2(255) NOT NULL,
    metric_value NUMBER NOT NULL,
    metric_unit VARCHAR2(50),
    trace_id VARCHAR2(32),
    span_id VARCHAR2(16),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    attributes VARCHAR2(4000),
    tenant_id VARCHAR2(100),
    CONSTRAINT fk_metrics_trace FOREIGN KEY (trace_id) REFERENCES plt_traces(trace_id),
    CONSTRAINT fk_metrics_span FOREIGN KEY (span_id) REFERENCES plt_spans(span_id)
);

COMMENT ON TABLE plt_metrics IS 'Application metrics with telemetry context';
COMMENT ON COLUMN plt_metrics.metric_unit IS 'Unit of measurement (ms, bytes, requests, etc.)';
COMMENT ON COLUMN plt_metrics.attributes IS 'JSON attributes for the metric';
COMMENT ON COLUMN plt_metrics.tenant_id IS 'Tenant identifier for multi-tenancy';

-- Logs table
CREATE TABLE plt_logs (
    log_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    trace_id VARCHAR2(32),
    span_id VARCHAR2(16),
    log_level VARCHAR2(10) NOT NULL,
    message VARCHAR2(4000) NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP,
    attributes VARCHAR2(4000) DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP,
    tenant_id VARCHAR2(100)
);

COMMENT ON TABLE plt_logs IS 'Structured logs with optional trace correlation';
COMMENT ON COLUMN plt_logs.trace_id IS 'Optional trace ID for correlation';
COMMENT ON COLUMN plt_logs.span_id IS 'Optional span ID for correlation';
COMMENT ON COLUMN plt_logs.log_level IS 'Log severity level';
COMMENT ON COLUMN plt_logs.tenant_id IS 'Tenant identifier for multi-tenancy';

-- Span attributes table (normalized attributes for better querying)
CREATE TABLE plt_span_attributes (
    span_id VARCHAR2(16) NOT NULL,
    attribute_key VARCHAR2(255) NOT NULL,
    attribute_value VARCHAR2(4000),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP,
    tenant_id VARCHAR2(100),
    CONSTRAINT plt_span_attr_pk PRIMARY KEY (span_id, attribute_key)
);

COMMENT ON TABLE plt_span_attributes IS 'Normalized span attributes for efficient querying';
COMMENT ON COLUMN plt_span_attributes.span_id IS 'Reference to span (soft FK for flexibility)';
COMMENT ON COLUMN plt_span_attributes.attribute_key IS 'Attribute key name';
COMMENT ON COLUMN plt_span_attributes.attribute_value IS 'Attribute value (up to 4KB)';
COMMENT ON COLUMN plt_span_attributes.tenant_id IS 'Tenant identifier for multi-tenancy';

-- =====================================================
-- ASYNC PROCESSING AND QUEUE TABLES
-- =====================================================

-- Async processing queue
CREATE TABLE plt_queue (
    queue_id NUMBER GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1 
        MAXVALUE 9999999999999999999999999999 
        MINVALUE 1 
        NOCYCLE 
        CACHE 20 
        NOORDER 
        NOKEEP
    ) NOT NULL,
    payload VARCHAR2(4000) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    processed CHAR(1) DEFAULT 'N' NOT NULL,
    process_attempts NUMBER DEFAULT 0 NOT NULL,
    processed_time TIMESTAMP WITH TIME ZONE,
    last_error VARCHAR2(4000),
    last_attempt_time TIMESTAMP WITH TIME ZONE,
    tenant_id VARCHAR2(100),
    CONSTRAINT pk_plt_queue PRIMARY KEY (queue_id),
    CONSTRAINT chk_plt_queue_processed CHECK (processed IN ('Y', 'N'))
);

COMMENT ON TABLE plt_queue IS 'Async processing queue for telemetry export';
COMMENT ON COLUMN plt_queue.payload IS 'JSON payload to be exported';
COMMENT ON COLUMN plt_queue.process_attempts IS 'Number of processing attempts (max 3)';
COMMENT ON COLUMN plt_queue.tenant_id IS 'Tenant identifier for multi-tenancy';

-- Failed exports table
CREATE TABLE plt_failed_exports (
    export_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    export_time TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    http_status NUMBER,
    payload VARCHAR2(4000),
    error_message VARCHAR2(4000),
    retry_count NUMBER DEFAULT 0,
    last_retry TIMESTAMP WITH TIME ZONE,
    tenant_id VARCHAR2(100)
);

COMMENT ON TABLE plt_failed_exports IS 'Failed telemetry export attempts for debugging';
COMMENT ON COLUMN plt_failed_exports.payload IS 'Truncated payload that failed to export';
COMMENT ON COLUMN plt_failed_exports.tenant_id IS 'Tenant identifier for multi-tenancy';

-- =====================================================
-- ERROR TRACKING AND MONITORING
-- =====================================================

-- Error logging table
CREATE TABLE plt_telemetry_errors (
    error_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    error_time TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
    error_message VARCHAR2(4000),
    error_stack VARCHAR2(4000),
    error_code NUMBER,
    module_name VARCHAR2(100),
    trace_id VARCHAR2(32),
    span_id VARCHAR2(16),
    session_user VARCHAR2(128) DEFAULT USER,
    os_user VARCHAR2(128) DEFAULT SYS_CONTEXT('USERENV', 'OS_USER'),
    host VARCHAR2(256) DEFAULT SYS_CONTEXT('USERENV', 'HOST'),
    ip_address VARCHAR2(45) DEFAULT SYS_CONTEXT('USERENV', 'IP_ADDRESS'),
    tenant_id VARCHAR2(100)
);

COMMENT ON TABLE plt_telemetry_errors IS 'Internal error logging for PLTelemetry operations';
COMMENT ON COLUMN plt_telemetry_errors.module_name IS 'PLTelemetry module where error occurred';
COMMENT ON COLUMN plt_telemetry_errors.tenant_id IS 'Tenant identifier for multi-tenancy';

-- =====================================================
-- AGENT AND FAILOVER MANAGEMENT
-- =====================================================

-- Agent registry table
CREATE TABLE plt_agent_registry (
    agent_id VARCHAR2(100) DEFAULT 'PRIMARY' PRIMARY KEY,
    last_heartbeat TIMESTAMP WITH TIME ZONE,
    last_process_time TIMESTAMP WITH TIME ZONE,
    items_processed NUMBER DEFAULT 0,
    items_planned NUMBER DEFAULT 0,
    process_interval NUMBER DEFAULT 60, -- seconds
    next_run_expected TIMESTAMP WITH TIME ZONE,
    status_message VARCHAR2(4000),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP
);

COMMENT ON TABLE plt_agent_registry IS 'External agent registry and health tracking';
COMMENT ON COLUMN plt_agent_registry.agent_id IS 'Unique agent identifier';
COMMENT ON COLUMN plt_agent_registry.process_interval IS 'Processing interval in seconds';

-- Failover configuration table
CREATE TABLE plt_failover_config (
    config_key VARCHAR2(50) PRIMARY KEY,
    config_value VARCHAR2(200) NOT NULL,
    description VARCHAR2(500),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP
);

COMMENT ON TABLE plt_failover_config IS 'Configuration for failover mechanism';
COMMENT ON COLUMN plt_failover_config.config_key IS 'Configuration parameter name';
COMMENT ON COLUMN plt_failover_config.config_value IS 'Configuration parameter value';

-- Fallback metrics table
CREATE TABLE plt_fallback_metrics (
    metric_time TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP,
    batch_size NUMBER,
    items_processed NUMBER,
    items_failed NUMBER,
    avg_latency_ms NUMBER,
    http_errors NUMBER,
    total_duration_ms NUMBER
);

COMMENT ON TABLE plt_fallback_metrics IS 'Performance metrics for fallback processing';

-- Rate limit configuration table
CREATE TABLE plt_rate_limit_config (
    latency_threshold_ms NUMBER NOT NULL,
    optimal_batch_size NUMBER NOT NULL,
    priority NUMBER NOT NULL,  -- Lower number = higher priority
    description VARCHAR2(200),
    is_active VARCHAR2(1) DEFAULT 'Y',
    CONSTRAINT plt_rate_limit_pk PRIMARY KEY (priority),
    CONSTRAINT plt_rate_limit_chk CHECK (latency_threshold_ms >= 0),
    CONSTRAINT plt_rate_limit_size_chk CHECK (optimal_batch_size > 0)
);

COMMENT ON TABLE plt_rate_limit_config IS 'Dynamic rate limiting configuration';

-- =====================================================
-- PULSE THROTTLING SYSTEM
-- =====================================================

-- Pulse throttling configuration table
CREATE TABLE plt_pulse_throttling_config (
    pulse_mode VARCHAR2(10) PRIMARY KEY,
    capacity_multiplier NUMBER(5,4) NOT NULL,
    batch_multiplier NUMBER(5,4) NOT NULL, 
    interval_multiplier NUMBER(5,2) NOT NULL,
    sampling_rate NUMBER(5,4) NOT NULL,
    metrics_enabled VARCHAR2(1) DEFAULT 'Y' CHECK (metrics_enabled IN ('Y', 'N')),
    logs_enabled VARCHAR2(1) DEFAULT 'Y' CHECK (logs_enabled IN ('Y', 'N')),
    queue_processing VARCHAR2(1) DEFAULT 'Y' CHECK (queue_processing IN ('Y', 'N')),
    description VARCHAR2(200),
    is_active VARCHAR2(1) DEFAULT 'Y' CHECK (is_active IN ('Y', 'N')),
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP
);

COMMENT ON TABLE plt_pulse_throttling_config IS 'Pulse mode throttling configuration for coordinated capacity management';
COMMENT ON COLUMN plt_pulse_throttling_config.pulse_mode IS 'Pulse mode from Go agent: PULSE1, PULSE2, PULSE3, PULSE4, COMA';
COMMENT ON COLUMN plt_pulse_throttling_config.capacity_multiplier IS 'Overall system capacity multiplier (0.0-1.0)';
COMMENT ON COLUMN plt_pulse_throttling_config.batch_multiplier IS 'Batch size multiplier for queue processing';
COMMENT ON COLUMN plt_pulse_throttling_config.interval_multiplier IS 'Scheduler interval multiplier (>1 = slower)';
COMMENT ON COLUMN plt_pulse_throttling_config.sampling_rate IS 'Telemetry sampling rate (0.0-1.0, 1.0=100%)';

-- =====================================================
-- SERVICE DISCOVERY AND MONITORING
-- =====================================================

-- Service discovery criticality levels configuration
CREATE TABLE plt_service_discovery_crit_levels (
    criticality_code VARCHAR2(10) PRIMARY KEY,
    description VARCHAR2(100) NOT NULL,
    check_interval_minutes NUMBER NOT NULL,
    escalation_multiplier NUMBER DEFAULT 0.5,
    max_escalation_failures NUMBER DEFAULT 3,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP
);

COMMENT ON TABLE plt_service_discovery_crit_levels IS 'Service discovery criticality levels and check intervals';
COMMENT ON COLUMN plt_service_discovery_crit_levels.escalation_multiplier IS 'Multiplier to reduce interval on failures (0.5 = half interval)';

-- Service discovery configuration table with enhanced custom monitoring support
CREATE TABLE plt_service_discovery_config (
    service_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    service_name VARCHAR2(50) UNIQUE NOT NULL,
    service_description VARCHAR2(200),
    endpoint_url VARCHAR2(300) NOT NULL,
    criticality_code VARCHAR2(10) NOT NULL,
    timeout_seconds NUMBER DEFAULT 10,
    is_enabled NUMBER(1) DEFAULT 1,
    service_type VARCHAR2(50) DEFAULT 'ENDPOINT' NOT NULL,
    custom_plan_yaml VARCHAR2(4000),
    custom_plan_json VARCHAR2(4000),
    yaml_hash VARCHAR2(64),
    last_yaml_check TIMESTAMP(6),
    tenant_id VARCHAR2(100), -- Multi-tenant support
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    last_check_time TIMESTAMP,
    consecutive_failures NUMBER DEFAULT 0,
    last_success_time TIMESTAMP,
    last_failure_reason VARCHAR2(500),
    -- Constraints
    CONSTRAINT fk_svc_disc_criticality FOREIGN KEY (criticality_code)
        REFERENCES plt_service_discovery_crit_levels(criticality_code),
    CONSTRAINT chk_svc_disc_enabled CHECK (is_enabled IN (0, 1)),
    CONSTRAINT chk_svc_disc_timeout CHECK (timeout_seconds > 0),
    CONSTRAINT chk_svc_disc_failures CHECK (consecutive_failures >= 0)
);

COMMENT ON TABLE plt_service_discovery_config IS 'Service discovery endpoint configuration and health status with custom monitoring support';
COMMENT ON COLUMN plt_service_discovery_config.tenant_id IS 'Tenant identifier for multi-tenant environments';
COMMENT ON COLUMN plt_service_discovery_config.service_type IS 'Type of service being monitored (ENDPOINT, CUSTOM)';
COMMENT ON COLUMN plt_service_discovery_config.custom_plan_yaml IS 'YAML configuration for custom service monitoring plans (when SERVICE_TYPE = CUSTOM)';
COMMENT ON COLUMN plt_service_discovery_config.custom_plan_json IS 'JSON configuration for custom service monitoring plans (when SERVICE_TYPE = CUSTOM)';
COMMENT ON COLUMN plt_service_discovery_config.yaml_hash IS 'SHA256 hash of CUSTOM_PLAN_YAML for change detection';
COMMENT ON COLUMN plt_service_discovery_config.last_yaml_check IS 'Last time DataPerro checked/converted this YAML';

-- =====================================================
-- DATABASE MONITORING SYSTEM
-- =====================================================

-- Database validation types table
CREATE TABLE db_validation_types (
    validation_type_code VARCHAR2(50) PRIMARY KEY,
    description VARCHAR2(255) NOT NULL,
    validation_procedure VARCHAR2(100) NOT NULL,
    default_check_interval_minutes NUMBER DEFAULT 5,
    is_active NUMBER(1) DEFAULT 1,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP
);

COMMENT ON TABLE db_validation_types IS 'Database validation type definitions';

-- Database validation rules table
CREATE TABLE db_validation_rules (
    rule_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    validation_type_code VARCHAR2(50) NOT NULL,
    rule_name VARCHAR2(100) NOT NULL,
    target_name VARCHAR2(100),
    warning_threshold NUMBER,
    critical_threshold NUMBER,
    check_interval_minutes NUMBER,
    is_active NUMBER(1) DEFAULT 1,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    updated_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT fk_validation_type FOREIGN KEY (validation_type_code) 
        REFERENCES db_validation_types(validation_type_code)
);

COMMENT ON TABLE db_validation_rules IS 'Database validation rules configuration';

-- Database validation results table
CREATE TABLE db_validation_results (
    result_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    rule_id NUMBER NOT NULL,
    check_timestamp TIMESTAMP DEFAULT SYSTIMESTAMP,
    actual_value NUMBER,
    status VARCHAR2(20), -- OK, WARNING, CRITICAL, ERROR
    message VARCHAR2(1000),
    execution_time_ms NUMBER,
    CONSTRAINT fk_validation_rule FOREIGN KEY (rule_id) 
        REFERENCES db_validation_rules(rule_id)
);

COMMENT ON TABLE db_validation_results IS 'Database validation execution results';

-- =====================================================
-- OBJECT TYPES
-- =====================================================

-- Pulse throttling configuration type
CREATE OR REPLACE TYPE plt_pulse_config_t AS OBJECT (
    pulse_mode VARCHAR2(10),
    capacity_multiplier NUMBER,
    batch_multiplier NUMBER,
    interval_multiplier NUMBER,
    sampling_rate NUMBER,
    metrics_enabled VARCHAR2(1),
    logs_enabled VARCHAR2(1),
    queue_processing VARCHAR2(1),
    description VARCHAR2(200)
);
/

-- =====================================================
-- PERFORMANCE INDEXES
-- =====================================================

PROMPT Creating performance indexes...

-- Traces indexes (tenant-aware)
CREATE INDEX idx_plt_traces_start_time ON plt_traces(start_time);
CREATE INDEX idx_plt_traces_service ON plt_traces(service_name, start_time);
CREATE INDEX idx_plt_traces_operation ON plt_traces(root_operation, start_time);
CREATE INDEX idx_plt_traces_tenant ON plt_traces(tenant_id, start_time);
CREATE INDEX idx_plt_traces_tenant_op ON plt_traces(tenant_id, root_operation, start_time);

-- Spans indexes (tenant-aware)
CREATE INDEX idx_plt_spans_trace_id ON plt_spans(trace_id, start_time);
CREATE INDEX idx_plt_spans_parent ON plt_spans(parent_span_id, start_time);
CREATE INDEX idx_plt_spans_operation ON plt_spans(operation_name, start_time);
CREATE INDEX idx_plt_spans_status ON plt_spans(status, start_time);
CREATE INDEX idx_plt_spans_duration ON plt_spans(duration_ms);
CREATE INDEX idx_plt_spans_tenant ON plt_spans(tenant_id, start_time);
CREATE INDEX idx_plt_spans_tenant_op ON plt_spans(tenant_id, operation_name, start_time);
CREATE INDEX idx_plt_spans_tenant_status ON plt_spans(tenant_id, status, start_time);

-- Events indexes (tenant-aware)
CREATE INDEX idx_plt_events_span_id ON plt_events(span_id, event_time);
CREATE INDEX idx_plt_events_name ON plt_events(event_name, event_time);
CREATE INDEX idx_plt_events_time ON plt_events(event_time);
CREATE INDEX idx_plt_events_tenant ON plt_events(tenant_id, event_time);

-- Metrics indexes (tenant-aware) - CRITICAL for enterprise dashboards
CREATE INDEX idx_plt_metrics_name ON plt_metrics(metric_name, timestamp);
CREATE INDEX idx_plt_metrics_trace ON plt_metrics(trace_id, timestamp);
CREATE INDEX idx_plt_metrics_span ON plt_metrics(span_id, timestamp);
CREATE INDEX idx_plt_metrics_time ON plt_metrics(timestamp);
CREATE INDEX idx_plt_metrics_value ON plt_metrics(metric_name, metric_value, timestamp);
CREATE INDEX idx_plt_metrics_tenant ON plt_metrics(tenant_id, timestamp);
CREATE INDEX idx_plt_metrics_tenant_name ON plt_metrics(tenant_id, metric_name, timestamp);
CREATE INDEX idx_plt_metrics_tenant_daily ON plt_metrics(tenant_id, TRUNC(timestamp), metric_name);

-- Queue indexes (tenant-aware for async processing)
CREATE INDEX idx_plt_queue_processed ON plt_queue(processed, process_attempts, created_at);
CREATE INDEX idx_plt_queue_created ON plt_queue(created_at);
CREATE INDEX idx_plt_queue_processed_time ON plt_queue(processed_time);
CREATE INDEX idx_plt_queue_attempts ON plt_queue(process_attempts, last_attempt_time);
CREATE INDEX idx_plt_queue_tenant ON plt_queue(tenant_id, processed, created_at);

-- Failed exports indexes (tenant-aware)
CREATE INDEX idx_plt_failed_exports_time ON plt_failed_exports(export_time);
CREATE INDEX idx_plt_failed_exports_status ON plt_failed_exports(http_status, export_time);
CREATE INDEX idx_plt_failed_exports_retry ON plt_failed_exports(retry_count, last_retry);
CREATE INDEX idx_plt_failed_exports_tenant ON plt_failed_exports(tenant_id, export_time);

-- Error logging indexes (tenant-aware)
CREATE INDEX idx_plt_telemetry_errors_time ON plt_telemetry_errors(error_time);
CREATE INDEX idx_plt_telemetry_errors_trace ON plt_telemetry_errors(trace_id);
CREATE INDEX idx_plt_telemetry_errors_span ON plt_telemetry_errors(span_id);
CREATE INDEX idx_plt_telemetry_errors_module ON plt_telemetry_errors(module_name, error_time);
CREATE INDEX idx_plt_telemetry_errors_code ON plt_telemetry_errors(error_code, error_time);
CREATE INDEX idx_plt_telemetry_errors_tenant ON plt_telemetry_errors(tenant_id, error_time);

-- Logs indexes (tenant-aware) - CRITICAL for enterprise log analysis
CREATE INDEX idx_plt_logs_trace_id ON plt_logs(trace_id);
CREATE INDEX idx_plt_logs_span_id ON plt_logs(span_id);
CREATE INDEX idx_plt_logs_timestamp ON plt_logs(timestamp);
CREATE INDEX idx_plt_logs_level_time ON plt_logs(log_level, timestamp);
CREATE INDEX idx_plt_logs_tenant ON plt_logs(tenant_id, timestamp);
CREATE INDEX idx_plt_logs_tenant_level ON plt_logs(tenant_id, log_level, timestamp);
CREATE INDEX idx_plt_logs_tenant_daily ON plt_logs(tenant_id, TRUNC(timestamp), log_level);

-- Span attributes indexes (tenant-aware)
CREATE INDEX plt_span_attr_span_idx ON plt_span_attributes(span_id);
CREATE INDEX plt_span_attr_key_idx ON plt_span_attributes(attribute_key);
CREATE INDEX plt_span_attr_value_idx ON plt_span_attributes(attribute_key, attribute_value);
CREATE INDEX plt_span_attr_tenant_idx ON plt_span_attributes(tenant_id, attribute_key);

-- Composite indexes for common query patterns
CREATE INDEX idx_plt_trace_span_lookup ON plt_spans(trace_id, span_id);
CREATE INDEX idx_plt_active_spans ON plt_spans(trace_id, end_time);
CREATE INDEX idx_plt_error_spans ON plt_spans(trace_id, status);

-- Function-based indexes for common operations
CREATE INDEX idx_plt_queue_failed ON plt_queue(CASE WHEN process_attempts >= 3 THEN process_attempts END);
CREATE INDEX idx_plt_queue_pending ON plt_queue(CASE WHEN processed = 'N' THEN created_at END);

-- Pulse throttling indexes
CREATE INDEX idx_plt_pulse_config_active ON plt_pulse_throttling_config(is_active, pulse_mode);

-- Service discovery indexes (enhanced with service_type)
CREATE INDEX idx_plt_svc_disc_enabled ON plt_service_discovery_config(is_enabled, criticality_code);
CREATE INDEX idx_plt_svc_disc_tenant ON plt_service_discovery_config(tenant_id, is_enabled);
CREATE INDEX idx_plt_svc_disc_last_check ON plt_service_discovery_config(last_check_time);
CREATE INDEX idx_plt_svc_disc_failures ON plt_service_discovery_config(consecutive_failures, is_enabled);
CREATE INDEX idx_plt_svc_disc_criticality ON plt_service_discovery_config(criticality_code, is_enabled);
CREATE INDEX idx_plt_svc_disc_next_check ON plt_service_discovery_config(
    CASE WHEN is_enabled = 1 THEN last_check_time END,
    criticality_code
);
CREATE INDEX idx_plt_svc_discovery_type ON plt_service_discovery_config(service_type, is_enabled);
CREATE INDEX idx_plt_svc_disc_yaml_hash ON plt_service_discovery_config(yaml_hash, last_yaml_check);

-- Criticality levels indexes
CREATE INDEX idx_plt_svc_crit_interval ON plt_service_discovery_crit_levels(check_interval_minutes);

-- Fallback metrics indexes
CREATE INDEX idx_fallback_metrics_time ON plt_fallback_metrics(metric_time DESC);

-- Database monitoring indexes
CREATE INDEX idx_db_validation_results_time ON db_validation_results(check_timestamp);
CREATE INDEX idx_db_validation_results_rule ON db_validation_results(rule_id, check_timestamp);
CREATE INDEX idx_db_validation_results_status ON db_validation_results(status, check_timestamp);

PROMPT
PROMPT =====================================================
PROMPT PLTelemetry DDL Installation Complete
PROMPT =====================================================
PROMPT 
PROMPT Tables created:
PROMPT - Core telemetry: traces, spans, events, metrics, logs
PROMPT - Processing: queue, failed_exports, agent_registry
PROMPT - Configuration: failover_config, pulse_throttling_config
PROMPT - Monitoring: service_discovery_config, db_validation_*
PROMPT - Performance: 50+ indexes for optimal query performance
PROMPT 
PROMPT Enhanced features:
PROMPT - Service discovery with custom monitoring plans (YAML/JSON)
PROMPT - DataPerro integration support with hash tracking
PROMPT - Multi-tenant architecture throughout
PROMPT 
PROMPT Next step: Run DML script to insert configuration data
PROMPT =====================================================